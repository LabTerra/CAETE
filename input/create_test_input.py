"""
Create a test NetCDF input file for CAETE unit tests.

This script generates a dummy dataset compatible with the station-based
CAETE input format. The file contains a single gridcell (station) with
reasonable values for all variables.

Usage:
    python create_test_input.py [output_file] [n_stations] [n_days]

Examples:
    python create_test_input.py  # Creates test_input.nc with 1 station, 365 days
    python create_test_input.py test_input.nc 2 730  # 2 stations, 2 years
"""

import numpy as np
import netCDF4 as nc
from datetime import datetime
import sys


def create_test_input(
    output_file: str = "test_input.nc",
    n_stations: int = 1,
    n_days: int = 365,
    start_year: int = 1901
) -> None:
    """
    Create a test NetCDF input file for CAETE.

    Args:
        output_file: Output file path
        n_stations: Number of stations (gridcells)
        n_days: Number of days in the time series
        start_year: Starting year for the time series
    """

    # Create the NetCDF file
    ds = nc.Dataset(output_file, "w", format="NETCDF4")

    # Global attributes
    ds.description = "CAETE test input data - synthetic dataset for unit tests"
    ds.reference = "Generated by create_test_input.py"
    ds.featureType = "timeSeries"
    ds.created = f"Created by create_test_input.py on {datetime.now().isoformat()}"

    # Dimensions
    ds.createDimension("time", None)  # Unlimited
    ds.createDimension("station", n_stations)
    ds.createDimension("string_length", 15)

    # Time variable
    time_var = ds.createVariable("time", "f4", ("time",), chunksizes=(min(1024, n_days),))
    time_var.units = f"days since {start_year}-1-1 00:00:00"
    time_var.calendar = "proleptic_gregorian"
    time_var.standard_name = "time"
    time_var.axis = "T"
    time_var[:] = np.arange(n_days, dtype=np.float32)

    # Station index variable
    station_var = ds.createVariable("station", "i4", ("station",))
    station_var.long_name = "Station index"
    station_var.cf_role = "timeseries_id"
    station_var[:] = np.arange(n_stations, dtype=np.int32)

    # Latitude variable - Amazon region default
    lat_var = ds.createVariable("lat", "f4", ("station",))
    lat_var.units = "degrees_north"
    lat_var.long_name = "Latitude"
    lat_var.standard_name = "latitude"
    lat_var.axis = "X"
    # Default: spread stations around central Amazon starting at -2.75
    lat_var[:] = np.linspace(-2.75, -2.75 - (n_stations - 1) * 0.5, n_stations).astype(np.float32)

    # Longitude variable
    lon_var = ds.createVariable("lon", "f4", ("station",))
    lon_var.units = "degrees_east"
    lon_var.long_name = "Longitude"
    lon_var.standard_name = "longitude"
    lon_var[:] = np.linspace(-61.75, -61.75 + (n_stations - 1) * 0.5, n_stations).astype(np.float32)

    # Station name variable - using global_y-global_x format (starting at 185-236)
    station_name_var = ds.createVariable("station_name", "S1", ("station", "string_length"))
    station_name_var.long_name = "Station identifier"
    station_name_var.cf_role = "timeseries_id"
    for i in range(n_stations):
        global_y = 185 + i  # Starting at global_y=185
        global_x = 236 + i  # Starting at global_x=236
        name = f"station_{global_y}-{global_x}".ljust(15)[:15]
        station_name_var[i, :] = nc.stringtochar(np.array([name], dtype="S15"))

    # Helper function to create time-varying variables
    def create_time_var(name, units, standard_name, long_name, data):
        var = ds.createVariable(
            name, "f4", ("time", "station"),
            fill_value=1.0e20,
            chunksizes=(n_days, min(128, n_stations)),
            shuffle=True,
            zlib=True,
            complevel=1
        )
        var.units = units
        var.standard_name = standard_name
        var.long_name = long_name
        var.coordinates = "lat lon"
        var[:] = data
        return var

    # Helper function to create station-only variables
    def create_station_var(name, units, long_name, data):
        var = ds.createVariable(name, "f4", ("station",), fill_value=1.0e20)
        var.units = units
        var.long_name = long_name
        var.coordinates = "lat lon"
        var[:] = data
        return var

    # Generate day of year for seasonal patterns
    doy = np.arange(n_days) % 365

    # Create realistic seasonal patterns (tropical Amazon)
    # Temperature: ~25-28Â°C with small seasonal variation
    tas_base = 26.0 + 2.0 * np.sin(2 * np.pi * doy / 365)  # Seasonal cycle
    tas_noise = np.random.normal(0, 1.5, (n_days, n_stations))  # Daily variability
    tas_data = (tas_base[:, np.newaxis] + tas_noise).astype(np.float32)
    tas_data = np.clip(tas_data, 18.0, 38.0)  # Reasonable bounds

    # Precipitation: ~5-15 mm/day with wet/dry season
    # Wet season: Dec-May (higher), Dry season: Jun-Nov (lower)
    pr_seasonal = 8.0 + 6.0 * np.cos(2 * np.pi * (doy - 15) / 365)  # Peak in Jan
    pr_noise = np.random.exponential(3.0, (n_days, n_stations))  # Rain events
    pr_data = (pr_seasonal[:, np.newaxis] + pr_noise).astype(np.float32)
    pr_data = np.clip(pr_data, 0.0, 100.0)  # No negative rain, cap at 100 mm/day
    # Add some dry days
    dry_mask = np.random.random((n_days, n_stations)) < 0.3
    pr_data[dry_mask] = 0.0

    # Surface pressure: ~1000-1015 hPa (Amazon lowlands)
    ps_base = 1008.0 + 3.0 * np.sin(2 * np.pi * doy / 365)
    ps_noise = np.random.normal(0, 2.0, (n_days, n_stations))
    ps_data = (ps_base[:, np.newaxis] + ps_noise).astype(np.float32)
    ps_data = np.clip(ps_data, 980.0, 1030.0)

    # Relative humidity: ~0.7-0.95 (tropical rainforest)
    hurs_base = 0.85 + 0.05 * np.cos(2 * np.pi * (doy - 15) / 365)  # Higher in wet season
    hurs_noise = np.random.normal(0, 0.05, (n_days, n_stations))
    hurs_data = (hurs_base[:, np.newaxis] + hurs_noise).astype(np.float32)
    hurs_data = np.clip(hurs_data, 0.4, 1.0)

    # Shortwave radiation: ~15-45 mol m-2 day-1 (PAR equivalent)
    # Lower in wet season (clouds), higher in dry season
    rsds_base = 30.0 - 10.0 * np.cos(2 * np.pi * (doy - 15) / 365)
    rsds_noise = np.random.normal(0, 5.0, (n_days, n_stations))
    rsds_data = (rsds_base[:, np.newaxis] + rsds_noise).astype(np.float32)
    rsds_data = np.clip(rsds_data, 5.0, 60.0)
    # Reduce radiation on rainy days
    rsds_data[pr_data > 10.0] *= 0.6

    # Vapor pressure deficit: ~0.3-1.5 kPa
    # Higher in dry season, lower in wet season
    vpd_base = 0.8 - 0.3 * np.cos(2 * np.pi * (doy - 15) / 365)
    vpd_noise = np.random.normal(0, 0.15, (n_days, n_stations))
    vpd_data = (vpd_base[:, np.newaxis] + vpd_noise).astype(np.float32)
    vpd_data = np.clip(vpd_data, 0.1, 3.0)

    # Create time-varying variables
    create_time_var("tas", "degC", "air_temperature", "TAS for CAETE", tas_data)
    create_time_var("pr", "mm day-1", "precipitation_flux", "PR for CAETE", pr_data)
    create_time_var("ps", "hPa", "surface_air_pressure", "PS for CAETE", ps_data)
    create_time_var("hurs", "1", "relative_humidity", "HURS for CAETE", hurs_data)
    create_time_var("rsds", "mol m-2 day-1", "surface_downwelling_shortwave_flux_in_air", "RSDS for CAETE", rsds_data)
    create_time_var("vpd", "kPa", "vapor_pressure_deficit", "Vapor Pressure Deficit for CAETE", vpd_data)

    # Soil nutrient variables (station-only, typical Amazon values)
    # Based on literature values for tropical soils

    # Total Nitrogen: ~100-500 g m-2 (top 30cm)
    tn_data = np.random.uniform(150.0, 400.0, n_stations).astype(np.float32)

    # Total Phosphorus: ~20-100 g m-2 (tropical soils are often P-limited)
    tp_data = np.random.uniform(30.0, 80.0, n_stations).astype(np.float32)

    # Available Phosphorus: ~0.5-5 g m-2 (very low in tropical soils)
    ap_data = np.random.uniform(1.0, 4.0, n_stations).astype(np.float32)

    # Inorganic Phosphorus: ~5-30 g m-2
    ip_data = np.random.uniform(8.0, 25.0, n_stations).astype(np.float32)

    # Organic Phosphorus: ~10-50 g m-2 (makes up most of soil P in tropics)
    op_data = tp_data - ap_data - ip_data
    op_data = np.clip(op_data, 5.0, 50.0).astype(np.float32)

    create_station_var("tn", "g m-2", "TN for CAETE", tn_data)
    create_station_var("tp", "g m-2", "TP for CAETE", tp_data)
    create_station_var("ap", "g m-2", "AP for CAETE", ap_data)
    create_station_var("ip", "g m-2", "IP for CAETE", ip_data)
    create_station_var("op", "g m-2", "OP for CAETE", op_data)

    ds.close()
    print(f"Created test input file: {output_file}")
    print(f"  Stations: {n_stations}")
    print(f"  Time steps: {n_days} days")
    print(f"  Start year: {start_year}")


if __name__ == "__main__":
    # Parse command line arguments
    output_file = sys.argv[1] if len(sys.argv) > 1 else "test_input.nc"
    n_stations = int(sys.argv[2]) if len(sys.argv) > 2 else 1
    n_days = int(sys.argv[3]) if len(sys.argv) > 3 else 365

    create_test_input(output_file, n_stations, n_days)
