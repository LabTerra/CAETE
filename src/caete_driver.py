# -*- coding: utf-8 -*-
# CAETÊ - Carbon and Ecosystem Functional-Trait Evolution Model
# Author: João Paulo Darela Filho

"""CAETÊ Model Driver Script.

This script demonstrates the complete workflow for running the CAETÊ model,
including spinup, transient climate simulations, and output generation.

Workflow Overview:
    1. Region Initialization - Load input data and create the simulation region
    2. Spinup - Equilibrate soil carbon pools using repeated spinup climate
    3. Transclim Run - Run model with transitional climate (~1850-1900)
    4. State Checkpoint - Save model state for potential restarts
    5. Prepare Transient - Update input to observational climate data
    6. Transient Run - Run model with historical climate (1901-2024)
    7. Finalize - Clean state and export results

Usage:
    Run this script directly from the src/ directory:
        $ python caete_driver.py

Output Files:
    - {region_name}_after_spinup_state_file.psz : State after spinup (restartable)
    - {region_name}_result.psz : Final simulation results
    - ../outputs/ : NetCDF and other output formats, including serialized "spin" files, and state files.

Copyright 2017- LabTerra

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

import multiprocessing as mp
from pathlib import Path

from polars import read_csv

# All simulation code must be inside the if __name__ == "__main__" block.
# This is required for multiprocessing with the 'spawn' method, which is
# used to ensure compatibility across Linux and Windows platforms.
# See: https://docs.python.org/3/library/multiprocessing.html#contexts-and-start-methods

if __name__ == "__main__":

    import time

    from metacommunity import pls_table
    from parameters import hsoil, ssoil, tsoil
    from region import region
    from worker import worker

    time_start = time.time()

    # Force 'spawn' start method for multiprocessing compatibility.
    # This must be called before any multiprocessing operations.
    mp.set_start_method('spawn', force=True)

    # Worker instance provides gridcell-level functions (spinup, transient runs, etc.)
    fn: worker = worker()

    # -------------------------------------------------------------------------
    # CONFIGURATION
    # -------------------------------------------------------------------------

    # Region identifier - used for output file naming
    region_name = "pan_amazon_hist_5"

    # Climate input files (NetCDF format)
    obsclim_files = "../input/20CRv3-ERA5/obsclim/caete_input_20CRv3-ERA5_obsclim.nc"
    spinclim_files = "../input/20CRv3-ERA5/spinclim/caete_input_20CRv3-ERA5_spinclim.nc"

    # Gridlist defines which gridcells to simulate
    gridlist = read_csv("../grd/gridlist_test.csv")

    # Soil hydraulic parameters (wilting point, field capacity, saturation)
    # TODO: Reconcile with soil hydrology model parameters
    soil_tuple = tsoil, ssoil, hsoil

    # Atmospheric CO2 concentration time series (CSV: year, ppm)
    co2_path = Path("../input/co2/historical_CO2_annual_1765-2024.csv")

    # PLS (Plant Life Strategy) table - defines all possible functional types
    # Generated by plsgen.py using table_gen function
    PLS_TABLE_PATH = Path("./PLS_MAIN/pls_attrs-5000.csv")
    assert PLS_TABLE_PATH.exists(), f"PLS table not found at {PLS_TABLE_PATH.resolve()}"

    main_table = pls_table.read_pls_table(PLS_TABLE_PATH)

    # -------------------------------------------------------------------------
    # HELPER FUNCTIONS
    # -------------------------------------------------------------------------

    def format_time(seconds: float) -> str:
        """Format elapsed time in human-readable format.

        Args:
            seconds: Elapsed time in seconds.

        Returns:
            Formatted string like "01h 23m 45s" or "23m 45s".
        """
        hours, remainder = divmod(int(seconds), 3600)
        minutes, secs = divmod(remainder, 60)
        if hours > 0:
            return f"{hours:02d}h {minutes:02d}m {secs:02d}s"
        return f"{minutes:02d}m {secs:02d}s"

    # -------------------------------------------------------------------------
    # SIMULATION HEADER
    # -------------------------------------------------------------------------
    print("\n" + "=" * 70)
    print("  CAETÊ MODEL - Simulation Driver")
    print("=" * 70)
    print(f"  Region: {region_name}")
    print(f"  Gridcells: {len(gridlist)}")
    print("=" * 70 + "\n")

    # =========================================================================
    # PHASE 1: Region Initialization
    # =========================================================================
    print("[1/7] Initializing region with spinclim files...")
    pan_amazon = region(region_name,
                        spinclim_files,
                        soil_tuple,
                        co2_path,
                        main_table,
                        gridlist=gridlist)
    print("      Region initialized successfully.\n")

    # =========================================================================
    # PHASE 2: Spinup - Equilibrate soil carbon pools
    # =========================================================================
    print("[2/7] Running spinup...")
    s1 = time.perf_counter()

    pan_amazon.run_region_map(fn.spinup)

    e1 = time.perf_counter()
    print(f"      ✓ Spinup completed in {format_time(e1 - s1)}\n")

    # =========================================================================
    # PHASE 3: Transclim Run - Transitional climate (1851-1900)
    # =========================================================================
    print("[3/7] Running transclim simulation...")
    s3 = time.perf_counter()

    pan_amazon.run_region_map(fn.transclim_run)

    e3 = time.perf_counter()
    print(f"      ✓ Transclim completed in {format_time(e3 - s3)}\n")

    # =========================================================================
    # PHASE 4: Save State Checkpoint
    # =========================================================================
    # State file enables restarting simulations from this point (end of 1900) - Starts in 01.01.1901
    state_file = Path(f"./{region_name}_after_spinup_state_file.psz")
    print(f"[4/7] Saving post-spinup state → {state_file.name}")
    s4 = time.perf_counter()

    pan_amazon.save_state(state_file)

    e4 = time.perf_counter()
    print(f"      ✓ State saved in {format_time(e4 - s4)}\n")

    elapsed = time.time() - time_start
    print(f"      ⏱ Elapsed time: {format_time(elapsed)}\n")

    # =========================================================================
    # PHASE 5: Prepare for Transient Run
    # =========================================================================
    # Create a fresh copy of the model state before switching to obsclim data.
    # This preserves the spinup state for potential alternative scenario runs.
    print("[5/7] Preparing transient run...")
    print("      Setting new state...")
    s5 = time.perf_counter()

    pan_amazon.set_new_state()

    e5 = time.perf_counter()
    print(f"      ✓ New state set in {format_time(e5 - s5)}")

    # Switch input source to observational climate data
    print("      Updating input to obsclim files...")
    s2 = time.perf_counter()

    pan_amazon.update_input(obsclim_files)

    e2 = time.perf_counter()
    print(f"      ✓ Input updated in {format_time(e2 - s2)}\n")

    # =========================================================================
    # PHASE 6: Transient Run - Historical climate (1901-2024)
    # =========================================================================
    # Run in 30-year segments to manage memory and enable progress tracking
    # Until now we did not generated any output files. The state files generated
    # during spinup only stores the model state for restarts.
    # All outputs in the spinup phase are discarded.
    print("[6/7] Running transient simulation (1901-2024)...")
    s_trans = time.perf_counter()
    run_breaks = fn.create_run_breaks(1901, 2024, 30)

    for i, period in enumerate(run_breaks, 1):
        print(f"      Period {i}/{len(run_breaks)}: {period[0]} → {period[1]}", end="")
        sp = time.perf_counter()

        # In fn.transient_run_brk the ouptut is serialized to "spin" files named spinXXXX.pkz
        # Each file contains the outputs for that period.
        # THis means that for downstream processing, the period in each file
        # will depend on the run breaks defined here.
        # Have a look at dataframes.output_manager.pan_amazon_output
        # to see how to process these files.
        pan_amazon.run_region_starmap(fn.transient_run_brk, period)

        ep = time.perf_counter()
        print(f" ({format_time(ep - sp)})")

    e_trans = time.perf_counter()
    print(f"      ✓ Transient run completed in {format_time(e_trans - s_trans)}\n")

    # =========================================================================
    # PHASE 7: Finalize and Export Results
    # =========================================================================
    # Clean model state to prepare for output export.
    # Note: This cleaned state cannot be used for restarts.
    print("[7/7] Finalizing simulation...")
    print("      Cleaning model state...")
    s6 = time.perf_counter()
    pan_amazon.clean_model_state_fast()
    e6 = time.perf_counter()
    print(f"      ✓ State cleaned in {format_time(e6 - s6)}")

    print(f"      Saving final results → {region_name}_result.psz")
    s7 = time.perf_counter()
    pan_amazon.save_state(Path(f"./{region_name}_result.psz"))
    e7 = time.perf_counter()
    print(f"      ✓ Results saved in {format_time(e7 - s7)}\n")

    # =========================================================================
    # SIMULATION SUMMARY
    # =========================================================================
    total_time = time.time() - time_start
    print("=" * 70)
    print("  SIMULATION COMPLETE")
    print("=" * 70)
    print(f"  Total execution time: {format_time(total_time)}")
    print("=" * 70 + "\n")

    # -------------------------------------------------------------------------
    # OUTPUT GENERATION
    # -------------------------------------------------------------------------
    # Import here to avoid multiprocessing pickle issues
    print("Generating output files...")
    from dataframes import output_manager
    output_manager.pan_amazon_output(filename_infix=region_name)
    print("✓ Output files generated.\n")

    # Archive the PLS table used in this simulation for reproducibility
    from shutil import copy2

    output_folder = pan_amazon.config.output.output_dir
    pls_filename = f"{PLS_TABLE_PATH.stem}_{region_name}{PLS_TABLE_PATH.suffix}"
    copy2(PLS_TABLE_PATH, output_folder / pls_filename)
    print(f"✓ PLS table copied to {output_folder / pls_filename}")
