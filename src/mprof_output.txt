
Progress: |------------------------------| 0.00% CompleteFilename: C:\Users\darel\OneDrive\Desktop\CAETE\src\caete.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
  1013    189.1 MiB    189.1 MiB           1       @profile
  1014                                             # @timer
  1015                                             def run_gridcell(self,
  1016                                                           start_date: str,
  1017                                                           end_date: str,
  1018                                                           spinup: int = 0,
  1019                                                           fixed_co2_atm_conc: Optional[str] | Optional[int] | Optional[float] = None,
  1020                                                           save: bool = True,
  1021                                                           nutri_cycle: bool = True,
  1022                                                           afex: bool = False,
  1023                                                           reset_community: bool = False,
  1024                                                           kill_and_reset: bool = False,
  1025                                                           env_filter: bool = False,
  1026                                                           process_limitation: bool = False,
  1027                                                           verbose: bool = False):
  1028                                                 """
  1029                                                 Run the model for a grid cell.
  1030                                         
  1031                                                 CAETÊ-DVM execution in the start_date - end_date period, can be used for spinup or transient runs.
  1032                                         
  1033                                                 Args:
  1034                                                     start_date (str): Start date for model execution in "yyyymmdd" format.
  1035                                                     end_date (str): End date for model execution in "yyyymmdd" format.
  1036                                                     spinup (int, optional): Number of repetitions in spinup. Set to 0 for a transient run between start_date and end_date. Default is 0.
  1037                                                     fixed_co2_atm_conc (Optional[Union[str, int, float]]): Fixed atmospheric CO2 concentration. If None, use dynamic CO2 levels from a predefined file. If a string with a year (e.g., "1987") That year's value in the provided file will be used. Use a float to set a fixed level in ppm. Default is None.
  1038                                                     save (bool, optional): Whether to save the results. Default is True.
  1039                                                     nutri_cycle (bool, optional): Whether to include nutrient cycling in the model. Default is True.
  1040                                                     afex (bool, optional): Whether to apply nutrient addition to soil in the model. Default is False.
  1041                                                     reset_community (bool, optional): Whether to restart a new community if there are not viable PLS. Default is False.
  1042                                                     kill_and_reset (bool, optional): Whether to kill and reset the community structure at the end of execution (only CVEG pools and PLS IDs). Default is False.
  1043                                                     env_filter (bool, optional): Whether to apply environmental filtering (Include new PLS periodically) []. Default is False.
  1044                                                     verbose (bool, optional): Whether to print detailed logs during execution. Default is False.
  1045                                         
  1046                                                 Returns:
  1047                                                     None
  1048                                         
  1049                                                 Notes:
  1050                                                     - If reset_community is true a new community will be set (reset) when there is no PLSs remaining.
  1051                                                     - If the kill_and_reset is true, after n spins (integer given by spinup parameter - i.e. in the end
  1052                                                       of function execution) all the communities in a gridcell are reset. The reset_community and
  1053                                                       kill_and_reset  arguments are not mutually exclusive. You can use both as true at the same time.
  1054                                                     - The env_filter argument is used to define if new unique PLSs from the main table will be
  1055                                                       seed in the communities that have free slots (PLSs that are not producing). At the moment, the
  1056                                                       interval for the env_filter to add a new PLS to the community is set to  ~15 days.
  1057                                                       If env filter argument is true, then the reset_community argument will have a very low
  1058                                                       probability to trigger a reset because the communities will be constantly filled with new PLS.
  1059                                                       Nonetheless, the reset_community argument will still be able to trigger a reset if the community loses all PLSs.
  1060                                                       With the probability of a reset_community increasing as the interval between new seeds increases. The parameter doy_months
  1061                                                       in the config file (caete.toml) is used to define the interval for the env_filter to add a new PLS to the community.
  1062                                         
  1063                                                       TODO: Implement a more flexible way to define the interval for
  1064                                                             the env_filter to add a new PLS to the community.
  1065                                                 """
  1066                                         
  1067    189.1 MiB      0.0 MiB           2           assert not fixed_co2_atm_conc or\
  1068    189.1 MiB      0.0 MiB           1               isinstance(fixed_co2_atm_conc, str) or\
  1069                                                     fixed_co2_atm_conc > 0,\
  1070                                                         "A fixed value for ATM[CO2] must be a positive number greater than zero or a proper string with the year - e.g., 'yyyy'"
  1071                                         
  1072                                         
  1073                                                 # Define start and end dates (read parameters)
  1074    189.2 MiB      0.0 MiB           1           start = parse_date(start_date)
  1075    189.2 MiB      0.0 MiB           1           end = parse_date(end_date)
  1076                                         
  1077                                                 # Check dates
  1078    189.2 MiB      0.0 MiB           1           assert start < end, "Start date must be before end date"
  1079    189.2 MiB      0.0 MiB           1           assert start >= self.start_date, "initial date out of bounds for the time array"
  1080    189.2 MiB      0.0 MiB           1           assert end <= self.end_date, f"Final date out of bounds for the time array"
  1081                                         
  1082                                         
  1083                                                 # Define time index bounds for this run
  1084                                                 # During a run we are in general using a slice ov the available time span
  1085                                                 # to run the model. For example, we can run the model for a year or a decade
  1086                                                 # at the begining of the input data time series to spin up. This slice is defined
  1087                                                 # by the start and end dates provided in the arguments. Here we get the indices.
  1088    189.2 MiB      0.1 MiB           1           self.start_index = int(cftime.date2num(start, self.time_unit, self.calendar))
  1089    189.2 MiB      0.0 MiB           1           self.end_index =   int(cftime.date2num(end, self.time_unit, self.calendar))
  1090                                         
  1091                                                 # Find the indices in the time array [used to slice the timeseries with driver data  - tas, pr, etc.]
  1092    189.8 MiB      0.6 MiB           1           lower_bound, upper_bound = self.find_index(self.start_index, self.end_index)
  1093                                         
  1094                                                 # Define the time steps range (days)
  1095    189.8 MiB      0.0 MiB           1           steps = np.arange(lower_bound, upper_bound + 1, dtype=np.int64)
  1096                                         
  1097                                                 # Define the number of repetitions for the spinup
  1098    189.8 MiB      0.0 MiB           1           spin = 1 if spinup == 0 else spinup
  1099                                         
  1100                                                 # Define the AFEX mode
  1101    189.8 MiB      0.0 MiB           1           afex_mode = self.afex_config.afex_mode # type: ignore
  1102                                         
  1103                                                 # Slice&Catch climatic input and make conversions
  1104    189.8 MiB      0.0 MiB           1           cv = self.config.conversion_factors_isimip # type: ignore
  1105                                         
  1106                                         
  1107    189.8 MiB      0.0 MiB           1           if self.config.input_handler.input_method == "ih" and self.config.input_handler.input_type == "netcdf":
  1108                                                     # Variables in Netcdf files are already in proprer units
  1109    189.8 MiB      0.0 MiB           1               temp: NDArray[np.float32] = self.tas[lower_bound: upper_bound + 1]   # Air temp: model uses °C
  1110    189.8 MiB      0.0 MiB           1               prec: NDArray[np.float32] = self.pr[lower_bound: upper_bound + 1]    # Precipitation: model uses  mm/day
  1111    189.8 MiB      0.0 MiB           1               p_atm: NDArray[np.float32] = self.ps[lower_bound: upper_bound + 1]   # Atmospheric pressure: model uses hPa
  1112    189.8 MiB      0.0 MiB           1               ipar: NDArray[np.float32] = self.rsds[lower_bound: upper_bound + 1]  # PAR: model uses  mol(photons) m-2 s-1
  1113    189.8 MiB      0.0 MiB           1               ru: NDArray[np.float32] = self.rhs[lower_bound: upper_bound + 1]     # Relative humidity: model uses 0-1
  1114                                                 else:
  1115                                                     temp: NDArray[np.float32] = self.tas[lower_bound: upper_bound + 1] - cv.tas    # Air temp: model uses °C
  1116                                                     prec: NDArray[np.float32] = self.pr[lower_bound: upper_bound + 1] * cv.pr      # Precipitation: model uses  mm/day
  1117                                                     p_atm: NDArray[np.float32] = self.ps[lower_bound: upper_bound + 1] * cv.ps     # Atmospheric pressure: model uses hPa
  1118                                                     ipar: NDArray[np.float32] = self.rsds[lower_bound: upper_bound + 1] * cv.rsds  # PAR: model uses  mol(photons) m-2 s-1
  1119                                                     ru: NDArray[np.float32] = self.rhs[lower_bound: upper_bound + 1] * cv.rhs      # Relative humidity: model uses 0-1
  1120                                         
  1121                                                 # Define the daily values for co2 concentrations
  1122    189.8 MiB      0.0 MiB           1           co2_daily_values = np.zeros(steps.size, dtype=np.float32)
  1123                                         
  1124    189.8 MiB      0.0 MiB           1           if fixed_co2_atm_conc is None:
  1125                                                     # In this case, the co2 concentration will be updated daily.
  1126                                                     # We interpolate linearly between the yearly values of the atm co2 data
  1127                                                     co2 = self.find_co2(start.year)
  1128                                                     today = datetime(start.year, start.month, start.day, start.hour, start.minute, start.second)
  1129                                                     time_step = timedelta(days=1) # Define the time step
  1130                                                     today -= time_step # The first thing we do next is to add a day to the date. So we go back one day
  1131                                                     # Loop over the days and calculate the co2 concentration for each day
  1132                                                     for step in range(steps.size):
  1133                                                         today += time_step
  1134                                                         remaining = (datetime(today.year, 12, 31) - today).days + 1
  1135                                                         daily_fraction = (self.find_co2(today.year + 1) - co2) / (remaining + 1)
  1136                                                         co2 += daily_fraction
  1137                                                         co2_daily_values[step] = co2
  1138    189.8 MiB      0.0 MiB           1           elif isinstance(fixed_co2_atm_conc, int) or isinstance(fixed_co2_atm_conc, float):
  1139                                                     # In this case, the co2 concentration will be fixed according to the numeric value provided in the argument
  1140                                                     co2 = fixed_co2_atm_conc
  1141                                                     co2_daily_values += co2
  1142    189.8 MiB      0.0 MiB           1           elif isinstance(fixed_co2_atm_conc, str):
  1143                                                     # In this case, the co2 concentration will be fixed
  1144                                                     # According to the year provided in the argument
  1145                                                     # as a string. Format "yyyy".
  1146    189.8 MiB      0.0 MiB           1               try:
  1147    189.8 MiB      0.0 MiB           1                   co2_year = int(fixed_co2_atm_conc)
  1148                                                     except ValueError:
  1149                                                         raise ValueError(
  1150                                                             "The string(\"yyyy\") must be a number in the {self.start_date.year} - {self.end_date.year} interval")
  1151    189.8 MiB      0.0 MiB           1               co2 = self.find_co2(co2_year)
  1152    189.8 MiB      0.0 MiB           1               co2_daily_values += co2
  1153                                                 else:
  1154                                                     raise ValueError("Invalid value for fixed_co2_atm_conc")
  1155                                         
  1156                                                 # Define variables to track dates
  1157    189.8 MiB      0.0 MiB           1           first_day_of_simulation = datetime(start.year, start.month, start.day, start.hour, start.minute, start.second)
  1158                                                 # Define the time step
  1159    189.8 MiB      0.0 MiB           1           time_step = timedelta(days=1)
  1160                                         
  1161                                                 # Define the object to store the outputs from daily_budget
  1162    189.8 MiB      0.0 MiB           1           daily_output = DailyBudget()
  1163                                         
  1164                                                 # Start loops
  1165                                                 # This outer loop is used to run the model for a number
  1166                                                 # of times defined by the spinup argument. The model is
  1167                                                 # executed repeatedly between the start and end dates
  1168                                                 # provided in the arguments
  1169                                         
  1170    196.7 MiB      0.0 MiB           3           for s in range(spin):
  1171                                         
  1172    196.8 MiB      4.2 MiB           2               self._allocate_output(steps.size, self.metacomm.comm_npls, len(self.metacomm), save)
  1173                                         
  1174                                                     # Loop over the days
  1175    196.8 MiB      0.0 MiB           2               today = first_day_of_simulation
  1176                                         
  1177                                                     # Go back one day
  1178    196.8 MiB      0.0 MiB           2               today -= time_step
  1179                                         
  1180                                                     # Arrays to store & pass values for each community in a simulated day
  1181    196.8 MiB      0.0 MiB           2               sto =        np.zeros(shape=(3, self.metacomm.comm_npls), order='F')
  1182    196.8 MiB      0.0 MiB           2               cleaf_in =   np.zeros(self.metacomm.comm_npls, order='F')
  1183    196.8 MiB      0.0 MiB           2               cwood_in =   np.zeros(self.metacomm.comm_npls, order='F')
  1184    196.8 MiB      0.0 MiB           2               croot_in =   np.zeros(self.metacomm.comm_npls, order='F')
  1185    196.8 MiB      0.0 MiB           2               uptk_costs = np.zeros(self.metacomm.comm_npls, order='F')
  1186    196.8 MiB      0.0 MiB           2               rnpp_in =    np.zeros(self.metacomm.comm_npls, order='F')
  1187                                         
  1188                                                     # There are two modes of operation: save and not save.
  1189                                                     # In the save == False mode, the arrays are used to store the values that are
  1190                                                     # needed for model iteration, i.e., the values that are used in the next
  1191                                                     # time step. In the save mode, an extra number arrays is created to be used
  1192                                                     # to store the outputs.
  1193    196.8 MiB      0.0 MiB           2               xsize: int = len(self.metacomm) # Number of communities
  1194    196.8 MiB      0.0 MiB           2               evavg: NDArray[np.float32] = np.zeros(xsize, dtype=np.float32)
  1195    196.8 MiB      0.0 MiB           2               epavg: NDArray[np.float32] = np.zeros(xsize, dtype=np.float32)
  1196    196.8 MiB      0.0 MiB           2               rnpp_mt: NDArray[np.float32] = np.zeros(xsize, dtype=np.float32)
  1197                                         
  1198                                                     # We keep track of these to input in SOM dynamics later. They are used for output also
  1199    196.8 MiB      0.0 MiB           2               leaf_litter: NDArray[np.float32] = np.zeros(xsize, dtype=np.float32)
  1200    196.8 MiB      0.0 MiB           2               cwd: NDArray[np.float32] = np.zeros(xsize, dtype=np.float32)
  1201    196.8 MiB      0.0 MiB           2               root_litter: NDArray[np.float32] = np.zeros(xsize, dtype=np.float32)
  1202    196.8 MiB      0.0 MiB           2               lnc: NDArray[np.float32] = np.zeros(shape=(6, xsize), dtype=np.float32)
  1203                                                     # This is added to leaf litter pool (that is basicaly a fast SOM pool)
  1204    196.8 MiB      0.0 MiB           2               c_to_nfixers: NDArray[np.float32]= np.zeros(xsize, dtype=np.float32)
  1205    196.8 MiB      0.0 MiB           2               nupt = np.zeros(shape=(2, xsize), dtype=np.float32)
  1206    196.8 MiB      0.0 MiB           2               pupt = np.zeros(shape=(3, xsize), dtype=np.float32)
  1207                                         
  1208    196.8 MiB      0.0 MiB           2               if save:
  1209                                                         cc = np.zeros(xsize, dtype=np.float32)
  1210                                                         photo = np.zeros(xsize, dtype=np.float32)
  1211                                                         aresp = np.zeros(xsize, dtype=np.float32)
  1212                                                         npp = np.zeros(xsize, dtype=np.float32)
  1213                                                         lai = np.zeros(xsize, dtype=np.float32)
  1214                                                         rcm = np.zeros(xsize, dtype=np.float32)
  1215                                                         f5 = np.zeros(xsize, dtype=np.float32)
  1216                                                         rm = np.zeros(xsize, dtype=np.float32)
  1217                                                         rg = np.zeros(xsize, dtype=np.float32)
  1218                                                         wue = np.zeros(xsize, dtype=np.float32)
  1219                                                         cue = np.zeros(xsize, dtype=np.float32)
  1220                                                         carbon_deficit = np.zeros(xsize, dtype=np.float32)
  1221                                                         vcmax = np.zeros(xsize, dtype=np.float32)
  1222                                                         specific_la = np.zeros(xsize, dtype=np.float32)
  1223                                                         storage_pool = np.zeros(shape=(3, xsize))
  1224                                         
  1225                                                         if process_limitation:
  1226                                                             lim_status_y_leaf = np.ma.masked_all((xsize, self.metacomm.comm_npls, 366), dtype=np.int8)
  1227                                                             lim_status_y_stem = np.ma.masked_all((xsize, self.metacomm.comm_npls, 366), dtype=np.int8)
  1228                                                             lim_status_y_root = np.ma.masked_all((xsize, self.metacomm.comm_npls, 366), dtype=np.int8)
  1229                                                             uptake_strategy_n = np.ma.masked_all((xsize, self.metacomm.comm_npls, 366), dtype=np.int8)
  1230                                                             uptake_strategy_p = np.ma.masked_all((xsize, self.metacomm.comm_npls, 366), dtype=np.int8)
  1231                                         
  1232                                                     # <- Daily loop
  1233    196.8 MiB   -596.2 MiB       36526               for step in range(steps.size):
  1234    196.8 MiB   -596.1 MiB       36524                   today += time_step
  1235    196.8 MiB   -596.1 MiB       36524                   julian_day = today.timetuple().tm_yday
  1236                                         
  1237                                                         # Get the co2 concentration for the day
  1238    196.8 MiB   -596.1 MiB       36524                   co2 = co2_daily_values[step]
  1239                                                         # Update soil temperature
  1240    196.8 MiB   -596.0 MiB       36524                   self.soil_temp = st.soil_temp(self.soil_temp, temp[step])
  1241                                         
  1242                                                         # AFEX
  1243    196.8 MiB   -596.1 MiB       36524                   if afex and julian_day == 365:
  1244                                                             self.add_soil_nutrients(afex_mode)
  1245                                         
  1246                                                         # Loop over communities
  1247    196.8 MiB   -596.1 MiB       36524                   living_pls = 0 # Sum of living PLS in the communities
  1248    196.8 MiB  -1192.3 MiB       73048                   for i, community in enumerate(self.metacomm):
  1249                                                             # if i >= len(self.metacomm):
  1250                                                             #     break
  1251                                                             # if community.masked:
  1252                                                             #     # skip this one
  1253                                                             #     continue
  1254    196.8 MiB   -595.8 MiB       36524                       sto[0, :] = inflate_array(community.npls, community.vp_sto[0, :], community.vp_lsid)
  1255    196.8 MiB   -596.1 MiB       36524                       sto[1, :] = inflate_array(community.npls, community.vp_sto[1, :], community.vp_lsid)
  1256    196.8 MiB   -596.1 MiB       36524                       sto[2, :] = inflate_array(community.npls, community.vp_sto[2, :], community.vp_lsid)
  1257                                         
  1258    196.8 MiB   -595.9 MiB       36524                       cleaf_in[:] = inflate_array(community.npls, community.vp_cleaf, community.vp_lsid)
  1259    196.8 MiB   -596.1 MiB       36524                       cwood_in[:] = inflate_array(community.npls, community.vp_cwood, community.vp_lsid)
  1260    196.8 MiB   -596.1 MiB       36524                       croot_in[:] = inflate_array(community.npls, community.vp_croot, community.vp_lsid)
  1261    196.8 MiB   -595.8 MiB       36524                       uptk_costs[:] = inflate_array(community.npls, community.sp_uptk_costs, community.vp_lsid)
  1262    196.8 MiB   -596.1 MiB       36524                       rnpp_in[:] = inflate_array(community.npls, community.construction_npp, community.vp_lsid)
  1263                                         
  1264    196.8 MiB   -596.1 MiB       36524                       ton = self.sp_organic_n #+ self.sp_sorganic_n
  1265    196.8 MiB   -596.1 MiB       36524                       top = self.sp_organic_p #+ self.sp_sorganic_p
  1266                                         
  1267                                                             # Community daily budget calculation
  1268    196.8 MiB  -1191.2 MiB       73048                       out = model.daily_budget(community.pls_array, self.wp_water_upper_mm,
  1269    196.8 MiB   -596.1 MiB       36524                                               self.wp_water_lower_mm, self.soil_temp, temp[step],
  1270    196.8 MiB   -596.1 MiB       36524                                               p_atm[step], ipar[step], ru[step], self.sp_available_n,
  1271    196.8 MiB   -596.1 MiB       36524                                               self.sp_available_p, ton, top, self.sp_organic_p,
  1272    196.8 MiB   -596.1 MiB       36524                                               co2, sto, cleaf_in, cwood_in, croot_in, uptk_costs,self.wmax_mm,
  1273    196.8 MiB   -596.1 MiB       36524                                               rnpp_in)
  1274                                         
  1275                                                             # get daily budget results
  1276    196.8 MiB   -596.1 MiB       36524                       daily_output.update(out)
  1277                                         
  1278                                                             # Update the community status
  1279    196.8 MiB   -596.0 MiB       36524                       community.update_lsid(daily_output.ocpavg)
  1280                                         
  1281                                                             # Abort community if no PLSs are left while saving the spin
  1282    196.8 MiB   -596.1 MiB       36524                       if community.masked and save:
  1283                                                                 continue
  1284                                         
  1285    196.8 MiB   -596.1 MiB       36524                       community.ls = community.vp_lsid.size
  1286                                                             # # Restore or seed PLS
  1287    196.8 MiB   -596.1 MiB       36524                       if env_filter and (community.ls < self.metacomm.comm_npls) and not save:
  1288    196.8 MiB    -86.3 MiB        5537                           if julian_day in self.doy_months:
  1289    196.8 MiB     -4.3 MiB         294                               new_id, new_PLS = community.get_unique_pls(self.get_from_main_array)
  1290    196.8 MiB     -8.9 MiB         588                               community.seed_pls(new_id, new_PLS, daily_output.cleafavg_pft,
  1291    196.8 MiB     -4.5 MiB         294                                                  daily_output.cfrootavg_pft, daily_output.cawoodavg_pft)
  1292    196.8 MiB     -4.5 MiB         294                               if verbose: print(f"PLS seed in Community {i}: Gridcell: {self.lat} °N, {self.lon} °E: In spin:{s}, step:{step}")
  1293                                         
  1294    196.8 MiB     -9.0 MiB         588                               daily_output.ocpavg = pft_area_frac64(daily_output.cleafavg_pft,
  1295    196.8 MiB     -4.5 MiB         294                                                               daily_output.cfrootavg_pft,
  1296    196.8 MiB     -4.5 MiB         294                                                               daily_output.cawoodavg_pft)
  1297    196.8 MiB     -4.5 MiB         294                               community.update_lsid(daily_output.ocpavg)
  1298    196.8 MiB     -4.5 MiB         294                               community.ls = community.vp_lsid.size
  1299                                                                 # endif
  1300                                         
  1301                                         
  1302    196.8 MiB   -596.1 MiB       36524                       community.vp_ocp = daily_output.ocpavg[community.vp_lsid]
  1303    196.8 MiB   -596.1 MiB       36524                       community.vp_cleaf = daily_output.cleafavg_pft[community.vp_lsid]
  1304    196.8 MiB   -596.1 MiB       36524                       community.vp_cwood = daily_output.cawoodavg_pft[community.vp_lsid]
  1305    196.8 MiB   -596.1 MiB       36524                       community.vp_croot = daily_output.cfrootavg_pft[community.vp_lsid]
  1306    196.8 MiB   -596.2 MiB       36524                       community.vp_sto = daily_output.stodbg[:, community.vp_lsid].astype('float32')
  1307    196.8 MiB   -596.2 MiB       36524                       community.sp_uptk_costs = daily_output.npp2pay[community.vp_lsid]
  1308    196.8 MiB   -596.2 MiB       36524                       community.construction_npp = daily_output.rnpp_out[community.vp_lsid]
  1309    196.8 MiB   -596.2 MiB       36524                       living_pls += community.ls
  1310                                                             # print(f"Community storage: {community.vp_sto[0, :]}")
  1311                                                             # print(f"Sto_budget_out {daily_output.stodbg[0, :]}")
  1312                                         
  1313                                                             # Limiting nutrient organization:
  1314                                                             # dim1 = leaf wood root, code: 1=N 2=P 4=N,COLIM 5=P,COLIM 6=COLIM 0=NOLIM
  1315    196.8 MiB   -596.2 MiB       36524                       if save:
  1316                                                                 if process_limitation:
  1317                                                                     lim_status_y_leaf[i, :, julian_day - 1] = daily_output.limitation_status[0,:]# type: ignore
  1318                                                                     lim_status_y_stem[i, :, julian_day - 1] = daily_output.limitation_status[1,:]# type: ignore
  1319                                                                     lim_status_y_root[i, :, julian_day - 1] = daily_output.limitation_status[2,:]# type: ignore
  1320                                                                     uptake_strategy_n[i, :, julian_day - 1] = daily_output.uptk_strat[0,:]# type: ignore
  1321                                                                     uptake_strategy_p[i, :, julian_day - 1] = daily_output.uptk_strat[1,:]# type: ignore
  1322                                         
  1323                                                                 community.anpp += cw_mean(community.vp_ocp, community.construction_npp.astype(np.float32))
  1324                                                                 community.uptake_costs += cw_mean(community.vp_ocp, community.sp_uptk_costs.astype(np.float32))
  1325                                         
  1326    196.8 MiB   -596.2 MiB       36524                       if save and julian_day == 365:
  1327                                                                 community.cleaf = cw_mean(community.vp_ocp, community.vp_cleaf.astype(np.float32))
  1328                                                                 community.cwood = cw_mean(community.vp_ocp, community.vp_cwood.astype(np.float32))
  1329                                                                 community.croot = cw_mean(community.vp_ocp, community.vp_croot.astype(np.float32))
  1330                                                                 community.csto = cw_mean(community.vp_ocp, community.vp_sto[0, :])
  1331                                                                 community.shannon_diversity = shannon_diversity(community.vp_ocp)
  1332                                                                 community.shannon_entropy = shannon_entropy(community.vp_ocp)
  1333                                                                 community.shannon_evenness = shannon_evenness(community.vp_ocp)
  1334                                         
  1335                                                                 # process limitation data
  1336                                                                 # Filter non living PLS from the limitation status
  1337                                                                 if process_limitation:
  1338                                                                     _data_leaf = lim_status_y_leaf[i, [community.vp_lsid], :] # type: ignore
  1339                                                                     _data_stem = lim_status_y_stem[i, [community.vp_lsid], :] # type: ignore
  1340                                                                     _data_root = lim_status_y_root[i, [community.vp_lsid], :] # type: ignore
  1341                                         
  1342                                                                     _data_uptake_n = uptake_strategy_n[i, [community.vp_lsid], :]# type: ignore
  1343                                                                     _data_uptake_p = uptake_strategy_p[i, [community.vp_lsid], :]# type: ignore
  1344                                         
  1345                                                                     # Loop over the living PLS to get the unique values and counts
  1346                                                                     pls_lim_leaf = []
  1347                                                                     pls_lim_stem = []
  1348                                                                     pls_lim_root = []
  1349                                                                     pls_uptake_n = []
  1350                                                                     pls_uptake_p = []
  1351                                         
  1352                                                                     for k in range(community.vp_lsid.size):
  1353                                                                         # Get the unique values and counts for leaf limitation
  1354                                                                         unique, counts = np.unique(_data_leaf[0, k, :], return_counts=True)
  1355                                                                         unique = unique.data[unique.mask == False] # type: ignore
  1356                                                                         pls_lim_leaf.append((unique, counts[:unique.size])) # type: ignore
  1357                                         
  1358                                                                         # Stem limitation
  1359                                                                         unique, counts = np.unique(_data_stem[0, k, :], return_counts=True)
  1360                                                                         unique = unique.data[unique.mask == False] # type: ignore
  1361                                                                         pls_lim_stem.append((unique, counts[:unique.size])) # type: ignore
  1362                                         
  1363                                                                         # Root limitation
  1364                                                                         unique, counts = np.unique(_data_root[0, k, :], return_counts=True)
  1365                                                                         unique = unique.data[unique.mask == False]
  1366                                                                         pls_lim_root.append((unique, counts[:unique.size])) # type: ignore
  1367                                         
  1368                                                                         # Uptake strategy N
  1369                                                                         unique, counts = np.unique(_data_uptake_n[0, k, :], return_counts=True)
  1370                                                                         unique = unique.data[unique.mask == False] # type: ignore
  1371                                                                         pls_uptake_n.append((unique, counts[:unique.size])) # type: ignore
  1372                                         
  1373                                                                         # Uptake strategy P
  1374                                                                         unique, counts = np.unique(_data_uptake_p[0, k, :], return_counts=True)
  1375                                                                         unique = unique.data[unique.mask == False]  # type: ignore
  1376                                                                         pls_uptake_p.append((unique, counts[:unique.size])) # type: ignore
  1377                                         
  1378                                                                     community.limitation_status_leaf = pls_lim_leaf
  1379                                                                     community.limitation_status_wood = pls_lim_stem
  1380                                                                     community.limitation_status_root = pls_lim_root
  1381                                                                     community.uptake_strategy_n = pls_uptake_n
  1382                                                                     community.uptake_strategy_p = pls_uptake_p
  1383                                         
  1384                                                                     # Reset the limitation masked arrays
  1385                                                                     lim_status_y_leaf.mask[i, :, :] = np.ones((self.metacomm.comm_npls, 366), dtype=bool) # type: ignore
  1386                                                                     lim_status_y_stem.mask[i, :, :] = np.ones((self.metacomm.comm_npls, 366), dtype=bool) # type: ignore
  1387                                                                     lim_status_y_root.mask[i, :, :] = np.ones((self.metacomm.comm_npls, 366), dtype=bool) # type: ignore
  1388                                                                     uptake_strategy_n.mask[i, :, :] = np.ones((self.metacomm.comm_npls, 366), dtype=bool) # type: ignore
  1389                                                                     uptake_strategy_p.mask[i, :, :] = np.ones((self.metacomm.comm_npls, 366), dtype=bool) # type: ignore
  1390                                                                 else:
  1391                                                                     pass
  1392                                         
  1393    196.8 MiB   -596.2 MiB       36524                       if community.vp_lsid.size < 1:
  1394                                                                 if verbose: print(f"Empty community {i}: Gridcell: {self.lat} °N, {self.lon} °E: In spin:{s}, step:{step}")
  1395                                                                 if reset_community:
  1396                                                                     assert not save, "Cannot save data when resetting communities"
  1397                                                                     if verbose: print(f"Reseting community {i}: Gridcell: {self.lat} °N, {self.lon} °E: In spin:{s}, step:{step}")
  1398                                         
  1399                                                                     new_life_strategies = self.get_from_main_array(community.npls)
  1400                                                                     community.restore_from_main_table(new_life_strategies)
  1401                                                                     # continue
  1402                                         
  1403                                                                 else:
  1404                                                                     # In the transiant run - i.e., when reset_community is false and
  1405                                                                     # kill_and_reset is false; we mask the community if there is no PLS
  1406                                                                     self.metacomm.mask[i] = np.int8(1)
  1407                                                                     # Set mask to true for this community, will not run in the next steps
  1408                                                                     # Set annual values to zero
  1409                                                                     community.masked = np.int8(1)
  1410                                                                     community.cleaf = np.float32(0.0)
  1411                                                                     community.cwood = np.float32(0.0)
  1412                                                                     community.croot = np.float32(0.0)
  1413                                                                     community.csto  = np.float32(0.0)
  1414                                                                     community.shannon_diversity = -9999.0
  1415                                                                     community.shannon_entropy = -9999.0
  1416                                                                     community.shannon_evenness = -9999.0
  1417                                                                     # if the reset_community is true
  1418                                                                     # continue # cycle
  1419                                         
  1420                                                             # Store values for each community
  1421    196.8 MiB   -596.2 MiB       36524                       rnpp_mt[i] = cw_mean(community.vp_ocp, community.construction_npp.astype(np.float32)) # Community Weighted rNPP
  1422    196.8 MiB   -596.2 MiB       36524                       leaf_litter[i] = daily_output.litter_l
  1423    196.8 MiB   -596.2 MiB       36524                       root_litter[i] = daily_output.litter_fr
  1424    196.8 MiB   -596.2 MiB       36524                       cwd[i] = daily_output.cwd
  1425    196.8 MiB   -596.2 MiB       36524                       lnc[:, i] = daily_output.lnc.astype(np.float32)
  1426    196.8 MiB   -596.2 MiB       36524                       c_to_nfixers[i] = daily_output.cp[3]
  1427    196.8 MiB   -596.2 MiB       36524                       evavg[i] = daily_output.evavg
  1428    196.8 MiB   -596.2 MiB       36524                       epavg[i] = daily_output.epavg
  1429    196.8 MiB   -596.2 MiB       36524                       nupt[:, i] = daily_output.nupt #type: ignore
  1430    196.8 MiB   -596.2 MiB       36524                       pupt[:, i] = daily_output.pupt #type: ignore
  1431                                         
  1432    196.8 MiB   -596.2 MiB       36524                       if save:
  1433                                                                 cc[i] = daily_output.c_cost_cwm #type: ignore
  1434                                                                 npp[i] = daily_output.nppavg #type: ignore
  1435                                                                 photo[i] = daily_output.phavg #type: ignore
  1436                                                                 aresp[i] = daily_output.aravg #type: ignore
  1437                                                                 lai[i] = daily_output.laiavg #type: ignore
  1438                                                                 rcm[i] = daily_output.rcavg #type: ignore
  1439                                                                 f5[i] = daily_output.f5avg #type: ignore
  1440                                                                 rm[i] = daily_output.rmavg #type: ignore
  1441                                                                 rg[i] = daily_output.rgavg #type: ignore
  1442                                                                 wue[i] = daily_output.wueavg #type: ignore
  1443                                                                 cue[i] = daily_output.cueavg #type: ignore
  1444                                                                 carbon_deficit[i] = daily_output.c_defavg #type: ignore
  1445                                                                 vcmax[i] = daily_output.vcmax #type: ignore
  1446                                                                 specific_la[i] = daily_output.specific_la #type: ignore
  1447                                         
  1448                                                                 for j in range(daily_output.stodbg.shape[0]):
  1449                                                                     storage_pool[j, i] = cw_mean(community.vp_ocp, community.vp_sto[j, :]) #type: ignore
  1450                                         
  1451                                                         #<- Out of the community loop
  1452                                                         # Save annual state of the metacommunity
  1453    196.8 MiB   -596.2 MiB       36524                   if save:
  1454                                                             if julian_day == 365:
  1455                                                                 y = today.year
  1456                                                                 # m = today.month
  1457                                                                 # d = today.day
  1458                                                                 filename = self.out_dir/f"metacommunity_{y}.pkz"
  1459                                                                 # filename = self.out_dir/f"metacommunity_{d}{m}{y}.pkz"
  1460                                                                 self.metacomm.save_state(filename, y, process_limitation)
  1461                                                                 self.metacomm_output[y] = filename
  1462                                         
  1463                                                                 for community in self.metacomm:
  1464                                                                     # Set annual accumulators to zero
  1465                                                                     community.anpp = np.float32(0.0)
  1466                                                                     community.uptake_costs = np.float32(0.0)
  1467                                         
  1468                                                         # ------------
  1469                                                         # Evapotranspiration
  1470    196.8 MiB   -596.2 MiB       36524                   et = masked_mean(self.metacomm.mask, evavg) #evavg.mean()
  1471                                                         ## Canopy-atmosphere coupling [EXPERIMENTAL]
  1472                                                         # vpd = m.vapor_p_deficit(temp[step], ru[step])
  1473                                                         # et_pot = masked_mean(self.metacomm.mask, np.array(epavg).astype(np.float32)) #epavg.mean()
  1474                                                         # self.evapm[step] = atm_canopy_coupling(et_pot, et, temp[step], vpd)
  1475    196.8 MiB   -596.2 MiB       36524                   self.evapm[step] = et
  1476                                         
  1477                                                         # Update water pools
  1478                                         
  1479    196.8 MiB   -596.0 MiB       36524                   self.runom[step] = self.swp._update_pool(prec[step], self.evapm[step])
  1480    196.8 MiB   -596.2 MiB       36524                   self.swp.w1 = 0.0 if self.swp.w1 < 0.0 else self.swp.w1
  1481    196.8 MiB   -596.2 MiB       36524                   self.swp.w2 = 0.0 if self.swp.w2 < 0.0 else self.swp.w2
  1482    196.8 MiB   -596.2 MiB       36524                   self.wp_water_upper_mm = self.swp.awc1
  1483    196.8 MiB   -596.2 MiB       36524                   self.wp_water_lower_mm = self.swp.awc2
  1484    196.8 MiB   -596.2 MiB       36524                   wtot = self.swp.w1 + self.swp.w2
  1485                                         
  1486                                                         # Update cflux to the soil for output, mean values over the communities
  1487                                                         # Values are also used to update SOM dynamics
  1488    196.8 MiB  -1192.4 MiB       73048                   self.litter_l[step] = masked_mean(self.metacomm.mask, leaf_litter) +\
  1489    196.8 MiB   -596.2 MiB       36524                                         masked_mean(self.metacomm.mask, c_to_nfixers)
  1490    196.8 MiB   -596.2 MiB       36524                   self.cwd[step] = masked_mean(self.metacomm.mask, cwd)
  1491    196.8 MiB   -596.2 MiB       36524                   self.litter_fr[step] = masked_mean(self.metacomm.mask, root_litter)
  1492    196.8 MiB   -596.2 MiB       36524                   self.lnc[:, step] = masked_mean_2D(self.metacomm.mask, lnc)
  1493                                         
  1494                                                         # Soil C:N:P balance and OM decomposition
  1495    196.8 MiB  -1192.4 MiB       73048                   s_out = soil_dec.carbon3(self.soil_temp, wtot / self.wmax_mm, self.litter_l[step],
  1496    196.8 MiB   -596.2 MiB       36524                                            self.cwd[step], self.litter_fr[step], self.lnc[:, step],
  1497    196.8 MiB   -596.2 MiB       36524                                            self.sp_csoil, self.sp_snc)
  1498    196.8 MiB   -596.2 MiB       36524                   soil_out = catch_out_carbon3(s_out)
  1499                                         
  1500                                                         # Organic C N & P
  1501    196.8 MiB   -596.2 MiB       36524                   self.sp_csoil = soil_out['cs']
  1502    196.8 MiB   -596.2 MiB       36524                   self.sp_snc = np.zeros(shape=8)
  1503    196.8 MiB   -596.2 MiB       36524                   self.sp_snc = soil_out['snc']
  1504    196.8 MiB   -596.2 MiB       36524                   idx = np.where(self.sp_snc < 0.0)[0]
  1505    196.8 MiB   -596.2 MiB       36524                   if len(idx) > 0:
  1506                                                             self.sp_snc[idx] = 0.0
  1507                                         
  1508                                                         # <- Out of the community loop
  1509    196.8 MiB   -596.2 MiB       36524                   self.nupt[:, step] = masked_mean_2D(self.metacomm.mask, nupt)
  1510    196.8 MiB   -596.2 MiB       36524                   self.pupt[:, step] = masked_mean_2D(self.metacomm.mask, pupt)
  1511                                         
  1512                                                         # TODO: Soil nutrient dynamics. Isolate this if branch into a separate method/class/function
  1513                                                         # Critical part of soil nutrient dynamics and availability for plants
  1514                                                         # IF NUTRICYCLE
  1515    196.8 MiB   -596.2 MiB       36524                   if nutri_cycle:
  1516                                                             # UPDATE ORGANIC POOLS
  1517                                                             self.sp_organic_n = self.sp_snc[:2].sum()
  1518                                                             self.sp_sorganic_n = self.sp_snc[2:4].sum()
  1519                                                             self.sp_organic_p = self.sp_snc[4:6].sum()
  1520                                                             self.sp_sorganic_p = self.sp_snc[6:].sum()
  1521                                         
  1522                                                             # Update inorganic pools
  1523                                                             self.sp_available_p += soil_out['pmin']
  1524                                                             self.sp_available_n += soil_out['nmin']
  1525                                                             self.sp_available_p -= self.pupt[0, step]
  1526                                                             self.sp_available_n -= self.nupt[0, step]
  1527                                         
  1528                                                             # NUTRIENT DINAMICS
  1529                                         
  1530                                                             # Inorganic N
  1531                                                             # TODO: NaNs are being sourced upstream , need to track the source and fix it
  1532                                         
  1533                                                             if not np.isfinite(self.sp_in_n):
  1534                                                                 # rwarn(f"Non-finite value detected in sp_in_n pool at step {step}. Resetting to zero.")
  1535                                                                 self.sp_in_n = 0.0
  1536                                                             if not np.isfinite(self.sp_available_n):
  1537                                                                 # rwarn(f"Non-finite value detected in sp_available_n pool at step {step}. Resetting to zero.")
  1538                                                                 self.sp_available_n = 0.0
  1539                                                             if not np.isfinite(self.sp_so_n):
  1540                                                                 # rwarn(f"Non-finite value detected in sp_so_n pool at step {step}. Resetting to zero.")
  1541                                                                 self.sp_so_n = 0.0
  1542                                         
  1543                                                             self.sp_in_n += self.sp_available_n + self.sp_so_n
  1544                                                             self.sp_so_n = soil_dec.sorbed_n_equil(self.sp_in_n)
  1545                                                             self.sp_available_n = soil_dec.solution_n_equil(self.sp_in_n)
  1546                                                             self.sp_in_n -= (self.sp_so_n + self.sp_available_n)
  1547                                         
  1548                                                             # Inorganic P
  1549                                                             if not np.isfinite(self.sp_in_p):
  1550                                                                 # rwarn(f"Non-finite value detected in sp_in_p pool at step {step}. Resetting to zero.")
  1551                                                                 self.sp_in_p = 0.0
  1552                                                             if not np.isfinite(self.sp_available_p):
  1553                                                                 # rwarn(f"Non-finite value detected in sp_available_p pool at step {step}. Resetting to zero.")
  1554                                                                 self.sp_available_p = 0.0
  1555                                                             if not np.isfinite(self.sp_so_p):
  1556                                                                 # rwarn(f"Non-finite value detected in sp_so_p pool at step {step}. Resetting to zero.")
  1557                                                                 self.sp_so_p = 0.0
  1558                                         
  1559                                                             self.sp_in_p += self.sp_available_p + self.sp_so_p
  1560                                                             # sp_so_p is the occluded P in the inorganic pool
  1561                                                             self.sp_so_p = soil_dec.sorbed_p_equil(self.sp_in_p)
  1562                                                             # THe fraction that can be dissolved in soil solution (passive uptake uses transpiration
  1563                                                             # to estimate the amount of P that can be taken up from the soil solution pool)
  1564                                                             self.sp_available_p = soil_dec.solution_p_equil(self.sp_in_p)
  1565                                                             # Inorganic pool that is adsorbed
  1566                                                             self.sp_in_p -= (self.sp_so_p + self.sp_available_p)
  1567                                         
  1568                                                             self.sp_so_p -= self.pupt[1, step]
  1569                                         
  1570                                                             try:
  1571                                                                 t1 = np.all(self.sp_snc > 0.0)
  1572                                                             except:
  1573                                                                 if self.sp_snc is None:
  1574                                                                     self.sp_snc = np.zeros(shape=8,)
  1575                                                                     t1 = True
  1576                                                                 elif self.sp_snc is not None:
  1577                                                                     t1 = True
  1578                                                                 rwarn(f"Exception while handling sp_snc pool")
  1579                                                             if not t1:
  1580                                                                 self.sp_snc[np.where(self.sp_snc < 0)[0]] = 0.0
  1581                                         
  1582                                                             # ORGANIC nutrients uptake
  1583                                                             total_on = self.sp_snc[:4].sum()
  1584                                                             if total_on > 0.0 and np.isfinite(total_on):
  1585                                                                 frsn = [i / total_on for i in self.sp_snc[:4]]
  1586                                                             else:
  1587                                                                 frsn = [0.0, 0.0, 0.0, 0.0]
  1588                                                             for i, fr in enumerate(frsn):
  1589                                                                 self.sp_snc[i] -= (self.nupt[1, step] * fr)
  1590                                         
  1591                                                             idx = np.where(self.sp_snc < 0.0)[0]
  1592                                                             if len(idx) > 0:
  1593                                                                 self.sp_snc[idx] = 0.0
  1594                                         
  1595                                                             self.sp_organic_n = self.sp_snc[:2].sum()
  1596                                                             self.sp_sorganic_n = self.sp_snc[2:4].sum()
  1597                                         
  1598                                                             # P
  1599                                                             total_op = self.sp_snc[4:].sum()
  1600                                                             if total_op > 0.0 and np.isfinite(total_op):
  1601                                                                 frsp = [i / total_op for i in self.sp_snc[4:]]
  1602                                                             else:
  1603                                                                 frsp = [0.0, 0.0, 0.0, 0.0]
  1604                                                             for i, fr in enumerate(frsp):
  1605                                                                 self.sp_snc[i + 4] -= (self.pupt[2, step] * fr)
  1606                                         
  1607                                                             idx = np.where(self.sp_snc < 0.0)[0]
  1608                                                             if len(idx) > 0:
  1609                                                                 self.sp_snc[idx] = 0.0
  1610                                         
  1611                                                             self.sp_organic_p = self.sp_snc[4:6].sum()
  1612                                                             self.sp_sorganic_p = self.sp_snc[6:].sum()
  1613                                                         # END SOIL NUTRIENT DYNAMICS
  1614                                         
  1615    196.8 MiB   -596.2 MiB       36524                   if save:
  1616                                                             # Plant uptake and Carbon costs of nutrient uptake
  1617                                                             self.storage_pool[:, step] = masked_mean_2D(self.metacomm.mask, storage_pool.astype(np.float32))
  1618                                                             self.carbon_costs[step] = masked_mean(self.metacomm.mask, cc)
  1619                                                             self.tsoil.append(self.soil_temp)
  1620                                                             self.photo[step] = masked_mean(self.metacomm.mask, photo)
  1621                                                             self.aresp[step] = masked_mean(self.metacomm.mask, aresp)
Filename: C:\Users\darel\OneDrive\Desktop\CAETE\src\caete.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
  1013    189.2 MiB    189.2 MiB           1       @profile
  1014                                             # @timer
  1015                                             def run_gridcell(self,
  1016                                                           start_date: str,
  1017                                                           end_date: str,
  1018                                                           spinup: int = 0,
  1019                                                           fixed_co2_atm_conc: Optional[str] | Optional[int] | Optional[float] = None,
  1020                                                           save: bool = True,
  1021                                                           nutri_cycle: bool = True,
  1022                                                           afex: bool = False,
  1023                                                           reset_community: bool = False,
  1024                                                           kill_and_reset: bool = False,
  1025                                                           env_filter: bool = False,
  1026                                                           process_limitation: bool = False,
  1027                                                           verbose: bool = False):
  1028                                                 """
  1029                                                 Run the model for a grid cell.
  1030                                         
  1031                                                 CAETÊ-DVM execution in the start_date - end_date period, can be used for spinup or transient runs.
  1032                                         
  1033                                                 Args:
  1034                                                     start_date (str): Start date for model execution in "yyyymmdd" format.
  1035                                                     end_date (str): End date for model execution in "yyyymmdd" format.
  1036                                                     spinup (int, optional): Number of repetitions in spinup. Set to 0 for a transient run between start_date and end_date. Default is 0.
  1037                                                     fixed_co2_atm_conc (Optional[Union[str, int, float]]): Fixed atmospheric CO2 concentration. If None, use dynamic CO2 levels from a predefined file. If a string with a year (e.g., "1987") That year's value in the provided file will be used. Use a float to set a fixed level in ppm. Default is None.
  1038                                                     save (bool, optional): Whether to save the results. Default is True.
  1039                                                     nutri_cycle (bool, optional): Whether to include nutrient cycling in the model. Default is True.
  1040                                                     afex (bool, optional): Whether to apply nutrient addition to soil in the model. Default is False.
  1041                                                     reset_community (bool, optional): Whether to restart a new community if there are not viable PLS. Default is False.
  1042                                                     kill_and_reset (bool, optional): Whether to kill and reset the community structure at the end of execution (only CVEG pools and PLS IDs). Default is False.
  1043                                                     env_filter (bool, optional): Whether to apply environmental filtering (Include new PLS periodically) []. Default is False.
  1044                                                     verbose (bool, optional): Whether to print detailed logs during execution. Default is False.
  1045                                         
  1046                                                 Returns:
  1047                                                     None
  1048                                         
  1049                                                 Notes:
  1050                                                     - If reset_community is true a new community will be set (reset) when there is no PLSs remaining.
  1051                                                     - If the kill_and_reset is true, after n spins (integer given by spinup parameter - i.e. in the end
  1052                                                       of function execution) all the communities in a gridcell are reset. The reset_community and
  1053                                                       kill_and_reset  arguments are not mutually exclusive. You can use both as true at the same time.
  1054                                                     - The env_filter argument is used to define if new unique PLSs from the main table will be
  1055                                                       seed in the communities that have free slots (PLSs that are not producing). At the moment, the
  1056                                                       interval for the env_filter to add a new PLS to the community is set to  ~15 days.
  1057                                                       If env filter argument is true, then the reset_community argument will have a very low
  1058                                                       probability to trigger a reset because the communities will be constantly filled with new PLS.
  1059                                                       Nonetheless, the reset_community argument will still be able to trigger a reset if the community loses all PLSs.
  1060                                                       With the probability of a reset_community increasing as the interval between new seeds increases. The parameter doy_months
  1061                                                       in the config file (caete.toml) is used to define the interval for the env_filter to add a new PLS to the community.
  1062                                         
  1063                                                       TODO: Implement a more flexible way to define the interval for
  1064                                                             the env_filter to add a new PLS to the community.
  1065                                                 """
  1066                                         
  1067    189.2 MiB      0.0 MiB           2           assert not fixed_co2_atm_conc or\
  1068    189.2 MiB      0.0 MiB           1               isinstance(fixed_co2_atm_conc, str) or\
  1069                                                     fixed_co2_atm_conc > 0,\
  1070                                                         "A fixed value for ATM[CO2] must be a positive number greater than zero or a proper string with the year - e.g., 'yyyy'"
  1071                                         
  1072                                         
  1073                                                 # Define start and end dates (read parameters)
  1074    189.3 MiB      0.0 MiB           1           start = parse_date(start_date)
  1075    189.3 MiB      0.0 MiB           1           end = parse_date(end_date)
  1076                                         
  1077                                                 # Check dates
  1078    189.3 MiB      0.0 MiB           1           assert start < end, "Start date must be before end date"
  1079    189.3 MiB      0.0 MiB           1           assert start >= self.start_date, "initial date out of bounds for the time array"
  1080    189.3 MiB      0.0 MiB           1           assert end <= self.end_date, f"Final date out of bounds for the time array"
  1081                                         
  1082                                         
  1083                                                 # Define time index bounds for this run
  1084                                                 # During a run we are in general using a slice ov the available time span
  1085                                                 # to run the model. For example, we can run the model for a year or a decade
  1086                                                 # at the begining of the input data time series to spin up. This slice is defined
  1087                                                 # by the start and end dates provided in the arguments. Here we get the indices.
  1088    189.4 MiB      0.1 MiB           1           self.start_index = int(cftime.date2num(start, self.time_unit, self.calendar))
  1089    189.4 MiB      0.0 MiB           1           self.end_index =   int(cftime.date2num(end, self.time_unit, self.calendar))
  1090                                         
  1091                                                 # Find the indices in the time array [used to slice the timeseries with driver data  - tas, pr, etc.]
  1092    189.8 MiB      0.5 MiB           1           lower_bound, upper_bound = self.find_index(self.start_index, self.end_index)
  1093                                         
  1094                                                 # Define the time steps range (days)
  1095    189.8 MiB      0.0 MiB           1           steps = np.arange(lower_bound, upper_bound + 1, dtype=np.int64)
  1096                                         
  1097                                                 # Define the number of repetitions for the spinup
  1098    189.8 MiB      0.0 MiB           1           spin = 1 if spinup == 0 else spinup
  1099                                         
  1100                                                 # Define the AFEX mode
  1101    189.8 MiB      0.0 MiB           1           afex_mode = self.afex_config.afex_mode # type: ignore
  1102                                         
  1103                                                 # Slice&Catch climatic input and make conversions
  1104    189.8 MiB      0.0 MiB           1           cv = self.config.conversion_factors_isimip # type: ignore
  1105                                         
  1106                                         
  1107    189.8 MiB      0.0 MiB           1           if self.config.input_handler.input_method == "ih" and self.config.input_handler.input_type == "netcdf":
  1108                                                     # Variables in Netcdf files are already in proprer units
  1109    189.8 MiB      0.0 MiB           1               temp: NDArray[np.float32] = self.tas[lower_bound: upper_bound + 1]   # Air temp: model uses °C
  1110    189.8 MiB      0.0 MiB           1               prec: NDArray[np.float32] = self.pr[lower_bound: upper_bound + 1]    # Precipitation: model uses  mm/day
  1111    189.8 MiB      0.0 MiB           1               p_atm: NDArray[np.float32] = self.ps[lower_bound: upper_bound + 1]   # Atmospheric pressure: model uses hPa
  1112    189.8 MiB      0.0 MiB           1               ipar: NDArray[np.float32] = self.rsds[lower_bound: upper_bound + 1]  # PAR: model uses  mol(photons) m-2 s-1
  1113    189.8 MiB      0.0 MiB           1               ru: NDArray[np.float32] = self.rhs[lower_bound: upper_bound + 1]     # Relative humidity: model uses 0-1
  1114                                                 else:
  1115                                                     temp: NDArray[np.float32] = self.tas[lower_bound: upper_bound + 1] - cv.tas    # Air temp: model uses °C
  1116                                                     prec: NDArray[np.float32] = self.pr[lower_bound: upper_bound + 1] * cv.pr      # Precipitation: model uses  mm/day
  1117                                                     p_atm: NDArray[np.float32] = self.ps[lower_bound: upper_bound + 1] * cv.ps     # Atmospheric pressure: model uses hPa
  1118                                                     ipar: NDArray[np.float32] = self.rsds[lower_bound: upper_bound + 1] * cv.rsds  # PAR: model uses  mol(photons) m-2 s-1
  1119                                                     ru: NDArray[np.float32] = self.rhs[lower_bound: upper_bound + 1] * cv.rhs      # Relative humidity: model uses 0-1
  1120                                         
  1121                                                 # Define the daily values for co2 concentrations
  1122    189.8 MiB      0.0 MiB           1           co2_daily_values = np.zeros(steps.size, dtype=np.float32)
  1123                                         
  1124    189.8 MiB      0.0 MiB           1           if fixed_co2_atm_conc is None:
  1125                                                     # In this case, the co2 concentration will be updated daily.
  1126                                                     # We interpolate linearly between the yearly values of the atm co2 data
  1127                                                     co2 = self.find_co2(start.year)
  1128                                                     today = datetime(start.year, start.month, start.day, start.hour, start.minute, start.second)
  1129                                                     time_step = timedelta(days=1) # Define the time step
  1130                                                     today -= time_step # The first thing we do next is to add a day to the date. So we go back one day
  1131                                                     # Loop over the days and calculate the co2 concentration for each day
  1132                                                     for step in range(steps.size):
  1133                                                         today += time_step
  1134                                                         remaining = (datetime(today.year, 12, 31) - today).days + 1
  1135                                                         daily_fraction = (self.find_co2(today.year + 1) - co2) / (remaining + 1)
  1136                                                         co2 += daily_fraction
  1137                                                         co2_daily_values[step] = co2
  1138    189.8 MiB      0.0 MiB           1           elif isinstance(fixed_co2_atm_conc, int) or isinstance(fixed_co2_atm_conc, float):
  1139                                                     # In this case, the co2 concentration will be fixed according to the numeric value provided in the argument
  1140                                                     co2 = fixed_co2_atm_conc
  1141                                                     co2_daily_values += co2
  1142    189.8 MiB      0.0 MiB           1           elif isinstance(fixed_co2_atm_conc, str):
  1143                                                     # In this case, the co2 concentration will be fixed
  1144                                                     # According to the year provided in the argument
  1145                                                     # as a string. Format "yyyy".
  1146    189.8 MiB      0.0 MiB           1               try:
  1147    189.8 MiB      0.0 MiB           1                   co2_year = int(fixed_co2_atm_conc)
  1148                                                     except ValueError:
  1149                                                         raise ValueError(
  1150                                                             "The string(\"yyyy\") must be a number in the {self.start_date.year} - {self.end_date.year} interval")
  1151    189.8 MiB      0.0 MiB           1               co2 = self.find_co2(co2_year)
  1152    189.9 MiB      0.0 MiB           1               co2_daily_values += co2
  1153                                                 else:
  1154                                                     raise ValueError("Invalid value for fixed_co2_atm_conc")
  1155                                         
  1156                                                 # Define variables to track dates
  1157    189.9 MiB      0.0 MiB           1           first_day_of_simulation = datetime(start.year, start.month, start.day, start.hour, start.minute, start.second)
  1158                                                 # Define the time step
  1159    189.9 MiB      0.0 MiB           1           time_step = timedelta(days=1)
  1160                                         
  1161                                                 # Define the object to store the outputs from daily_budget
  1162    189.9 MiB      0.0 MiB           1           daily_output = DailyBudget()
  1163                                         
  1164                                                 # Start loops
  1165                                                 # This outer loop is used to run the model for a number
  1166                                                 # of times defined by the spinup argument. The model is
  1167                                                 # executed repeatedly between the start and end dates
  1168                                                 # provided in the arguments
  1169                                         
  1170    197.0 MiB      0.0 MiB           3           for s in range(spin):
  1171                                         
  1172    197.1 MiB      4.4 MiB           2               self._allocate_output(steps.size, self.metacomm.comm_npls, len(self.metacomm), save)
  1173                                         
  1174                                                     # Loop over the days
  1175    197.1 MiB      0.0 MiB           2               today = first_day_of_simulation
  1176                                         
  1177                                                     # Go back one day
  1178    197.1 MiB      0.0 MiB           2               today -= time_step
  1179                                         
  1180                                                     # Arrays to store & pass values for each community in a simulated day
  1181    197.1 MiB      0.0 MiB           2               sto =        np.zeros(shape=(3, self.metacomm.comm_npls), order='F')
  1182    197.1 MiB      0.0 MiB           2               cleaf_in =   np.zeros(self.metacomm.comm_npls, order='F')
  1183    197.1 MiB      0.0 MiB           2               cwood_in =   np.zeros(self.metacomm.comm_npls, order='F')
  1184    197.1 MiB      0.0 MiB           2               croot_in =   np.zeros(self.metacomm.comm_npls, order='F')
  1185    197.1 MiB      0.0 MiB           2               uptk_costs = np.zeros(self.metacomm.comm_npls, order='F')
  1186    197.1 MiB      0.0 MiB           2               rnpp_in =    np.zeros(self.metacomm.comm_npls, order='F')
  1187                                         
  1188                                                     # There are two modes of operation: save and not save.
  1189                                                     # In the save == False mode, the arrays are used to store the values that are
  1190                                                     # needed for model iteration, i.e., the values that are used in the next
  1191                                                     # time step. In the save mode, an extra number arrays is created to be used
  1192                                                     # to store the outputs.
  1193    197.1 MiB      0.0 MiB           2               xsize: int = len(self.metacomm) # Number of communities
  1194    197.1 MiB      0.0 MiB           2               evavg: NDArray[np.float32] = np.zeros(xsize, dtype=np.float32)
  1195    197.1 MiB      0.0 MiB           2               epavg: NDArray[np.float32] = np.zeros(xsize, dtype=np.float32)
  1196    197.1 MiB      0.0 MiB           2               rnpp_mt: NDArray[np.float32] = np.zeros(xsize, dtype=np.float32)
  1197                                         
  1198                                                     # We keep track of these to input in SOM dynamics later. They are used for output also
  1199    197.1 MiB      0.0 MiB           2               leaf_litter: NDArray[np.float32] = np.zeros(xsize, dtype=np.float32)
  1200    197.1 MiB      0.0 MiB           2               cwd: NDArray[np.float32] = np.zeros(xsize, dtype=np.float32)
  1201    197.1 MiB      0.0 MiB           2               root_litter: NDArray[np.float32] = np.zeros(xsize, dtype=np.float32)
  1202    197.1 MiB      0.0 MiB           2               lnc: NDArray[np.float32] = np.zeros(shape=(6, xsize), dtype=np.float32)
  1203                                                     # This is added to leaf litter pool (that is basicaly a fast SOM pool)
  1204    197.1 MiB      0.0 MiB           2               c_to_nfixers: NDArray[np.float32]= np.zeros(xsize, dtype=np.float32)
  1205    197.1 MiB      0.0 MiB           2               nupt = np.zeros(shape=(2, xsize), dtype=np.float32)
  1206    197.1 MiB      0.0 MiB           2               pupt = np.zeros(shape=(3, xsize), dtype=np.float32)
  1207                                         
  1208    197.1 MiB      0.0 MiB           2               if save:
  1209                                                         cc = np.zeros(xsize, dtype=np.float32)
  1210                                                         photo = np.zeros(xsize, dtype=np.float32)
  1211                                                         aresp = np.zeros(xsize, dtype=np.float32)
  1212                                                         npp = np.zeros(xsize, dtype=np.float32)
  1213                                                         lai = np.zeros(xsize, dtype=np.float32)
  1214                                                         rcm = np.zeros(xsize, dtype=np.float32)
  1215                                                         f5 = np.zeros(xsize, dtype=np.float32)
  1216                                                         rm = np.zeros(xsize, dtype=np.float32)
  1217                                                         rg = np.zeros(xsize, dtype=np.float32)
  1218                                                         wue = np.zeros(xsize, dtype=np.float32)
  1219                                                         cue = np.zeros(xsize, dtype=np.float32)
  1220                                                         carbon_deficit = np.zeros(xsize, dtype=np.float32)
  1221                                                         vcmax = np.zeros(xsize, dtype=np.float32)
  1222                                                         specific_la = np.zeros(xsize, dtype=np.float32)
  1223                                                         storage_pool = np.zeros(shape=(3, xsize))
  1224                                         
  1225                                                         if process_limitation:
  1226                                                             lim_status_y_leaf = np.ma.masked_all((xsize, self.metacomm.comm_npls, 366), dtype=np.int8)
  1227                                                             lim_status_y_stem = np.ma.masked_all((xsize, self.metacomm.comm_npls, 366), dtype=np.int8)
  1228                                                             lim_status_y_root = np.ma.masked_all((xsize, self.metacomm.comm_npls, 366), dtype=np.int8)
  1229                                                             uptake_strategy_n = np.ma.masked_all((xsize, self.metacomm.comm_npls, 366), dtype=np.int8)
  1230                                                             uptake_strategy_p = np.ma.masked_all((xsize, self.metacomm.comm_npls, 366), dtype=np.int8)
  1231                                         
  1232                                                     # <- Daily loop
  1233    197.1 MiB   -602.5 MiB       36526               for step in range(steps.size):
  1234    197.1 MiB   -602.4 MiB       36524                   today += time_step
  1235    197.1 MiB   -602.4 MiB       36524                   julian_day = today.timetuple().tm_yday
  1236                                         
  1237                                                         # Get the co2 concentration for the day
  1238    197.1 MiB   -602.5 MiB       36524                   co2 = co2_daily_values[step]
  1239                                                         # Update soil temperature
  1240    197.1 MiB   -602.4 MiB       36524                   self.soil_temp = st.soil_temp(self.soil_temp, temp[step])
  1241                                         
  1242                                                         # AFEX
  1243    197.1 MiB   -602.5 MiB       36524                   if afex and julian_day == 365:
  1244                                                             self.add_soil_nutrients(afex_mode)
  1245                                         
  1246                                                         # Loop over communities
  1247    197.1 MiB   -602.5 MiB       36524                   living_pls = 0 # Sum of living PLS in the communities
  1248    197.1 MiB  -1204.9 MiB       73048                   for i, community in enumerate(self.metacomm):
  1249                                                             # if i >= len(self.metacomm):
  1250                                                             #     break
  1251                                                             # if community.masked:
  1252                                                             #     # skip this one
  1253                                                             #     continue
  1254    197.1 MiB   -602.2 MiB       36524                       sto[0, :] = inflate_array(community.npls, community.vp_sto[0, :], community.vp_lsid)
  1255    197.1 MiB   -602.5 MiB       36524                       sto[1, :] = inflate_array(community.npls, community.vp_sto[1, :], community.vp_lsid)
  1256    197.1 MiB   -602.5 MiB       36524                       sto[2, :] = inflate_array(community.npls, community.vp_sto[2, :], community.vp_lsid)
  1257                                         
  1258    197.1 MiB   -602.2 MiB       36524                       cleaf_in[:] = inflate_array(community.npls, community.vp_cleaf, community.vp_lsid)
  1259    197.1 MiB   -602.5 MiB       36524                       cwood_in[:] = inflate_array(community.npls, community.vp_cwood, community.vp_lsid)
  1260    197.1 MiB   -602.5 MiB       36524                       croot_in[:] = inflate_array(community.npls, community.vp_croot, community.vp_lsid)
  1261    197.1 MiB   -602.1 MiB       36524                       uptk_costs[:] = inflate_array(community.npls, community.sp_uptk_costs, community.vp_lsid)
  1262    197.1 MiB   -602.4 MiB       36524                       rnpp_in[:] = inflate_array(community.npls, community.construction_npp, community.vp_lsid)
  1263                                         
  1264    197.1 MiB   -602.4 MiB       36524                       ton = self.sp_organic_n #+ self.sp_sorganic_n
  1265    197.1 MiB   -602.5 MiB       36524                       top = self.sp_organic_p #+ self.sp_sorganic_p
  1266                                         
  1267                                                             # Community daily budget calculation
  1268    197.1 MiB  -1203.8 MiB       73048                       out = model.daily_budget(community.pls_array, self.wp_water_upper_mm,
  1269    197.1 MiB   -602.5 MiB       36524                                               self.wp_water_lower_mm, self.soil_temp, temp[step],
  1270    197.1 MiB   -602.5 MiB       36524                                               p_atm[step], ipar[step], ru[step], self.sp_available_n,
  1271    197.1 MiB   -602.5 MiB       36524                                               self.sp_available_p, ton, top, self.sp_organic_p,
  1272    197.1 MiB   -602.5 MiB       36524                                               co2, sto, cleaf_in, cwood_in, croot_in, uptk_costs,self.wmax_mm,
  1273    197.1 MiB   -602.5 MiB       36524                                               rnpp_in)
  1274                                         
  1275                                                             # get daily budget results
  1276    197.1 MiB   -602.5 MiB       36524                       daily_output.update(out)
  1277                                         
  1278                                                             # Update the community status
  1279    197.1 MiB   -602.1 MiB       36524                       community.update_lsid(daily_output.ocpavg)
  1280                                         
  1281                                                             # Abort community if no PLSs are left while saving the spin
  1282    197.1 MiB   -602.5 MiB       36524                       if community.masked and save:
  1283                                                                 continue
  1284                                         
  1285    197.1 MiB   -602.5 MiB       36524                       community.ls = community.vp_lsid.size
  1286                                                             # # Restore or seed PLS
  1287    197.1 MiB   -602.5 MiB       36524                       if env_filter and (community.ls < self.metacomm.comm_npls) and not save:
  1288    197.1 MiB    -49.9 MiB        3322                           if julian_day in self.doy_months:
  1289    197.1 MiB     -2.9 MiB         211                               new_id, new_PLS = community.get_unique_pls(self.get_from_main_array)
  1290    197.1 MiB     -5.9 MiB         422                               community.seed_pls(new_id, new_PLS, daily_output.cleafavg_pft,
  1291    197.1 MiB     -3.0 MiB         211                                                  daily_output.cfrootavg_pft, daily_output.cawoodavg_pft)
  1292    197.1 MiB     -3.0 MiB         211                               if verbose: print(f"PLS seed in Community {i}: Gridcell: {self.lat} °N, {self.lon} °E: In spin:{s}, step:{step}")
  1293                                         
  1294    197.1 MiB     -6.0 MiB         422                               daily_output.ocpavg = pft_area_frac64(daily_output.cleafavg_pft,
  1295    197.1 MiB     -3.0 MiB         211                                                               daily_output.cfrootavg_pft,
  1296    197.1 MiB     -3.0 MiB         211                                                               daily_output.cawoodavg_pft)
  1297    197.1 MiB     -3.0 MiB         211                               community.update_lsid(daily_output.ocpavg)
  1298    197.1 MiB     -3.0 MiB         211                               community.ls = community.vp_lsid.size
  1299                                                                 # endif
  1300                                         
  1301                                         
  1302    197.1 MiB   -602.5 MiB       36524                       community.vp_ocp = daily_output.ocpavg[community.vp_lsid]
  1303    197.1 MiB   -602.5 MiB       36524                       community.vp_cleaf = daily_output.cleafavg_pft[community.vp_lsid]
  1304    197.1 MiB   -602.5 MiB       36524                       community.vp_cwood = daily_output.cawoodavg_pft[community.vp_lsid]
  1305    197.1 MiB   -602.5 MiB       36524                       community.vp_croot = daily_output.cfrootavg_pft[community.vp_lsid]
  1306    197.1 MiB   -602.4 MiB       36524                       community.vp_sto = daily_output.stodbg[:, community.vp_lsid].astype('float32')
  1307    197.1 MiB   -602.5 MiB       36524                       community.sp_uptk_costs = daily_output.npp2pay[community.vp_lsid]
  1308    197.1 MiB   -602.5 MiB       36524                       community.construction_npp = daily_output.rnpp_out[community.vp_lsid]
  1309    197.1 MiB   -602.5 MiB       36524                       living_pls += community.ls
  1310                                                             # print(f"Community storage: {community.vp_sto[0, :]}")
  1311                                                             # print(f"Sto_budget_out {daily_output.stodbg[0, :]}")
  1312                                         
  1313                                                             # Limiting nutrient organization:
  1314                                                             # dim1 = leaf wood root, code: 1=N 2=P 4=N,COLIM 5=P,COLIM 6=COLIM 0=NOLIM
  1315    197.1 MiB   -602.5 MiB       36524                       if save:
  1316                                                                 if process_limitation:
  1317                                                                     lim_status_y_leaf[i, :, julian_day - 1] = daily_output.limitation_status[0,:]# type: ignore
  1318                                                                     lim_status_y_stem[i, :, julian_day - 1] = daily_output.limitation_status[1,:]# type: ignore
  1319                                                                     lim_status_y_root[i, :, julian_day - 1] = daily_output.limitation_status[2,:]# type: ignore
  1320                                                                     uptake_strategy_n[i, :, julian_day - 1] = daily_output.uptk_strat[0,:]# type: ignore
  1321                                                                     uptake_strategy_p[i, :, julian_day - 1] = daily_output.uptk_strat[1,:]# type: ignore
  1322                                         
  1323                                                                 community.anpp += cw_mean(community.vp_ocp, community.construction_npp.astype(np.float32))
  1324                                                                 community.uptake_costs += cw_mean(community.vp_ocp, community.sp_uptk_costs.astype(np.float32))
  1325                                         
  1326    197.1 MiB   -602.5 MiB       36524                       if save and julian_day == 365:
  1327                                                                 community.cleaf = cw_mean(community.vp_ocp, community.vp_cleaf.astype(np.float32))
  1328                                                                 community.cwood = cw_mean(community.vp_ocp, community.vp_cwood.astype(np.float32))
  1329                                                                 community.croot = cw_mean(community.vp_ocp, community.vp_croot.astype(np.float32))
  1330                                                                 community.csto = cw_mean(community.vp_ocp, community.vp_sto[0, :])
  1331                                                                 community.shannon_diversity = shannon_diversity(community.vp_ocp)
  1332                                                                 community.shannon_entropy = shannon_entropy(community.vp_ocp)
  1333                                                                 community.shannon_evenness = shannon_evenness(community.vp_ocp)
  1334                                         
  1335                                                                 # process limitation data
  1336                                                                 # Filter non living PLS from the limitation status
  1337                                                                 if process_limitation:
  1338                                                                     _data_leaf = lim_status_y_leaf[i, [community.vp_lsid], :] # type: ignore
  1339                                                                     _data_stem = lim_status_y_stem[i, [community.vp_lsid], :] # type: ignore
  1340                                                                     _data_root = lim_status_y_root[i, [community.vp_lsid], :] # type: ignore
  1341                                         
  1342                                                                     _data_uptake_n = uptake_strategy_n[i, [community.vp_lsid], :]# type: ignore
  1343                                                                     _data_uptake_p = uptake_strategy_p[i, [community.vp_lsid], :]# type: ignore
  1344                                         
  1345                                                                     # Loop over the living PLS to get the unique values and counts
  1346                                                                     pls_lim_leaf = []
  1347                                                                     pls_lim_stem = []
  1348                                                                     pls_lim_root = []
  1349                                                                     pls_uptake_n = []
  1350                                                                     pls_uptake_p = []
  1351                                         
  1352                                                                     for k in range(community.vp_lsid.size):
  1353                                                                         # Get the unique values and counts for leaf limitation
  1354                                                                         unique, counts = np.unique(_data_leaf[0, k, :], return_counts=True)
  1355                                                                         unique = unique.data[unique.mask == False] # type: ignore
  1356                                                                         pls_lim_leaf.append((unique, counts[:unique.size])) # type: ignore
  1357                                         
  1358                                                                         # Stem limitation
  1359                                                                         unique, counts = np.unique(_data_stem[0, k, :], return_counts=True)
  1360                                                                         unique = unique.data[unique.mask == False] # type: ignore
  1361                                                                         pls_lim_stem.append((unique, counts[:unique.size])) # type: ignore
  1362                                         
  1363                                                                         # Root limitation
  1364                                                                         unique, counts = np.unique(_data_root[0, k, :], return_counts=True)
  1365                                                                         unique = unique.data[unique.mask == False]
  1366                                                                         pls_lim_root.append((unique, counts[:unique.size])) # type: ignore
  1367                                         
  1368                                                                         # Uptake strategy N
  1369                                                                         unique, counts = np.unique(_data_uptake_n[0, k, :], return_counts=True)
  1370                                                                         unique = unique.data[unique.mask == False] # type: ignore
  1371                                                                         pls_uptake_n.append((unique, counts[:unique.size])) # type: ignore
  1372                                         
  1373                                                                         # Uptake strategy P
  1374                                                                         unique, counts = np.unique(_data_uptake_p[0, k, :], return_counts=True)
  1375                                                                         unique = unique.data[unique.mask == False]  # type: ignore
  1376                                                                         pls_uptake_p.append((unique, counts[:unique.size])) # type: ignore
  1377                                         
  1378                                                                     community.limitation_status_leaf = pls_lim_leaf
  1379                                                                     community.limitation_status_wood = pls_lim_stem
  1380                                                                     community.limitation_status_root = pls_lim_root
  1381                                                                     community.uptake_strategy_n = pls_uptake_n
  1382                                                                     community.uptake_strategy_p = pls_uptake_p
  1383                                         
  1384                                                                     # Reset the limitation masked arrays
  1385                                                                     lim_status_y_leaf.mask[i, :, :] = np.ones((self.metacomm.comm_npls, 366), dtype=bool) # type: ignore
  1386                                                                     lim_status_y_stem.mask[i, :, :] = np.ones((self.metacomm.comm_npls, 366), dtype=bool) # type: ignore
  1387                                                                     lim_status_y_root.mask[i, :, :] = np.ones((self.metacomm.comm_npls, 366), dtype=bool) # type: ignore
  1388                                                                     uptake_strategy_n.mask[i, :, :] = np.ones((self.metacomm.comm_npls, 366), dtype=bool) # type: ignore
  1389                                                                     uptake_strategy_p.mask[i, :, :] = np.ones((self.metacomm.comm_npls, 366), dtype=bool) # type: ignore
  1390                                                                 else:
  1391                                                                     pass
  1392                                         
  1393    197.1 MiB   -602.5 MiB       36524                       if community.vp_lsid.size < 1:
  1394                                                                 if verbose: print(f"Empty community {i}: Gridcell: {self.lat} °N, {self.lon} °E: In spin:{s}, step:{step}")
  1395                                                                 if reset_community:
  1396                                                                     assert not save, "Cannot save data when resetting communities"
  1397                                                                     if verbose: print(f"Reseting community {i}: Gridcell: {self.lat} °N, {self.lon} °E: In spin:{s}, step:{step}")
  1398                                         
  1399                                                                     new_life_strategies = self.get_from_main_array(community.npls)
  1400                                                                     community.restore_from_main_table(new_life_strategies)
  1401                                                                     # continue
  1402                                         
  1403                                                                 else:
  1404                                                                     # In the transiant run - i.e., when reset_community is false and
  1405                                                                     # kill_and_reset is false; we mask the community if there is no PLS
  1406                                                                     self.metacomm.mask[i] = np.int8(1)
  1407                                                                     # Set mask to true for this community, will not run in the next steps
  1408                                                                     # Set annual values to zero
  1409                                                                     community.masked = np.int8(1)
  1410                                                                     community.cleaf = np.float32(0.0)
  1411                                                                     community.cwood = np.float32(0.0)
  1412                                                                     community.croot = np.float32(0.0)
  1413                                                                     community.csto  = np.float32(0.0)
  1414                                                                     community.shannon_diversity = -9999.0
  1415                                                                     community.shannon_entropy = -9999.0
  1416                                                                     community.shannon_evenness = -9999.0
  1417                                                                     # if the reset_community is true
  1418                                                                     # continue # cycle
  1419                                         
  1420                                                             # Store values for each community
  1421    197.1 MiB   -602.5 MiB       36524                       rnpp_mt[i] = cw_mean(community.vp_ocp, community.construction_npp.astype(np.float32)) # Community Weighted rNPP
  1422    197.1 MiB   -602.5 MiB       36524                       leaf_litter[i] = daily_output.litter_l
  1423    197.1 MiB   -602.5 MiB       36524                       root_litter[i] = daily_output.litter_fr
  1424    197.1 MiB   -602.5 MiB       36524                       cwd[i] = daily_output.cwd
  1425    197.1 MiB   -602.5 MiB       36524                       lnc[:, i] = daily_output.lnc.astype(np.float32)
  1426    197.1 MiB   -602.5 MiB       36524                       c_to_nfixers[i] = daily_output.cp[3]
  1427    197.1 MiB   -602.5 MiB       36524                       evavg[i] = daily_output.evavg
  1428    197.1 MiB   -602.5 MiB       36524                       epavg[i] = daily_output.epavg
  1429    197.1 MiB   -602.5 MiB       36524                       nupt[:, i] = daily_output.nupt #type: ignore
  1430    197.1 MiB   -602.5 MiB       36524                       pupt[:, i] = daily_output.pupt #type: ignore
  1431                                         
  1432    197.1 MiB   -602.5 MiB       36524                       if save:
  1433                                                                 cc[i] = daily_output.c_cost_cwm #type: ignore
  1434                                                                 npp[i] = daily_output.nppavg #type: ignore
  1435                                                                 photo[i] = daily_output.phavg #type: ignore
  1436                                                                 aresp[i] = daily_output.aravg #type: ignore
  1437                                                                 lai[i] = daily_output.laiavg #type: ignore
  1438                                                                 rcm[i] = daily_output.rcavg #type: ignore
  1439                                                                 f5[i] = daily_output.f5avg #type: ignore
  1440                                                                 rm[i] = daily_output.rmavg #type: ignore
  1441                                                                 rg[i] = daily_output.rgavg #type: ignore
  1442                                                                 wue[i] = daily_output.wueavg #type: ignore
  1443                                                                 cue[i] = daily_output.cueavg #type: ignore
  1444                                                                 carbon_deficit[i] = daily_output.c_defavg #type: ignore
  1445                                                                 vcmax[i] = daily_output.vcmax #type: ignore
  1446                                                                 specific_la[i] = daily_output.specific_la #type: ignore
  1447                                         
  1448                                                                 for j in range(daily_output.stodbg.shape[0]):
  1449                                                                     storage_pool[j, i] = cw_mean(community.vp_ocp, community.vp_sto[j, :]) #type: ignore
  1450                                         
  1451                                                         #<- Out of the community loop
  1452                                                         # Save annual state of the metacommunity
  1453    197.1 MiB   -602.5 MiB       36524                   if save:
  1454                                                             if julian_day == 365:
  1455                                                                 y = today.year
  1456                                                                 # m = today.month
  1457                                                                 # d = today.day
  1458                                                                 filename = self.out_dir/f"metacommunity_{y}.pkz"
  1459                                                                 # filename = self.out_dir/f"metacommunity_{d}{m}{y}.pkz"
  1460                                                                 self.metacomm.save_state(filename, y, process_limitation)
  1461                                                                 self.metacomm_output[y] = filename
  1462                                         
  1463                                                                 for community in self.metacomm:
  1464                                                                     # Set annual accumulators to zero
  1465                                                                     community.anpp = np.float32(0.0)
  1466                                                                     community.uptake_costs = np.float32(0.0)
  1467                                         
  1468                                                         # ------------
  1469                                                         # Evapotranspiration
  1470    197.1 MiB   -602.5 MiB       36524                   et = masked_mean(self.metacomm.mask, evavg) #evavg.mean()
  1471                                                         ## Canopy-atmosphere coupling [EXPERIMENTAL]
  1472                                                         # vpd = m.vapor_p_deficit(temp[step], ru[step])
  1473                                                         # et_pot = masked_mean(self.metacomm.mask, np.array(epavg).astype(np.float32)) #epavg.mean()
  1474                                                         # self.evapm[step] = atm_canopy_coupling(et_pot, et, temp[step], vpd)
  1475    197.1 MiB   -602.5 MiB       36524                   self.evapm[step] = et
  1476                                         
  1477                                                         # Update water pools
  1478                                         
  1479    197.1 MiB   -602.3 MiB       36524                   self.runom[step] = self.swp._update_pool(prec[step], self.evapm[step])
  1480    197.1 MiB   -602.5 MiB       36524                   self.swp.w1 = 0.0 if self.swp.w1 < 0.0 else self.swp.w1
  1481    197.1 MiB   -602.5 MiB       36524                   self.swp.w2 = 0.0 if self.swp.w2 < 0.0 else self.swp.w2
  1482    197.1 MiB   -602.5 MiB       36524                   self.wp_water_upper_mm = self.swp.awc1
  1483    197.1 MiB   -602.5 MiB       36524                   self.wp_water_lower_mm = self.swp.awc2
  1484    197.1 MiB   -602.5 MiB       36524                   wtot = self.swp.w1 + self.swp.w2
  1485                                         
  1486                                                         # Update cflux to the soil for output, mean values over the communities
  1487                                                         # Values are also used to update SOM dynamics
  1488    197.1 MiB  -1204.9 MiB       73048                   self.litter_l[step] = masked_mean(self.metacomm.mask, leaf_litter) +\
  1489    197.1 MiB   -602.5 MiB       36524                                         masked_mean(self.metacomm.mask, c_to_nfixers)
  1490    197.1 MiB   -602.5 MiB       36524                   self.cwd[step] = masked_mean(self.metacomm.mask, cwd)
  1491    197.1 MiB   -602.5 MiB       36524                   self.litter_fr[step] = masked_mean(self.metacomm.mask, root_litter)
  1492    197.1 MiB   -602.5 MiB       36524                   self.lnc[:, step] = masked_mean_2D(self.metacomm.mask, lnc)
  1493                                         
  1494                                                         # Soil C:N:P balance and OM decomposition
  1495    197.1 MiB  -1204.9 MiB       73048                   s_out = soil_dec.carbon3(self.soil_temp, wtot / self.wmax_mm, self.litter_l[step],
  1496    197.1 MiB   -602.5 MiB       36524                                            self.cwd[step], self.litter_fr[step], self.lnc[:, step],
  1497    197.1 MiB   -602.5 MiB       36524                                            self.sp_csoil, self.sp_snc)
  1498    197.1 MiB   -602.5 MiB       36524                   soil_out = catch_out_carbon3(s_out)
  1499                                         
  1500                                                         # Organic C N & P
  1501    197.1 MiB   -602.5 MiB       36524                   self.sp_csoil = soil_out['cs']
  1502    197.1 MiB   -602.5 MiB       36524                   self.sp_snc = np.zeros(shape=8)
  1503    197.1 MiB   -602.5 MiB       36524                   self.sp_snc = soil_out['snc']
  1504    197.1 MiB   -602.4 MiB       36524                   idx = np.where(self.sp_snc < 0.0)[0]
  1505    197.1 MiB   -602.5 MiB       36524                   if len(idx) > 0:
  1506                                                             self.sp_snc[idx] = 0.0
  1507                                         
  1508                                                         # <- Out of the community loop
  1509    197.1 MiB   -602.5 MiB       36524                   self.nupt[:, step] = masked_mean_2D(self.metacomm.mask, nupt)
  1510    197.1 MiB   -602.5 MiB       36524                   self.pupt[:, step] = masked_mean_2D(self.metacomm.mask, pupt)
  1511                                         
  1512                                                         # TODO: Soil nutrient dynamics. Isolate this if branch into a separate method/class/function
  1513                                                         # Critical part of soil nutrient dynamics and availability for plants
  1514                                                         # IF NUTRICYCLE
  1515    197.1 MiB   -602.5 MiB       36524                   if nutri_cycle:
  1516                                                             # UPDATE ORGANIC POOLS
  1517                                                             self.sp_organic_n = self.sp_snc[:2].sum()
  1518                                                             self.sp_sorganic_n = self.sp_snc[2:4].sum()
  1519                                                             self.sp_organic_p = self.sp_snc[4:6].sum()
  1520                                                             self.sp_sorganic_p = self.sp_snc[6:].sum()
  1521                                         
  1522                                                             # Update inorganic pools
  1523                                                             self.sp_available_p += soil_out['pmin']
  1524                                                             self.sp_available_n += soil_out['nmin']
  1525                                                             self.sp_available_p -= self.pupt[0, step]
  1526                                                             self.sp_available_n -= self.nupt[0, step]
  1527                                         
  1528                                                             # NUTRIENT DINAMICS
  1529                                         
  1530                                                             # Inorganic N
  1531                                                             # TODO: NaNs are being sourced upstream , need to track the source and fix it
  1532                                         
  1533                                                             if not np.isfinite(self.sp_in_n):
  1534                                                                 # rwarn(f"Non-finite value detected in sp_in_n pool at step {step}. Resetting to zero.")
  1535                                                                 self.sp_in_n = 0.0
  1536                                                             if not np.isfinite(self.sp_available_n):
  1537                                                                 # rwarn(f"Non-finite value detected in sp_available_n pool at step {step}. Resetting to zero.")
  1538                                                                 self.sp_available_n = 0.0
  1539                                                             if not np.isfinite(self.sp_so_n):
  1540                                                                 # rwarn(f"Non-finite value detected in sp_so_n pool at step {step}. Resetting to zero.")
  1541                                                                 self.sp_so_n = 0.0
  1542                                         
  1543                                                             self.sp_in_n += self.sp_available_n + self.sp_so_n
  1544                                                             self.sp_so_n = soil_dec.sorbed_n_equil(self.sp_in_n)
  1545                                                             self.sp_available_n = soil_dec.solution_n_equil(self.sp_in_n)
  1546                                                             self.sp_in_n -= (self.sp_so_n + self.sp_available_n)
  1547                                         
  1548                                                             # Inorganic P
  1549                                                             if not np.isfinite(self.sp_in_p):
  1550                                                                 # rwarn(f"Non-finite value detected in sp_in_p pool at step {step}. Resetting to zero.")
  1551                                                                 self.sp_in_p = 0.0
  1552                                                             if not np.isfinite(self.sp_available_p):
  1553                                                                 # rwarn(f"Non-finite value detected in sp_available_p pool at step {step}. Resetting to zero.")
  1554                                                                 self.sp_available_p = 0.0
  1555                                                             if not np.isfinite(self.sp_so_p):
  1556                                                                 # rwarn(f"Non-finite value detected in sp_so_p pool at step {step}. Resetting to zero.")
  1557                                                                 self.sp_so_p = 0.0
  1558                                         
  1559                                                             self.sp_in_p += self.sp_available_p + self.sp_so_p
  1560                                                             # sp_so_p is the occluded P in the inorganic pool
  1561                                                             self.sp_so_p = soil_dec.sorbed_p_equil(self.sp_in_p)
  1562                                                             # THe fraction that can be dissolved in soil solution (passive uptake uses transpiration
  1563                                                             # to estimate the amount of P that can be taken up from the soil solution pool)
  1564                                                             self.sp_available_p = soil_dec.solution_p_equil(self.sp_in_p)
  1565                                                             # Inorganic pool that is adsorbed
  1566                                                             self.sp_in_p -= (self.sp_so_p + self.sp_available_p)
  1567                                         
  1568                                                             self.sp_so_p -= self.pupt[1, step]
  1569                                         
  1570                                                             try:
  1571                                                                 t1 = np.all(self.sp_snc > 0.0)
  1572                                                             except:
  1573                                                                 if self.sp_snc is None:
  1574                                                                     self.sp_snc = np.zeros(shape=8,)
  1575                                                                     t1 = True
  1576                                                                 elif self.sp_snc is not None:
  1577                                                                     t1 = True
  1578                                                                 rwarn(f"Exception while handling sp_snc pool")
  1579                                                             if not t1:
  1580                                                                 self.sp_snc[np.where(self.sp_snc < 0)[0]] = 0.0
  1581                                         
  1582                                                             # ORGANIC nutrients uptake
  1583                                                             total_on = self.sp_snc[:4].sum()
  1584                                                             if total_on > 0.0 and np.isfinite(total_on):
  1585                                                                 frsn = [i / total_on for i in self.sp_snc[:4]]
  1586                                                             else:
  1587                                                                 frsn = [0.0, 0.0, 0.0, 0.0]
  1588                                                             for i, fr in enumerate(frsn):
  1589                                                                 self.sp_snc[i] -= (self.nupt[1, step] * fr)
  1590                                         
  1591                                                             idx = np.where(self.sp_snc < 0.0)[0]
  1592                                                             if len(idx) > 0:
  1593                                                                 self.sp_snc[idx] = 0.0
  1594                                         
  1595                                                             self.sp_organic_n = self.sp_snc[:2].sum()
  1596                                                             self.sp_sorganic_n = self.sp_snc[2:4].sum()
  1597                                         
  1598                                                             # P
  1599                                                             total_op = self.sp_snc[4:].sum()
  1600                                                             if total_op > 0.0 and np.isfinite(total_op):
  1601                                                                 frsp = [i / total_op for i in self.sp_snc[4:]]
  1602                                                             else:
  1603                                                                 frsp = [0.0, 0.0, 0.0, 0.0]
  1604                                                             for i, fr in enumerate(frsp):
  1605                                                                 self.sp_snc[i + 4] -= (self.pupt[2, step] * fr)
  1606                                         
  1607                                                             idx = np.where(self.sp_snc < 0.0)[0]
  1608                                                             if len(idx) > 0:
  1609                                                                 self.sp_snc[idx] = 0.0
  1610                                         
  1611                                                             self.sp_organic_p = self.sp_snc[4:6].sum()
  1612                                                             self.sp_sorganic_p = self.sp_snc[6:].sum()
  1613                                                         # END SOIL NUTRIENT DYNAMICS
  1614                                         
  1615    197.1 MiB   -602.5 MiB       36524                   if save:
  1616                                                             # Plant uptake and Carbon costs of nutrient uptake
  1617                                                             self.storage_pool[:, step] = masked_mean_2D(self.metacomm.mask, storage_pool.astype(np.float32))
  1618                                                             self.carbon_costs[step] = masked_mean(self.metacomm.mask, cc)
  1619                                                             self.tsoil.append(self.soil_temp)
  1620                                                             self.photo[step] = masked_mean(self.metacomm.mask, photo)
  1621                                                             self.aresp[step] = masked_mean(self.metacomm.mask, aresp)
  1622                                                             self.npp[step] = masked_mean(self.metacomm.mask, npp)
  1623                                                             self.rnpp[step] = masked_mean(self.metacomm.mask, rnpp_mt)
  1624                                                             self.lai[step] = masked_mean(self.metacomm.mask, lai)
  1625                                                             self.rcm[step] = masked_mean(self.metacomm.mask, rcm)
  1626                                                             self.f5[step] = masked_mean(self.metacomm.mask, f5)
  1627                                                             self.rm[step] = masked_mean(self.metacomm.mask, rm)
  1628                                                             self.rg[step] = masked_mean(self.metacomm.mask, rg)
  1629                                                             self.wue[step] = masked_mean(self.metacomm.mask, wue)
  1630                                                             self.cue[step] = masked_mean(self.metacomm.mask, cue)
  1631                                                             self.carbon_deficit[step] = masked_mean(self.metacomm.mask, carbon_deficit)
  1632                                                             self.vcmax[step] = masked_mean(self.metacomm.mask, vcmax)
  1633                                                             self.specific_la[step] = masked_mean(self.metacomm.mask, specific_la)
  1634                                                             self.hresp[step] = soil_out['hr']
  1635                                                             self.csoil[:, step] = soil_out['cs']
  1636                                                             self.wsoil[step] = self.swp.calc_total_water()
  1637                                                             self.inorg_n[step] = self.sp_in_n
  1638                                                             self.inorg_p[step] = self.sp_in_p
  1639                                                             self.sorbed_n[step] = self.sp_so_n
  1640                                                             self.sorbed_p[step] = self.sp_so_p
  1641                                                             self.snc[:, step] = soil_out['snc']
  1642                                                             self.nmin[step] = self.sp_available_n
  1643                                                             self.pmin[step] = self.sp_available_p
  1644                                                             self.ls[step] = living_pls
  1645                                         
  1646                                                     # <- Out of the daily loop
  1647                                                     # Save the spin data
  1648                                                     sv: Thread
  1649    196.7 MiB     -0.1 MiB           2               if save:
  1650                                                         if s > 0:
  1651                                                             sv.join()  # Wait for the previous thread to finish
  1652                                                             self.flush_data = None
  1653                                                         self.executed_iterations.append((start_date, end_date))
  1654                                                         self.flush_data = self._flush_output(
  1655                                                             'spin', (self.start_index, self.end_index))
  1656                                                         sv = Thread(target=self._save_output, args=(self.flush_data,))
  1657                                                         sv.start()
  1658                                                 # <- Out of spin loop
  1659                                                 # Manage the last thread
  1660    196.7 MiB      0.0 MiB           1           if save:
  1661                                                     sv.join()  # Wait for the last thread to finish
  1662                                                     self.flush_data = None
  1663                                         
  1664                                         
  1665                                                 # Restablish new communities in the end, if applicable
  1666    196.7 MiB      0.0 MiB           1           if kill_and_reset:
  1667                                                     assert not save, "Cannot save data when resetting communities"
  1668                                                     for community in self.metacomm:
  1669                                                         # with lock:
  1670                                                         new_life_strategies = self.get_from_main_array(community.npls)
  1671                                                         community.restore_from_main_table(new_life_strategies)
  1672                                                     # Here we update the metacomm mask to ensure that all communities are active again
  1673                                                     self.metacomm.update_mask()
  1674                                         
  1675    196.7 MiB      0.0 MiB           1           return None


Filename: C:\Users\darel\OneDrive\Desktop\CAETE\src\caete.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
  1013    196.8 MiB    196.8 MiB           1       @profile
  1014                                             # @timer
  1015                                             def run_gridcell(self,
  1016                                                           start_date: str,
  1017                                                           end_date: str,
  1018                                                           spinup: int = 0,
  1019                                                           fixed_co2_atm_conc: Optional[str] | Optional[int] | Optional[float] = None,
  1020                                                           save: bool = True,
  1021                                                           nutri_cycle: bool = True,
  1022                                                           afex: bool = False,
  1023                                                           reset_community: bool = False,
  1024                                                           kill_and_reset: bool = False,
  1025                                                           env_filter: bool = False,
  1026                                                           process_limitation: bool = False,
  1027                                                           verbose: bool = False):
  1028                                                 """
  1029                                                 Run the model for a grid cell.
  1030                                         
  1031                                                 CAETÊ-DVM execution in the start_date - end_date period, can be used for spinup or transient runs.
  1032                                         
  1033                                                 Args:
  1034                                                     start_date (str): Start date for model execution in "yyyymmdd" format.
  1035                                                     end_date (str): End date for model execution in "yyyymmdd" format.
  1036                                                     spinup (int, optional): Number of repetitions in spinup. Set to 0 for a transient run between start_date and end_date. Default is 0.
  1037                                                     fixed_co2_atm_conc (Optional[Union[str, int, float]]): Fixed atmospheric CO2 concentration. If None, use dynamic CO2 levels from a predefined file. If a string with a year (e.g., "1987") That year's value in the provided file will be used. Use a float to set a fixed level in ppm. Default is None.
  1038                                                     save (bool, optional): Whether to save the results. Default is True.
  1039                                                     nutri_cycle (bool, optional): Whether to include nutrient cycling in the model. Default is True.
  1040                                                     afex (bool, optional): Whether to apply nutrient addition to soil in the model. Default is False.
  1041                                                     reset_community (bool, optional): Whether to restart a new community if there are not viable PLS. Default is False.
  1042                                                     kill_and_reset (bool, optional): Whether to kill and reset the community structure at the end of execution (only CVEG pools and PLS IDs). Default is False.
  1043                                                     env_filter (bool, optional): Whether to apply environmental filtering (Include new PLS periodically) []. Default is False.
  1044                                                     verbose (bool, optional): Whether to print detailed logs during execution. Default is False.
  1045                                         
  1046                                                 Returns:
  1047                                                     None
  1048                                         
  1049                                                 Notes:
  1050                                                     - If reset_community is true a new community will be set (reset) when there is no PLSs remaining.
  1051                                                     - If the kill_and_reset is true, after n spins (integer given by spinup parameter - i.e. in the end
  1052                                                       of function execution) all the communities in a gridcell are reset. The reset_community and
  1053                                                       kill_and_reset  arguments are not mutually exclusive. You can use both as true at the same time.
  1054                                                     - The env_filter argument is used to define if new unique PLSs from the main table will be
  1055                                                       seed in the communities that have free slots (PLSs that are not producing). At the moment, the
  1056                                                       interval for the env_filter to add a new PLS to the community is set to  ~15 days.
  1057                                                       If env filter argument is true, then the reset_community argument will have a very low
  1058                                                       probability to trigger a reset because the communities will be constantly filled with new PLS.
  1059                                                       Nonetheless, the reset_community argument will still be able to trigger a reset if the community loses all PLSs.
  1060                                                       With the probability of a reset_community increasing as the interval between new seeds increases. The parameter doy_months
  1061                                                       in the config file (caete.toml) is used to define the interval for the env_filter to add a new PLS to the community.
  1062                                         
  1063                                                       TODO: Implement a more flexible way to define the interval for
  1064                                                             the env_filter to add a new PLS to the community.
  1065                                                 """
  1066                                         
  1067    196.8 MiB      0.0 MiB           2           assert not fixed_co2_atm_conc or\
  1068    196.8 MiB      0.0 MiB           1               isinstance(fixed_co2_atm_conc, str) or\
  1069                                                     fixed_co2_atm_conc > 0,\
  1070                                                         "A fixed value for ATM[CO2] must be a positive number greater than zero or a proper string with the year - e.g., 'yyyy'"
  1071                                         
  1072                                         
  1073                                                 # Define start and end dates (read parameters)
  1074    196.8 MiB      0.0 MiB           1           start = parse_date(start_date)
  1075    196.8 MiB      0.0 MiB           1           end = parse_date(end_date)
  1076                                         
  1077                                                 # Check dates
  1078    196.8 MiB      0.0 MiB           1           assert start < end, "Start date must be before end date"
  1079    196.8 MiB      0.0 MiB           1           assert start >= self.start_date, "initial date out of bounds for the time array"
  1080    196.8 MiB      0.0 MiB           1           assert end <= self.end_date, f"Final date out of bounds for the time array"
  1081                                         
  1082                                         
  1083                                                 # Define time index bounds for this run
  1084                                                 # During a run we are in general using a slice ov the available time span
  1085                                                 # to run the model. For example, we can run the model for a year or a decade
  1086                                                 # at the begining of the input data time series to spin up. This slice is defined
  1087                                                 # by the start and end dates provided in the arguments. Here we get the indices.
  1088    196.8 MiB      0.0 MiB           1           self.start_index = int(cftime.date2num(start, self.time_unit, self.calendar))
  1089    196.8 MiB      0.0 MiB           1           self.end_index =   int(cftime.date2num(end, self.time_unit, self.calendar))
  1090                                         
  1091                                                 # Find the indices in the time array [used to slice the timeseries with driver data  - tas, pr, etc.]
  1092    196.8 MiB      0.0 MiB           1           lower_bound, upper_bound = self.find_index(self.start_index, self.end_index)
  1093                                         
  1094                                                 # Define the time steps range (days)
  1095    196.8 MiB      0.0 MiB           1           steps = np.arange(lower_bound, upper_bound + 1, dtype=np.int64)
  1096                                         
  1097                                                 # Define the number of repetitions for the spinup
  1098    196.8 MiB      0.0 MiB           1           spin = 1 if spinup == 0 else spinup
  1099                                         
  1100                                                 # Define the AFEX mode
  1101    196.8 MiB      0.0 MiB           1           afex_mode = self.afex_config.afex_mode # type: ignore
  1102                                         
  1103                                                 # Slice&Catch climatic input and make conversions
  1104    196.8 MiB      0.0 MiB           1           cv = self.config.conversion_factors_isimip # type: ignore
  1105                                         
  1106                                         
  1107    196.8 MiB      0.0 MiB           1           if self.config.input_handler.input_method == "ih" and self.config.input_handler.input_type == "netcdf":
  1108                                                     # Variables in Netcdf files are already in proprer units
  1109    196.8 MiB      0.0 MiB           1               temp: NDArray[np.float32] = self.tas[lower_bound: upper_bound + 1]   # Air temp: model uses °C
  1110    196.8 MiB      0.0 MiB           1               prec: NDArray[np.float32] = self.pr[lower_bound: upper_bound + 1]    # Precipitation: model uses  mm/day
  1111    196.8 MiB      0.0 MiB           1               p_atm: NDArray[np.float32] = self.ps[lower_bound: upper_bound + 1]   # Atmospheric pressure: model uses hPa
  1112    196.8 MiB      0.0 MiB           1               ipar: NDArray[np.float32] = self.rsds[lower_bound: upper_bound + 1]  # PAR: model uses  mol(photons) m-2 s-1
  1113    196.8 MiB      0.0 MiB           1               ru: NDArray[np.float32] = self.rhs[lower_bound: upper_bound + 1]     # Relative humidity: model uses 0-1
  1114                                                 else:
  1115                                                     temp: NDArray[np.float32] = self.tas[lower_bound: upper_bound + 1] - cv.tas    # Air temp: model uses °C
  1116                                                     prec: NDArray[np.float32] = self.pr[lower_bound: upper_bound + 1] * cv.pr      # Precipitation: model uses  mm/day
  1117                                                     p_atm: NDArray[np.float32] = self.ps[lower_bound: upper_bound + 1] * cv.ps     # Atmospheric pressure: model uses hPa
  1118                                                     ipar: NDArray[np.float32] = self.rsds[lower_bound: upper_bound + 1] * cv.rsds  # PAR: model uses  mol(photons) m-2 s-1
  1119                                                     ru: NDArray[np.float32] = self.rhs[lower_bound: upper_bound + 1] * cv.rhs      # Relative humidity: model uses 0-1
  1120                                         
  1121                                                 # Define the daily values for co2 concentrations
  1122    196.8 MiB      0.0 MiB           1           co2_daily_values = np.zeros(steps.size, dtype=np.float32)
  1123                                         
  1124    196.8 MiB      0.0 MiB           1           if fixed_co2_atm_conc is None:
  1125                                                     # In this case, the co2 concentration will be updated daily.
  1126                                                     # We interpolate linearly between the yearly values of the atm co2 data
  1127                                                     co2 = self.find_co2(start.year)
  1128                                                     today = datetime(start.year, start.month, start.day, start.hour, start.minute, start.second)
  1129                                                     time_step = timedelta(days=1) # Define the time step
  1130                                                     today -= time_step # The first thing we do next is to add a day to the date. So we go back one day
  1131                                                     # Loop over the days and calculate the co2 concentration for each day
  1132                                                     for step in range(steps.size):
  1133                                                         today += time_step
  1134                                                         remaining = (datetime(today.year, 12, 31) - today).days + 1
  1135                                                         daily_fraction = (self.find_co2(today.year + 1) - co2) / (remaining + 1)
  1136                                                         co2 += daily_fraction
  1137                                                         co2_daily_values[step] = co2
  1138    196.8 MiB      0.0 MiB           1           elif isinstance(fixed_co2_atm_conc, int) or isinstance(fixed_co2_atm_conc, float):
  1139                                                     # In this case, the co2 concentration will be fixed according to the numeric value provided in the argument
  1140                                                     co2 = fixed_co2_atm_conc
  1141                                                     co2_daily_values += co2
  1142    196.8 MiB      0.0 MiB           1           elif isinstance(fixed_co2_atm_conc, str):
  1143                                                     # In this case, the co2 concentration will be fixed
  1144                                                     # According to the year provided in the argument
  1145                                                     # as a string. Format "yyyy".
  1146    196.8 MiB      0.0 MiB           1               try:
  1147    196.8 MiB      0.0 MiB           1                   co2_year = int(fixed_co2_atm_conc)
  1148                                                     except ValueError:
  1149                                                         raise ValueError(
  1150                                                             "The string(\"yyyy\") must be a number in the {self.start_date.year} - {self.end_date.year} interval")
  1151    196.8 MiB      0.0 MiB           1               co2 = self.find_co2(co2_year)
  1152    196.8 MiB      0.0 MiB           1               co2_daily_values += co2
  1153                                                 else:
  1154                                                     raise ValueError("Invalid value for fixed_co2_atm_conc")
  1155                                         
  1156                                                 # Define variables to track dates
  1157    196.8 MiB      0.0 MiB           1           first_day_of_simulation = datetime(start.year, start.month, start.day, start.hour, start.minute, start.second)
  1158                                                 # Define the time step
  1159    196.8 MiB      0.0 MiB           1           time_step = timedelta(days=1)
  1160                                         
  1161                                                 # Define the object to store the outputs from daily_budget
  1162    196.8 MiB      0.0 MiB           1           daily_output = DailyBudget()
  1163                                         
  1164                                                 # Start loops
  1165                                                 # This outer loop is used to run the model for a number
  1166                                                 # of times defined by the spinup argument. The model is
  1167                                                 # executed repeatedly between the start and end dates
  1168                                                 # provided in the arguments
  1169                                         
  1170    197.7 MiB      0.0 MiB           2           for s in range(spin):
  1171                                         
  1172    197.7 MiB      0.8 MiB           1               self._allocate_output(steps.size, self.metacomm.comm_npls, len(self.metacomm), save)
  1173                                         
  1174                                                     # Loop over the days
  1175    197.7 MiB      0.0 MiB           1               today = first_day_of_simulation
  1176                                         
  1177                                                     # Go back one day
  1178    197.7 MiB      0.0 MiB           1               today -= time_step
  1179                                         
  1180                                                     # Arrays to store & pass values for each community in a simulated day
  1181    197.7 MiB      0.0 MiB           1               sto =        np.zeros(shape=(3, self.metacomm.comm_npls), order='F')
  1182    197.7 MiB      0.0 MiB           1               cleaf_in =   np.zeros(self.metacomm.comm_npls, order='F')
  1183    197.7 MiB      0.0 MiB           1               cwood_in =   np.zeros(self.metacomm.comm_npls, order='F')
  1184    197.7 MiB      0.0 MiB           1               croot_in =   np.zeros(self.metacomm.comm_npls, order='F')
  1185    197.7 MiB      0.0 MiB           1               uptk_costs = np.zeros(self.metacomm.comm_npls, order='F')
  1186    197.7 MiB      0.0 MiB           1               rnpp_in =    np.zeros(self.metacomm.comm_npls, order='F')
  1187                                         
  1188                                                     # There are two modes of operation: save and not save.
  1189                                                     # In the save == False mode, the arrays are used to store the values that are
  1190                                                     # needed for model iteration, i.e., the values that are used in the next
  1191                                                     # time step. In the save mode, an extra number arrays is created to be used
  1192                                                     # to store the outputs.
  1193    197.7 MiB      0.0 MiB           1               xsize: int = len(self.metacomm) # Number of communities
  1194    197.7 MiB      0.0 MiB           1               evavg: NDArray[np.float32] = np.zeros(xsize, dtype=np.float32)
  1195    197.7 MiB      0.0 MiB           1               epavg: NDArray[np.float32] = np.zeros(xsize, dtype=np.float32)
  1196    197.7 MiB      0.0 MiB           1               rnpp_mt: NDArray[np.float32] = np.zeros(xsize, dtype=np.float32)
  1197                                         
  1198                                                     # We keep track of these to input in SOM dynamics later. They are used for output also
  1199    197.7 MiB      0.0 MiB           1               leaf_litter: NDArray[np.float32] = np.zeros(xsize, dtype=np.float32)
  1200    197.7 MiB      0.0 MiB           1               cwd: NDArray[np.float32] = np.zeros(xsize, dtype=np.float32)
  1201    197.7 MiB      0.0 MiB           1               root_litter: NDArray[np.float32] = np.zeros(xsize, dtype=np.float32)
  1202    197.7 MiB      0.0 MiB           1               lnc: NDArray[np.float32] = np.zeros(shape=(6, xsize), dtype=np.float32)
  1203                                                     # This is added to leaf litter pool (that is basicaly a fast SOM pool)
  1204    197.7 MiB      0.0 MiB           1               c_to_nfixers: NDArray[np.float32]= np.zeros(xsize, dtype=np.float32)
  1205    197.7 MiB      0.0 MiB           1               nupt = np.zeros(shape=(2, xsize), dtype=np.float32)
  1206    197.7 MiB      0.0 MiB           1               pupt = np.zeros(shape=(3, xsize), dtype=np.float32)
  1207                                         
  1208    197.7 MiB      0.0 MiB           1               if save:
  1209                                                         cc = np.zeros(xsize, dtype=np.float32)
  1210                                                         photo = np.zeros(xsize, dtype=np.float32)
  1211                                                         aresp = np.zeros(xsize, dtype=np.float32)
  1212                                                         npp = np.zeros(xsize, dtype=np.float32)
  1213                                                         lai = np.zeros(xsize, dtype=np.float32)
  1214                                                         rcm = np.zeros(xsize, dtype=np.float32)
  1215                                                         f5 = np.zeros(xsize, dtype=np.float32)
  1216                                                         rm = np.zeros(xsize, dtype=np.float32)
  1217                                                         rg = np.zeros(xsize, dtype=np.float32)
  1218                                                         wue = np.zeros(xsize, dtype=np.float32)
  1219                                                         cue = np.zeros(xsize, dtype=np.float32)
  1220                                                         carbon_deficit = np.zeros(xsize, dtype=np.float32)
  1221                                                         vcmax = np.zeros(xsize, dtype=np.float32)
  1222                                                         specific_la = np.zeros(xsize, dtype=np.float32)
  1223                                                         storage_pool = np.zeros(shape=(3, xsize))
  1224                                         
  1225                                                         if process_limitation:
  1226                                                             lim_status_y_leaf = np.ma.masked_all((xsize, self.metacomm.comm_npls, 366), dtype=np.int8)
  1227                                                             lim_status_y_stem = np.ma.masked_all((xsize, self.metacomm.comm_npls, 366), dtype=np.int8)
  1228                                                             lim_status_y_root = np.ma.masked_all((xsize, self.metacomm.comm_npls, 366), dtype=np.int8)
  1229                                                             uptake_strategy_n = np.ma.masked_all((xsize, self.metacomm.comm_npls, 366), dtype=np.int8)
  1230                                                             uptake_strategy_p = np.ma.masked_all((xsize, self.metacomm.comm_npls, 366), dtype=np.int8)
  1231                                         
  1232                                                     # <- Daily loop
  1233    197.7 MiB      0.0 MiB       18263               for step in range(steps.size):
  1234    197.7 MiB      0.0 MiB       18262                   today += time_step
  1235    197.7 MiB      0.0 MiB       18262                   julian_day = today.timetuple().tm_yday
  1236                                         
  1237                                                         # Get the co2 concentration for the day
  1238    197.7 MiB      0.0 MiB       18262                   co2 = co2_daily_values[step]
  1239                                                         # Update soil temperature
  1240    197.7 MiB      0.0 MiB       18262                   self.soil_temp = st.soil_temp(self.soil_temp, temp[step])
  1241                                         
  1242                                                         # AFEX
  1243    197.7 MiB      0.0 MiB       18262                   if afex and julian_day == 365:
  1244                                                             self.add_soil_nutrients(afex_mode)
  1245                                         
  1246                                                         # Loop over communities
  1247    197.7 MiB      0.0 MiB       18262                   living_pls = 0 # Sum of living PLS in the communities
  1248    197.7 MiB      0.0 MiB       36524                   for i, community in enumerate(self.metacomm):
  1249                                                             # if i >= len(self.metacomm):
  1250                                                             #     break
  1251                                                             # if community.masked:
  1252                                                             #     # skip this one
  1253                                                             #     continue
  1254    197.7 MiB      0.0 MiB       18262                       sto[0, :] = inflate_array(community.npls, community.vp_sto[0, :], community.vp_lsid)
  1255    197.7 MiB      0.0 MiB       18262                       sto[1, :] = inflate_array(community.npls, community.vp_sto[1, :], community.vp_lsid)
  1256    197.7 MiB      0.0 MiB       18262                       sto[2, :] = inflate_array(community.npls, community.vp_sto[2, :], community.vp_lsid)
  1257                                         
  1258    197.7 MiB      0.0 MiB       18262                       cleaf_in[:] = inflate_array(community.npls, community.vp_cleaf, community.vp_lsid)
  1259    197.7 MiB      0.0 MiB       18262                       cwood_in[:] = inflate_array(community.npls, community.vp_cwood, community.vp_lsid)
  1260    197.7 MiB      0.0 MiB       18262                       croot_in[:] = inflate_array(community.npls, community.vp_croot, community.vp_lsid)
  1261    197.7 MiB      0.0 MiB       18262                       uptk_costs[:] = inflate_array(community.npls, community.sp_uptk_costs, community.vp_lsid)
  1262    197.7 MiB      0.0 MiB       18262                       rnpp_in[:] = inflate_array(community.npls, community.construction_npp, community.vp_lsid)
  1263                                         
  1264    197.7 MiB      0.0 MiB       18262                       ton = self.sp_organic_n #+ self.sp_sorganic_n
  1265    197.7 MiB      0.0 MiB       18262                       top = self.sp_organic_p #+ self.sp_sorganic_p
  1266                                         
  1267                                                             # Community daily budget calculation
  1268    197.7 MiB      0.0 MiB       36524                       out = model.daily_budget(community.pls_array, self.wp_water_upper_mm,
  1269    197.7 MiB      0.0 MiB       18262                                               self.wp_water_lower_mm, self.soil_temp, temp[step],
  1270    197.7 MiB      0.0 MiB       18262                                               p_atm[step], ipar[step], ru[step], self.sp_available_n,
  1271    197.7 MiB      0.0 MiB       18262                                               self.sp_available_p, ton, top, self.sp_organic_p,
  1272    197.7 MiB      0.0 MiB       18262                                               co2, sto, cleaf_in, cwood_in, croot_in, uptk_costs,self.wmax_mm,
  1273    197.7 MiB      0.0 MiB       18262                                               rnpp_in)
  1274                                         
  1275                                                             # get daily budget results
  1276    197.7 MiB      0.0 MiB       18262                       daily_output.update(out)
  1277                                         
  1278                                                             # Update the community status
  1279    197.7 MiB      0.0 MiB       18262                       community.update_lsid(daily_output.ocpavg)
  1280                                         
  1281                                                             # Abort community if no PLSs are left while saving the spin
  1282    197.7 MiB      0.0 MiB       18262                       if community.masked and save:
  1283                                                                 continue
  1284                                         
  1285    197.7 MiB      0.0 MiB       18262                       community.ls = community.vp_lsid.size
  1286                                                             # # Restore or seed PLS
  1287    197.7 MiB      0.0 MiB       18262                       if env_filter and (community.ls < self.metacomm.comm_npls) and not save:
  1288                                                                 if julian_day in self.doy_months:
  1289                                                                     new_id, new_PLS = community.get_unique_pls(self.get_from_main_array)
  1290                                                                     community.seed_pls(new_id, new_PLS, daily_output.cleafavg_pft,
  1291                                                                                        daily_output.cfrootavg_pft, daily_output.cawoodavg_pft)
  1292                                                                     if verbose: print(f"PLS seed in Community {i}: Gridcell: {self.lat} °N, {self.lon} °E: In spin:{s}, step:{step}")
  1293                                         
  1294                                                                     daily_output.ocpavg = pft_area_frac64(daily_output.cleafavg_pft,
  1295                                                                                                     daily_output.cfrootavg_pft,
  1296                                                                                                     daily_output.cawoodavg_pft)
  1297                                                                     community.update_lsid(daily_output.ocpavg)
  1298                                                                     community.ls = community.vp_lsid.size
  1299                                                                 # endif
  1300                                         
  1301                                         
  1302    197.7 MiB      0.0 MiB       18262                       community.vp_ocp = daily_output.ocpavg[community.vp_lsid]
  1303    197.7 MiB      0.0 MiB       18262                       community.vp_cleaf = daily_output.cleafavg_pft[community.vp_lsid]
  1304    197.7 MiB      0.0 MiB       18262                       community.vp_cwood = daily_output.cawoodavg_pft[community.vp_lsid]
  1305    197.7 MiB      0.0 MiB       18262                       community.vp_croot = daily_output.cfrootavg_pft[community.vp_lsid]
  1306    197.7 MiB      0.0 MiB       18262                       community.vp_sto = daily_output.stodbg[:, community.vp_lsid].astype('float32')
  1307    197.7 MiB      0.0 MiB       18262                       community.sp_uptk_costs = daily_output.npp2pay[community.vp_lsid]
  1308    197.7 MiB      0.0 MiB       18262                       community.construction_npp = daily_output.rnpp_out[community.vp_lsid]
  1309    197.7 MiB      0.0 MiB       18262                       living_pls += community.ls
  1310                                                             # print(f"Community storage: {community.vp_sto[0, :]}")
  1311                                                             # print(f"Sto_budget_out {daily_output.stodbg[0, :]}")
  1312                                         
  1313                                                             # Limiting nutrient organization:
  1314                                                             # dim1 = leaf wood root, code: 1=N 2=P 4=N,COLIM 5=P,COLIM 6=COLIM 0=NOLIM
  1315    197.7 MiB      0.0 MiB       18262                       if save:
  1316                                                                 if process_limitation:
  1317                                                                     lim_status_y_leaf[i, :, julian_day - 1] = daily_output.limitation_status[0,:]# type: ignore
  1318                                                                     lim_status_y_stem[i, :, julian_day - 1] = daily_output.limitation_status[1,:]# type: ignore
  1319                                                                     lim_status_y_root[i, :, julian_day - 1] = daily_output.limitation_status[2,:]# type: ignore
  1320                                                                     uptake_strategy_n[i, :, julian_day - 1] = daily_output.uptk_strat[0,:]# type: ignore
  1321                                                                     uptake_strategy_p[i, :, julian_day - 1] = daily_output.uptk_strat[1,:]# type: ignore
  1322                                         
  1323                                                                 community.anpp += cw_mean(community.vp_ocp, community.construction_npp.astype(np.float32))
  1324                                                                 community.uptake_costs += cw_mean(community.vp_ocp, community.sp_uptk_costs.astype(np.float32))
  1325                                         
  1326    197.7 MiB      0.0 MiB       18262                       if save and julian_day == 365:
  1327                                                                 community.cleaf = cw_mean(community.vp_ocp, community.vp_cleaf.astype(np.float32))
  1328                                                                 community.cwood = cw_mean(community.vp_ocp, community.vp_cwood.astype(np.float32))
  1329                                                                 community.croot = cw_mean(community.vp_ocp, community.vp_croot.astype(np.float32))
  1330                                                                 community.csto = cw_mean(community.vp_ocp, community.vp_sto[0, :])
  1331                                                                 community.shannon_diversity = shannon_diversity(community.vp_ocp)
  1332                                                                 community.shannon_entropy = shannon_entropy(community.vp_ocp)
  1333                                                                 community.shannon_evenness = shannon_evenness(community.vp_ocp)
  1334                                         
  1335                                                                 # process limitation data
  1336                                                                 # Filter non living PLS from the limitation status
  1337                                                                 if process_limitation:
  1338                                                                     _data_leaf = lim_status_y_leaf[i, [community.vp_lsid], :] # type: ignore
  1339                                                                     _data_stem = lim_status_y_stem[i, [community.vp_lsid], :] # type: ignore
  1340                                                                     _data_root = lim_status_y_root[i, [community.vp_lsid], :] # type: ignore
  1341                                         
  1342                                                                     _data_uptake_n = uptake_strategy_n[i, [community.vp_lsid], :]# type: ignore
  1343                                                                     _data_uptake_p = uptake_strategy_p[i, [community.vp_lsid], :]# type: ignore
  1344                                         
  1345                                                                     # Loop over the living PLS to get the unique values and counts
  1346                                                                     pls_lim_leaf = []
  1347                                                                     pls_lim_stem = []
  1348                                                                     pls_lim_root = []
  1349                                                                     pls_uptake_n = []
  1350                                                                     pls_uptake_p = []
  1351                                         
  1352                                                                     for k in range(community.vp_lsid.size):
  1353                                                                         # Get the unique values and counts for leaf limitation
  1354                                                                         unique, counts = np.unique(_data_leaf[0, k, :], return_counts=True)
  1355                                                                         unique = unique.data[unique.mask == False] # type: ignore
  1356                                                                         pls_lim_leaf.append((unique, counts[:unique.size])) # type: ignore
  1357                                         
  1358                                                                         # Stem limitation
  1359                                                                         unique, counts = np.unique(_data_stem[0, k, :], return_counts=True)
  1360                                                                         unique = unique.data[unique.mask == False] # type: ignore
  1361                                                                         pls_lim_stem.append((unique, counts[:unique.size])) # type: ignore
  1362                                         
  1363                                                                         # Root limitation
  1364                                                                         unique, counts = np.unique(_data_root[0, k, :], return_counts=True)
  1365                                                                         unique = unique.data[unique.mask == False]
  1366                                                                         pls_lim_root.append((unique, counts[:unique.size])) # type: ignore
  1367                                         
  1368                                                                         # Uptake strategy N
  1369                                                                         unique, counts = np.unique(_data_uptake_n[0, k, :], return_counts=True)
  1370                                                                         unique = unique.data[unique.mask == False] # type: ignore
  1371                                                                         pls_uptake_n.append((unique, counts[:unique.size])) # type: ignore
  1372                                         
  1373                                                                         # Uptake strategy P
  1374                                                                         unique, counts = np.unique(_data_uptake_p[0, k, :], return_counts=True)
  1375                                                                         unique = unique.data[unique.mask == False]  # type: ignore
  1376                                                                         pls_uptake_p.append((unique, counts[:unique.size])) # type: ignore
  1377                                         
  1378                                                                     community.limitation_status_leaf = pls_lim_leaf
  1379                                                                     community.limitation_status_wood = pls_lim_stem
  1380                                                                     community.limitation_status_root = pls_lim_root
  1381                                                                     community.uptake_strategy_n = pls_uptake_n
  1382                                                                     community.uptake_strategy_p = pls_uptake_p
  1383                                         
  1384                                                                     # Reset the limitation masked arrays
  1385                                                                     lim_status_y_leaf.mask[i, :, :] = np.ones((self.metacomm.comm_npls, 366), dtype=bool) # type: ignore
  1386                                                                     lim_status_y_stem.mask[i, :, :] = np.ones((self.metacomm.comm_npls, 366), dtype=bool) # type: ignore
  1387                                                                     lim_status_y_root.mask[i, :, :] = np.ones((self.metacomm.comm_npls, 366), dtype=bool) # type: ignore
  1388                                                                     uptake_strategy_n.mask[i, :, :] = np.ones((self.metacomm.comm_npls, 366), dtype=bool) # type: ignore
  1389                                                                     uptake_strategy_p.mask[i, :, :] = np.ones((self.metacomm.comm_npls, 366), dtype=bool) # type: ignore
  1390                                                                 else:
  1391                                                                     pass
  1392                                         
  1393    197.7 MiB      0.0 MiB       18262                       if community.vp_lsid.size < 1:
  1394                                                                 if verbose: print(f"Empty community {i}: Gridcell: {self.lat} °N, {self.lon} °E: In spin:{s}, step:{step}")
  1395                                                                 if reset_community:
  1396                                                                     assert not save, "Cannot save data when resetting communities"
  1397                                                                     if verbose: print(f"Reseting community {i}: Gridcell: {self.lat} °N, {self.lon} °E: In spin:{s}, step:{step}")
  1398                                         
  1399                                                                     new_life_strategies = self.get_from_main_array(community.npls)
  1400                                                                     community.restore_from_main_table(new_life_strategies)
  1401                                                                     # continue
  1402                                         
  1403                                                                 else:
  1404                                                                     # In the transiant run - i.e., when reset_community is false and
  1405                                                                     # kill_and_reset is false; we mask the community if there is no PLS
  1406                                                                     self.metacomm.mask[i] = np.int8(1)
  1407                                                                     # Set mask to true for this community, will not run in the next steps
  1408                                                                     # Set annual values to zero
  1409                                                                     community.masked = np.int8(1)
  1410                                                                     community.cleaf = np.float32(0.0)
  1411                                                                     community.cwood = np.float32(0.0)
  1412                                                                     community.croot = np.float32(0.0)
  1413                                                                     community.csto  = np.float32(0.0)
  1414                                                                     community.shannon_diversity = -9999.0
  1415                                                                     community.shannon_entropy = -9999.0
  1416                                                                     community.shannon_evenness = -9999.0
  1417                                                                     # if the reset_community is true
  1418                                                                     # continue # cycle
  1419                                         
  1420                                                             # Store values for each community
  1421    197.7 MiB      0.0 MiB       18262                       rnpp_mt[i] = cw_mean(community.vp_ocp, community.construction_npp.astype(np.float32)) # Community Weighted rNPP
  1422    197.7 MiB      0.0 MiB       18262                       leaf_litter[i] = daily_output.litter_l
  1423    197.7 MiB      0.0 MiB       18262                       root_litter[i] = daily_output.litter_fr
  1424    197.7 MiB      0.0 MiB       18262                       cwd[i] = daily_output.cwd
  1425    197.7 MiB      0.0 MiB       18262                       lnc[:, i] = daily_output.lnc.astype(np.float32)
  1426    197.7 MiB      0.0 MiB       18262                       c_to_nfixers[i] = daily_output.cp[3]
  1427    197.7 MiB      0.0 MiB       18262                       evavg[i] = daily_output.evavg
  1428    197.7 MiB      0.0 MiB       18262                       epavg[i] = daily_output.epavg
  1429    197.7 MiB      0.0 MiB       18262                       nupt[:, i] = daily_output.nupt #type: ignore
  1430    197.7 MiB      0.0 MiB       18262                       pupt[:, i] = daily_output.pupt #type: ignore
  1431                                         
  1432    197.7 MiB      0.0 MiB       18262                       if save:
  1433                                                                 cc[i] = daily_output.c_cost_cwm #type: ignore
  1434                                                                 npp[i] = daily_output.nppavg #type: ignore
  1435                                                                 photo[i] = daily_output.phavg #type: ignore
  1436                                                                 aresp[i] = daily_output.aravg #type: ignore
  1437                                                                 lai[i] = daily_output.laiavg #type: ignore
  1438                                                                 rcm[i] = daily_output.rcavg #type: ignore
  1439                                                                 f5[i] = daily_output.f5avg #type: ignore
  1440                                                                 rm[i] = daily_output.rmavg #type: ignore
  1441                                                                 rg[i] = daily_output.rgavg #type: ignore
  1442                                                                 wue[i] = daily_output.wueavg #type: ignore
  1443                                                                 cue[i] = daily_output.cueavg #type: ignore
  1444                                                                 carbon_deficit[i] = daily_output.c_defavg #type: ignore
  1445                                                                 vcmax[i] = daily_output.vcmax #type: ignore
  1446                                                                 specific_la[i] = daily_output.specific_la #type: ignore
  1447                                         
  1448                                                                 for j in range(daily_output.stodbg.shape[0]):
  1449                                                                     storage_pool[j, i] = cw_mean(community.vp_ocp, community.vp_sto[j, :]) #type: ignore
  1450                                         
  1451                                                         #<- Out of the community loop
  1452                                                         # Save annual state of the metacommunity
  1453    197.7 MiB      0.0 MiB       18262                   if save:
  1454                                                             if julian_day == 365:
  1455                                                                 y = today.year
  1456                                                                 # m = today.month
  1457                                                                 # d = today.day
  1458                                                                 filename = self.out_dir/f"metacommunity_{y}.pkz"
  1459                                                                 # filename = self.out_dir/f"metacommunity_{d}{m}{y}.pkz"
  1460                                                                 self.metacomm.save_state(filename, y, process_limitation)
  1461                                                                 self.metacomm_output[y] = filename
  1462                                         
  1463                                                                 for community in self.metacomm:
  1464                                                                     # Set annual accumulators to zero
  1465                                                                     community.anpp = np.float32(0.0)
  1466                                                                     community.uptake_costs = np.float32(0.0)
  1467                                         
  1468                                                         # ------------
  1469                                                         # Evapotranspiration
  1470    197.7 MiB      0.0 MiB       18262                   et = masked_mean(self.metacomm.mask, evavg) #evavg.mean()
  1471                                                         ## Canopy-atmosphere coupling [EXPERIMENTAL]
  1472                                                         # vpd = m.vapor_p_deficit(temp[step], ru[step])
  1473                                                         # et_pot = masked_mean(self.metacomm.mask, np.array(epavg).astype(np.float32)) #epavg.mean()
  1474                                                         # self.evapm[step] = atm_canopy_coupling(et_pot, et, temp[step], vpd)
  1475    197.7 MiB      0.0 MiB       18262                   self.evapm[step] = et
  1476                                         
  1477                                                         # Update water pools
  1478                                         
  1479    197.7 MiB      0.0 MiB       18262                   self.runom[step] = self.swp._update_pool(prec[step], self.evapm[step])
  1480    197.7 MiB      0.0 MiB       18262                   self.swp.w1 = 0.0 if self.swp.w1 < 0.0 else self.swp.w1
  1481    197.7 MiB      0.0 MiB       18262                   self.swp.w2 = 0.0 if self.swp.w2 < 0.0 else self.swp.w2
  1482    197.7 MiB      0.0 MiB       18262                   self.wp_water_upper_mm = self.swp.awc1
  1483    197.7 MiB      0.0 MiB       18262                   self.wp_water_lower_mm = self.swp.awc2
  1484    197.7 MiB      0.0 MiB       18262                   wtot = self.swp.w1 + self.swp.w2
  1485                                         
  1486                                                         # Update cflux to the soil for output, mean values over the communities
  1487                                                         # Values are also used to update SOM dynamics
  1488    197.7 MiB      0.0 MiB       36524                   self.litter_l[step] = masked_mean(self.metacomm.mask, leaf_litter) +\
  1489    197.7 MiB      0.0 MiB       18262                                         masked_mean(self.metacomm.mask, c_to_nfixers)
  1490    197.7 MiB      0.0 MiB       18262                   self.cwd[step] = masked_mean(self.metacomm.mask, cwd)
  1491    197.7 MiB      0.0 MiB       18262                   self.litter_fr[step] = masked_mean(self.metacomm.mask, root_litter)
  1492    197.7 MiB      0.0 MiB       18262                   self.lnc[:, step] = masked_mean_2D(self.metacomm.mask, lnc)
  1493                                         
  1494                                                         # Soil C:N:P balance and OM decomposition
  1495    197.7 MiB      0.0 MiB       36524                   s_out = soil_dec.carbon3(self.soil_temp, wtot / self.wmax_mm, self.litter_l[step],
  1496    197.7 MiB      0.0 MiB       18262                                            self.cwd[step], self.litter_fr[step], self.lnc[:, step],
  1497    197.7 MiB      0.0 MiB       18262                                            self.sp_csoil, self.sp_snc)
  1498    197.7 MiB      0.0 MiB       18262                   soil_out = catch_out_carbon3(s_out)
  1499                                         
  1500                                                         # Organic C N & P
  1501    197.7 MiB      0.0 MiB       18262                   self.sp_csoil = soil_out['cs']
  1502    197.7 MiB      0.0 MiB       18262                   self.sp_snc = np.zeros(shape=8)
  1503    197.7 MiB      0.0 MiB       18262                   self.sp_snc = soil_out['snc']
  1504    197.7 MiB      0.0 MiB       18262                   idx = np.where(self.sp_snc < 0.0)[0]
  1505    197.7 MiB      0.0 MiB       18262                   if len(idx) > 0:
  1506                                                             self.sp_snc[idx] = 0.0
  1507                                         
  1508                                                         # <- Out of the community loop
  1509    197.7 MiB      0.0 MiB       18262                   self.nupt[:, step] = masked_mean_2D(self.metacomm.mask, nupt)
  1510    197.7 MiB      0.0 MiB       18262                   self.pupt[:, step] = masked_mean_2D(self.metacomm.mask, pupt)
  1511                                         
  1512                                                         # TODO: Soil nutrient dynamics. Isolate this if branch into a separate method/class/function
  1513                                                         # Critical part of soil nutrient dynamics and availability for plants
  1514                                                         # IF NUTRICYCLE
  1515    197.7 MiB      0.0 MiB       18262                   if nutri_cycle:
  1516                                                             # UPDATE ORGANIC POOLS
  1517    197.7 MiB      0.0 MiB       18262                       self.sp_organic_n = self.sp_snc[:2].sum()
  1518    197.7 MiB      0.0 MiB       18262                       self.sp_sorganic_n = self.sp_snc[2:4].sum()
  1519    197.7 MiB      0.0 MiB       18262                       self.sp_organic_p = self.sp_snc[4:6].sum()
  1520    197.7 MiB      0.0 MiB       18262                       self.sp_sorganic_p = self.sp_snc[6:].sum()
  1521                                         
  1522                                                             # Update inorganic pools
  1523    197.7 MiB      0.0 MiB       18262                       self.sp_available_p += soil_out['pmin']
  1524    197.7 MiB      0.0 MiB       18262                       self.sp_available_n += soil_out['nmin']
  1525    197.7 MiB      0.0 MiB       18262                       self.sp_available_p -= self.pupt[0, step]
  1526    197.7 MiB      0.0 MiB       18262                       self.sp_available_n -= self.nupt[0, step]
  1527                                         
  1528                                                             # NUTRIENT DINAMICS
  1529                                         
  1530                                                             # Inorganic N
  1531                                                             # TODO: NaNs are being sourced upstream , need to track the source and fix it
  1532                                         
  1533    197.7 MiB      0.0 MiB       18262                       if not np.isfinite(self.sp_in_n):
  1534                                                                 # rwarn(f"Non-finite value detected in sp_in_n pool at step {step}. Resetting to zero.")
  1535                                                                 self.sp_in_n = 0.0
  1536    197.7 MiB      0.0 MiB       18262                       if not np.isfinite(self.sp_available_n):
  1537                                                                 # rwarn(f"Non-finite value detected in sp_available_n pool at step {step}. Resetting to zero.")
  1538                                                                 self.sp_available_n = 0.0
  1539    197.7 MiB      0.0 MiB       18262                       if not np.isfinite(self.sp_so_n):
  1540                                                                 # rwarn(f"Non-finite value detected in sp_so_n pool at step {step}. Resetting to zero.")
  1541                                                                 self.sp_so_n = 0.0
  1542                                         
  1543    197.7 MiB      0.0 MiB       18262                       self.sp_in_n += self.sp_available_n + self.sp_so_n
  1544    197.7 MiB      0.0 MiB       18262                       self.sp_so_n = soil_dec.sorbed_n_equil(self.sp_in_n)
  1545    197.7 MiB      0.0 MiB       18262                       self.sp_available_n = soil_dec.solution_n_equil(self.sp_in_n)
  1546    197.7 MiB      0.0 MiB       18262                       self.sp_in_n -= (self.sp_so_n + self.sp_available_n)
  1547                                         
  1548                                                             # Inorganic P
  1549    197.7 MiB      0.0 MiB       18262                       if not np.isfinite(self.sp_in_p):
  1550                                                                 # rwarn(f"Non-finite value detected in sp_in_p pool at step {step}. Resetting to zero.")
  1551                                                                 self.sp_in_p = 0.0
  1552    197.7 MiB   -141.8 MiB       18262                       if not np.isfinite(self.sp_available_p):
  1553                                                                 # rwarn(f"Non-finite value detected in sp_available_p pool at step {step}. Resetting to zero.")
  1554                                                                 self.sp_available_p = 0.0
  1555    197.7 MiB   -141.8 MiB       18262                       if not np.isfinite(self.sp_so_p):
  1556                                                                 # rwarn(f"Non-finite value detected in sp_so_p pool at step {step}. Resetting to zero.")
  1557                                                                 self.sp_so_p = 0.0
  1558                                         
  1559    197.7 MiB      0.0 MiB       18262                       self.sp_in_p += self.sp_available_p + self.sp_so_p
  1560                                                             # sp_so_p is the occluded P in the inorganic pool
  1561    197.7 MiB      0.0 MiB       18262                       self.sp_so_p = soil_dec.sorbed_p_equil(self.sp_in_p)
  1562                                                             # THe fraction that can be dissolved in soil solution (passive uptake uses transpiration
  1563                                                             # to estimate the amount of P that can be taken up from the soil solution pool)
  1564    197.7 MiB      0.0 MiB       18262                       self.sp_available_p = soil_dec.solution_p_equil(self.sp_in_p)
  1565                                                             # Inorganic pool that is adsorbed
  1566    197.7 MiB      0.0 MiB       18262                       self.sp_in_p -= (self.sp_so_p + self.sp_available_p)
  1567                                         
  1568    197.7 MiB      0.0 MiB       18262                       self.sp_so_p -= self.pupt[1, step]
  1569                                         
  1570    197.7 MiB      0.0 MiB       18262                       try:
  1571    197.7 MiB      0.0 MiB       18262                           t1 = np.all(self.sp_snc > 0.0)
  1572                                                             except:
  1573                                                                 if self.sp_snc is None:
  1574                                                                     self.sp_snc = np.zeros(shape=8,)
  1575                                                                     t1 = True
  1576                                                                 elif self.sp_snc is not None:
  1577                                                                     t1 = True
  1578                                                                 rwarn(f"Exception while handling sp_snc pool")
  1579    197.7 MiB      0.0 MiB       18262                       if not t1:
  1580                                                                 self.sp_snc[np.where(self.sp_snc < 0)[0]] = 0.0
  1581                                         
  1582                                                             # ORGANIC nutrients uptake
  1583    197.7 MiB      0.0 MiB       18262                       total_on = self.sp_snc[:4].sum()
  1584    197.7 MiB      0.0 MiB       18262                       if total_on > 0.0 and np.isfinite(total_on):
  1585    197.7 MiB      0.0 MiB      127834                           frsn = [i / total_on for i in self.sp_snc[:4]]
  1586                                                             else:
  1587                                                                 frsn = [0.0, 0.0, 0.0, 0.0]
  1588    197.7 MiB      0.0 MiB       91310                       for i, fr in enumerate(frsn):
  1589    197.7 MiB      0.0 MiB       73048                           self.sp_snc[i] -= (self.nupt[1, step] * fr)
  1590                                         
  1591    197.7 MiB      0.0 MiB       18262                       idx = np.where(self.sp_snc < 0.0)[0]
  1592    197.7 MiB      0.0 MiB       18262                       if len(idx) > 0:
  1593                                                                 self.sp_snc[idx] = 0.0
  1594                                         
  1595    197.7 MiB      0.0 MiB       18262                       self.sp_organic_n = self.sp_snc[:2].sum()
  1596    197.7 MiB      0.0 MiB       18262                       self.sp_sorganic_n = self.sp_snc[2:4].sum()
  1597                                         
  1598                                                             # P
  1599    197.7 MiB      0.0 MiB       18262                       total_op = self.sp_snc[4:].sum()
  1600    197.7 MiB      0.0 MiB       18262                       if total_op > 0.0 and np.isfinite(total_op):
  1601    197.7 MiB      0.0 MiB      127834                           frsp = [i / total_op for i in self.sp_snc[4:]]
  1602                                                             else:
  1603                                                                 frsp = [0.0, 0.0, 0.0, 0.0]
  1604    197.7 MiB      0.0 MiB       91310                       for i, fr in enumerate(frsp):
  1605    197.7 MiB      0.0 MiB       73048                           self.sp_snc[i + 4] -= (self.pupt[2, step] * fr)
  1606                                         
  1607    197.7 MiB      0.0 MiB       18262                       idx = np.where(self.sp_snc < 0.0)[0]
  1608    197.7 MiB      0.0 MiB       18262                       if len(idx) > 0:
  1609                                                                 self.sp_snc[idx] = 0.0
  1610                                         
  1611    197.7 MiB      0.0 MiB       18262                       self.sp_organic_p = self.sp_snc[4:6].sum()
  1612    197.7 MiB      0.0 MiB       18262                       self.sp_sorganic_p = self.sp_snc[6:].sum()
  1613                                                         # END SOIL NUTRIENT DYNAMICS
  1614                                         
  1615    197.7 MiB      0.0 MiB       18262                   if save:
  1616                                                             # Plant uptake and Carbon costs of nutrient uptake
  1617                                                             self.storage_pool[:, step] = masked_mean_2D(self.metacomm.mask, storage_pool.astype(np.float32))
  1618                                                             self.carbon_costs[step] = masked_mean(self.metacomm.mask, cc)
  1619                                                             self.tsoil.append(self.soil_temp)
  1620                                                             self.photo[step] = masked_mean(self.metacomm.mask, photo)
  1621                                                             self.aresp[step] = masked_mean(self.metacomm.mask, aresp)
  1622                                                             self.npp[step] = masked_mean(self.metacomm.mask, npp)
  1623                                                             self.rnpp[step] = masked_mean(self.metacomm.mask, rnpp_mt)
  1624                                                             self.lai[step] = masked_mean(self.metacomm.mask, lai)
  1625                                                             self.rcm[step] = masked_mean(self.metacomm.mask, rcm)
  1626                                                             self.f5[step] = masked_mean(self.metacomm.mask, f5)
  1627                                                             self.rm[step] = masked_mean(self.metacomm.mask, rm)
  1628                                                             self.rg[step] = masked_mean(self.metacomm.mask, rg)
  1629                                                             self.wue[step] = masked_mean(self.metacomm.mask, wue)
  1630                                                             self.cue[step] = masked_mean(self.metacomm.mask, cue)
  1631                                                             self.carbon_deficit[step] = masked_mean(self.metacomm.mask, carbon_deficit)
  1632                                                             self.vcmax[step] = masked_mean(self.metacomm.mask, vcmax)
  1633                                                             self.specific_la[step] = masked_mean(self.metacomm.mask, specific_la)
  1634                                                             self.hresp[step] = soil_out['hr']
  1635                                                             self.csoil[:, step] = soil_out['cs']
  1636                                                             self.wsoil[step] = self.swp.calc_total_water()
  1637                                                             self.inorg_n[step] = self.sp_in_n
  1638                                                             self.inorg_p[step] = self.sp_in_p
  1639                                                             self.sorbed_n[step] = self.sp_so_n
  1640                                                             self.sorbed_p[step] = self.sp_so_p
  1641                                                             self.snc[:, step] = soil_out['snc']
  1642                                                             self.nmin[step] = self.sp_available_n
  1643                                                             self.pmin[step] = self.sp_available_p
  1644                                                             self.ls[step] = living_pls
  1645                                         
  1646                                                     # <- Out of the daily loop
  1647                                                     # Save the spin data
  1648                                                     sv: Thread
  1649    197.7 MiB      0.0 MiB           1               if save:
  1650                                                         if s > 0:
  1622                                                             self.npp[step] = masked_mean(self.metacomm.mask, npp)
  1623                                                             self.rnpp[step] = masked_mean(self.metacomm.mask, rnpp_mt)
  1624                                                             self.lai[step] = masked_mean(self.metacomm.mask, lai)
  1625                                                             self.rcm[step] = masked_mean(self.metacomm.mask, rcm)
  1626                                                             self.f5[step] = masked_mean(self.metacomm.mask, f5)
  1627                                                             self.rm[step] = masked_mean(self.metacomm.mask, rm)
  1628                                                             self.rg[step] = masked_mean(self.metacomm.mask, rg)
  1629                                                             self.wue[step] = masked_mean(self.metacomm.mask, wue)
  1630                                                             self.cue[step] = masked_mean(self.metacomm.mask, cue)
  1631                                                             self.carbon_deficit[step] = masked_mean(self.metacomm.mask, carbon_deficit)
  1632                                                             self.vcmax[step] = masked_mean(self.metacomm.mask, vcmax)
  1633                                                             self.specific_la[step] = masked_mean(self.metacomm.mask, specific_la)
  1634                                                             self.hresp[step] = soil_out['hr']
  1635                                                             self.csoil[:, step] = soil_out['cs']
  1636                                                             self.wsoil[step] = self.swp.calc_total_water()
  1637                                                             self.inorg_n[step] = self.sp_in_n
  1638                                                             self.inorg_p[step] = self.sp_in_p
  1639                                                             self.sorbed_n[step] = self.sp_so_n
  1640                                                             self.sorbed_p[step] = self.sp_so_p
  1641                                                             self.snc[:, step] = soil_out['snc']
  1642                                                             self.nmin[step] = self.sp_available_n
  1643                                                             self.pmin[step] = self.sp_available_p
  1644                                                             self.ls[step] = living_pls
  1645                                         
  1646                                                     # <- Out of the daily loop
  1647                                                     # Save the spin data
  1648                                                     sv: Thread
  1649    197.0 MiB     -0.1 MiB           2               if save:
  1650                                                         if s > 0:
  1651                                                             sv.join()  # Wait for the previous thread to finish
  1652                                                             self.flush_data = None
  1653                                                         self.executed_iterations.append((start_date, end_date))
  1654                                                         self.flush_data = self._flush_output(
  1655                                                             'spin', (self.start_index, self.end_index))
  1656                                                         sv = Thread(target=self._save_output, args=(self.flush_data,))
  1657                                                         sv.start()
  1658                                                 # <- Out of spin loop
  1659                                                 # Manage the last thread
  1660    197.0 MiB      0.0 MiB           1           if save:
  1661                                                     sv.join()  # Wait for the last thread to finish
  1662                                                     self.flush_data = None
  1663                                         
  1664                                         
  1665                                                 # Restablish new communities in the end, if applicable
  1666    197.0 MiB      0.0 MiB           1           if kill_and_reset:
  1667                                                     assert not save, "Cannot save data when resetting communities"
  1668                                                     for community in self.metacomm:
  1669                                                         # with lock:
  1670                                                         new_life_strategies = self.get_from_main_array(community.npls)
  1671                                                         community.restore_from_main_table(new_life_strategies)
  1672                                                     # Here we update the metacomm mask to ensure that all communities are active again
  1673                                                     self.metacomm.update_mask()
  1674                                         
  1675    197.0 MiB      0.0 MiB           1           return None


Filename: C:\Users\darel\OneDrive\Desktop\CAETE\src\caete.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
  1013    197.1 MiB    197.1 MiB           1       @profile
  1014                                             # @timer
  1015                                             def run_gridcell(self,
  1016                                                           start_date: str,
  1017                                                           end_date: str,
  1018                                                           spinup: int = 0,
  1019                                                           fixed_co2_atm_conc: Optional[str] | Optional[int] | Optional[float] = None,
  1020                                                           save: bool = True,
  1021                                                           nutri_cycle: bool = True,
  1022                                                           afex: bool = False,
  1023                                                           reset_community: bool = False,
  1024                                                           kill_and_reset: bool = False,
  1025                                                           env_filter: bool = False,
  1026                                                           process_limitation: bool = False,
  1027                                                           verbose: bool = False):
  1028                                                 """
  1029                                                 Run the model for a grid cell.
  1030                                         
  1031                                                 CAETÊ-DVM execution in the start_date - end_date period, can be used for spinup or transient runs.
  1032                                         
  1033                                                 Args:
  1034                                                     start_date (str): Start date for model execution in "yyyymmdd" format.
  1035                                                     end_date (str): End date for model execution in "yyyymmdd" format.
  1036                                                     spinup (int, optional): Number of repetitions in spinup. Set to 0 for a transient run between start_date and end_date. Default is 0.
  1037                                                     fixed_co2_atm_conc (Optional[Union[str, int, float]]): Fixed atmospheric CO2 concentration. If None, use dynamic CO2 levels from a predefined file. If a string with a year (e.g., "1987") That year's value in the provided file will be used. Use a float to set a fixed level in ppm. Default is None.
  1038                                                     save (bool, optional): Whether to save the results. Default is True.
  1039                                                     nutri_cycle (bool, optional): Whether to include nutrient cycling in the model. Default is True.
  1040                                                     afex (bool, optional): Whether to apply nutrient addition to soil in the model. Default is False.
  1041                                                     reset_community (bool, optional): Whether to restart a new community if there are not viable PLS. Default is False.
  1042                                                     kill_and_reset (bool, optional): Whether to kill and reset the community structure at the end of execution (only CVEG pools and PLS IDs). Default is False.
  1043                                                     env_filter (bool, optional): Whether to apply environmental filtering (Include new PLS periodically) []. Default is False.
  1044                                                     verbose (bool, optional): Whether to print detailed logs during execution. Default is False.
  1045                                         
  1046                                                 Returns:
  1047                                                     None
  1048                                         
  1049                                                 Notes:
  1050                                                     - If reset_community is true a new community will be set (reset) when there is no PLSs remaining.
  1051                                                     - If the kill_and_reset is true, after n spins (integer given by spinup parameter - i.e. in the end
  1052                                                       of function execution) all the communities in a gridcell are reset. The reset_community and
  1053                                                       kill_and_reset  arguments are not mutually exclusive. You can use both as true at the same time.
  1054                                                     - The env_filter argument is used to define if new unique PLSs from the main table will be
  1055                                                       seed in the communities that have free slots (PLSs that are not producing). At the moment, the
  1056                                                       interval for the env_filter to add a new PLS to the community is set to  ~15 days.
  1057                                                       If env filter argument is true, then the reset_community argument will have a very low
  1058                                                       probability to trigger a reset because the communities will be constantly filled with new PLS.
  1059                                                       Nonetheless, the reset_community argument will still be able to trigger a reset if the community loses all PLSs.
  1060                                                       With the probability of a reset_community increasing as the interval between new seeds increases. The parameter doy_months
  1061                                                       in the config file (caete.toml) is used to define the interval for the env_filter to add a new PLS to the community.
  1062                                         
  1063                                                       TODO: Implement a more flexible way to define the interval for
  1064                                                             the env_filter to add a new PLS to the community.
  1065                                                 """
  1066                                         
  1067    197.1 MiB      0.0 MiB           2           assert not fixed_co2_atm_conc or\
  1068    197.1 MiB      0.0 MiB           1               isinstance(fixed_co2_atm_conc, str) or\
  1069                                                     fixed_co2_atm_conc > 0,\
  1070                                                         "A fixed value for ATM[CO2] must be a positive number greater than zero or a proper string with the year - e.g., 'yyyy'"
  1071                                         
  1072                                         
  1073                                                 # Define start and end dates (read parameters)
  1074    197.1 MiB      0.0 MiB           1           start = parse_date(start_date)
  1075    197.1 MiB      0.0 MiB           1           end = parse_date(end_date)
  1076                                         
  1077                                                 # Check dates
  1078    197.1 MiB      0.0 MiB           1           assert start < end, "Start date must be before end date"
  1079    197.1 MiB      0.0 MiB           1           assert start >= self.start_date, "initial date out of bounds for the time array"
  1080    197.1 MiB      0.0 MiB           1           assert end <= self.end_date, f"Final date out of bounds for the time array"
  1081                                         
  1082                                         
  1083                                                 # Define time index bounds for this run
  1084                                                 # During a run we are in general using a slice ov the available time span
  1085                                                 # to run the model. For example, we can run the model for a year or a decade
  1086                                                 # at the begining of the input data time series to spin up. This slice is defined
  1087                                                 # by the start and end dates provided in the arguments. Here we get the indices.
  1088    197.1 MiB      0.0 MiB           1           self.start_index = int(cftime.date2num(start, self.time_unit, self.calendar))
  1089    197.1 MiB      0.0 MiB           1           self.end_index =   int(cftime.date2num(end, self.time_unit, self.calendar))
  1090                                         
  1091                                                 # Find the indices in the time array [used to slice the timeseries with driver data  - tas, pr, etc.]
  1092    197.1 MiB      0.0 MiB           1           lower_bound, upper_bound = self.find_index(self.start_index, self.end_index)
  1093                                         
  1094                                                 # Define the time steps range (days)
  1095    197.1 MiB      0.0 MiB           1           steps = np.arange(lower_bound, upper_bound + 1, dtype=np.int64)
  1096                                         
  1097                                                 # Define the number of repetitions for the spinup
  1098    197.1 MiB      0.0 MiB           1           spin = 1 if spinup == 0 else spinup
  1099                                         
  1100                                                 # Define the AFEX mode
  1101    197.1 MiB      0.0 MiB           1           afex_mode = self.afex_config.afex_mode # type: ignore
  1102                                         
  1103                                                 # Slice&Catch climatic input and make conversions
  1104    197.1 MiB      0.0 MiB           1           cv = self.config.conversion_factors_isimip # type: ignore
  1105                                         
  1106                                         
  1107    197.1 MiB      0.0 MiB           1           if self.config.input_handler.input_method == "ih" and self.config.input_handler.input_type == "netcdf":
  1108                                                     # Variables in Netcdf files are already in proprer units
  1109    197.1 MiB      0.0 MiB           1               temp: NDArray[np.float32] = self.tas[lower_bound: upper_bound + 1]   # Air temp: model uses °C
  1110    197.1 MiB      0.0 MiB           1               prec: NDArray[np.float32] = self.pr[lower_bound: upper_bound + 1]    # Precipitation: model uses  mm/day
  1111    197.1 MiB      0.0 MiB           1               p_atm: NDArray[np.float32] = self.ps[lower_bound: upper_bound + 1]   # Atmospheric pressure: model uses hPa
  1112    197.1 MiB      0.0 MiB           1               ipar: NDArray[np.float32] = self.rsds[lower_bound: upper_bound + 1]  # PAR: model uses  mol(photons) m-2 s-1
  1113    197.1 MiB      0.0 MiB           1               ru: NDArray[np.float32] = self.rhs[lower_bound: upper_bound + 1]     # Relative humidity: model uses 0-1
  1114                                                 else:
  1115                                                     temp: NDArray[np.float32] = self.tas[lower_bound: upper_bound + 1] - cv.tas    # Air temp: model uses °C
  1116                                                     prec: NDArray[np.float32] = self.pr[lower_bound: upper_bound + 1] * cv.pr      # Precipitation: model uses  mm/day
  1117                                                     p_atm: NDArray[np.float32] = self.ps[lower_bound: upper_bound + 1] * cv.ps     # Atmospheric pressure: model uses hPa
  1118                                                     ipar: NDArray[np.float32] = self.rsds[lower_bound: upper_bound + 1] * cv.rsds  # PAR: model uses  mol(photons) m-2 s-1
  1119                                                     ru: NDArray[np.float32] = self.rhs[lower_bound: upper_bound + 1] * cv.rhs      # Relative humidity: model uses 0-1
  1120                                         
  1121                                                 # Define the daily values for co2 concentrations
  1122    197.1 MiB      0.0 MiB           1           co2_daily_values = np.zeros(steps.size, dtype=np.float32)
  1123                                         
  1124    197.1 MiB      0.0 MiB           1           if fixed_co2_atm_conc is None:
  1125                                                     # In this case, the co2 concentration will be updated daily.
  1126                                                     # We interpolate linearly between the yearly values of the atm co2 data
  1127                                                     co2 = self.find_co2(start.year)
  1128                                                     today = datetime(start.year, start.month, start.day, start.hour, start.minute, start.second)
  1129                                                     time_step = timedelta(days=1) # Define the time step
  1130                                                     today -= time_step # The first thing we do next is to add a day to the date. So we go back one day
  1131                                                     # Loop over the days and calculate the co2 concentration for each day
  1132                                                     for step in range(steps.size):
  1133                                                         today += time_step
  1134                                                         remaining = (datetime(today.year, 12, 31) - today).days + 1
  1135                                                         daily_fraction = (self.find_co2(today.year + 1) - co2) / (remaining + 1)
  1136                                                         co2 += daily_fraction
  1137                                                         co2_daily_values[step] = co2
  1138    197.1 MiB      0.0 MiB           1           elif isinstance(fixed_co2_atm_conc, int) or isinstance(fixed_co2_atm_conc, float):
  1139                                                     # In this case, the co2 concentration will be fixed according to the numeric value provided in the argument
  1140                                                     co2 = fixed_co2_atm_conc
  1141                                                     co2_daily_values += co2
  1142    197.1 MiB      0.0 MiB           1           elif isinstance(fixed_co2_atm_conc, str):
  1143                                                     # In this case, the co2 concentration will be fixed
  1144                                                     # According to the year provided in the argument
  1145                                                     # as a string. Format "yyyy".
  1146    197.1 MiB      0.0 MiB           1               try:
  1147    197.1 MiB      0.0 MiB           1                   co2_year = int(fixed_co2_atm_conc)
  1148                                                     except ValueError:
  1149                                                         raise ValueError(
  1150                                                             "The string(\"yyyy\") must be a number in the {self.start_date.year} - {self.end_date.year} interval")
  1151    197.1 MiB      0.0 MiB           1               co2 = self.find_co2(co2_year)
  1152    197.1 MiB      0.0 MiB           1               co2_daily_values += co2
  1153                                                 else:
  1154                                                     raise ValueError("Invalid value for fixed_co2_atm_conc")
  1155                                         
  1156                                                 # Define variables to track dates
  1157    197.1 MiB      0.0 MiB           1           first_day_of_simulation = datetime(start.year, start.month, start.day, start.hour, start.minute, start.second)
  1158                                                 # Define the time step
  1159    197.1 MiB      0.0 MiB           1           time_step = timedelta(days=1)
  1160                                         
  1161                                                 # Define the object to store the outputs from daily_budget
  1162    197.1 MiB      0.0 MiB           1           daily_output = DailyBudget()
  1163                                         
  1164                                                 # Start loops
  1165                                                 # This outer loop is used to run the model for a number
  1166                                                 # of times defined by the spinup argument. The model is
  1167                                                 # executed repeatedly between the start and end dates
  1168                                                 # provided in the arguments
  1169                                         
  1170    197.1 MiB      0.0 MiB           2           for s in range(spin):
  1171                                         
  1172    197.1 MiB      0.0 MiB           1               self._allocate_output(steps.size, self.metacomm.comm_npls, len(self.metacomm), save)
  1173                                         
  1174                                                     # Loop over the days
  1175    197.1 MiB      0.0 MiB           1               today = first_day_of_simulation
  1176                                         
  1177                                                     # Go back one day
  1178    197.1 MiB      0.0 MiB           1               today -= time_step
  1179                                         
  1180                                                     # Arrays to store & pass values for each community in a simulated day
  1181    197.1 MiB      0.0 MiB           1               sto =        np.zeros(shape=(3, self.metacomm.comm_npls), order='F')
  1182    197.1 MiB      0.0 MiB           1               cleaf_in =   np.zeros(self.metacomm.comm_npls, order='F')
  1183    197.1 MiB      0.0 MiB           1               cwood_in =   np.zeros(self.metacomm.comm_npls, order='F')
  1184    197.1 MiB      0.0 MiB           1               croot_in =   np.zeros(self.metacomm.comm_npls, order='F')
  1185    197.1 MiB      0.0 MiB           1               uptk_costs = np.zeros(self.metacomm.comm_npls, order='F')
  1186    197.1 MiB      0.0 MiB           1               rnpp_in =    np.zeros(self.metacomm.comm_npls, order='F')
  1187                                         
  1188                                                     # There are two modes of operation: save and not save.
  1189                                                     # In the save == False mode, the arrays are used to store the values that are
  1190                                                     # needed for model iteration, i.e., the values that are used in the next
  1191                                                     # time step. In the save mode, an extra number arrays is created to be used
  1192                                                     # to store the outputs.
  1193    197.1 MiB      0.0 MiB           1               xsize: int = len(self.metacomm) # Number of communities
  1194    197.1 MiB      0.0 MiB           1               evavg: NDArray[np.float32] = np.zeros(xsize, dtype=np.float32)
  1195    197.1 MiB      0.0 MiB           1               epavg: NDArray[np.float32] = np.zeros(xsize, dtype=np.float32)
  1196    197.1 MiB      0.0 MiB           1               rnpp_mt: NDArray[np.float32] = np.zeros(xsize, dtype=np.float32)
  1197                                         
  1198                                                     # We keep track of these to input in SOM dynamics later. They are used for output also
  1199    197.1 MiB      0.0 MiB           1               leaf_litter: NDArray[np.float32] = np.zeros(xsize, dtype=np.float32)
  1200    197.1 MiB      0.0 MiB           1               cwd: NDArray[np.float32] = np.zeros(xsize, dtype=np.float32)
  1201    197.1 MiB      0.0 MiB           1               root_litter: NDArray[np.float32] = np.zeros(xsize, dtype=np.float32)
  1202    197.1 MiB      0.0 MiB           1               lnc: NDArray[np.float32] = np.zeros(shape=(6, xsize), dtype=np.float32)
  1203                                                     # This is added to leaf litter pool (that is basicaly a fast SOM pool)
  1204    197.1 MiB      0.0 MiB           1               c_to_nfixers: NDArray[np.float32]= np.zeros(xsize, dtype=np.float32)
  1205    197.1 MiB      0.0 MiB           1               nupt = np.zeros(shape=(2, xsize), dtype=np.float32)
  1206    197.1 MiB      0.0 MiB           1               pupt = np.zeros(shape=(3, xsize), dtype=np.float32)
  1207                                         
  1208    197.1 MiB      0.0 MiB           1               if save:
  1209                                                         cc = np.zeros(xsize, dtype=np.float32)
  1210                                                         photo = np.zeros(xsize, dtype=np.float32)
  1211                                                         aresp = np.zeros(xsize, dtype=np.float32)
  1212                                                         npp = np.zeros(xsize, dtype=np.float32)
  1213                                                         lai = np.zeros(xsize, dtype=np.float32)
  1214                                                         rcm = np.zeros(xsize, dtype=np.float32)
  1215                                                         f5 = np.zeros(xsize, dtype=np.float32)
  1216                                                         rm = np.zeros(xsize, dtype=np.float32)
  1217                                                         rg = np.zeros(xsize, dtype=np.float32)
  1218                                                         wue = np.zeros(xsize, dtype=np.float32)
  1219                                                         cue = np.zeros(xsize, dtype=np.float32)
  1220                                                         carbon_deficit = np.zeros(xsize, dtype=np.float32)
  1221                                                         vcmax = np.zeros(xsize, dtype=np.float32)
  1222                                                         specific_la = np.zeros(xsize, dtype=np.float32)
  1223                                                         storage_pool = np.zeros(shape=(3, xsize))
  1224                                         
  1225                                                         if process_limitation:
  1226                                                             lim_status_y_leaf = np.ma.masked_all((xsize, self.metacomm.comm_npls, 366), dtype=np.int8)
  1227                                                             lim_status_y_stem = np.ma.masked_all((xsize, self.metacomm.comm_npls, 366), dtype=np.int8)
  1228                                                             lim_status_y_root = np.ma.masked_all((xsize, self.metacomm.comm_npls, 366), dtype=np.int8)
  1229                                                             uptake_strategy_n = np.ma.masked_all((xsize, self.metacomm.comm_npls, 366), dtype=np.int8)
  1230                                                             uptake_strategy_p = np.ma.masked_all((xsize, self.metacomm.comm_npls, 366), dtype=np.int8)
  1231                                         
  1232                                                     # <- Daily loop
  1233    197.1 MiB     -7.2 MiB       18263               for step in range(steps.size):
  1234    197.1 MiB     -7.2 MiB       18262                   today += time_step
  1235    197.1 MiB     -7.2 MiB       18262                   julian_day = today.timetuple().tm_yday
  1236                                         
  1237                                                         # Get the co2 concentration for the day
  1238    197.1 MiB     -7.2 MiB       18262                   co2 = co2_daily_values[step]
  1239                                                         # Update soil temperature
  1240    197.1 MiB     -7.2 MiB       18262                   self.soil_temp = st.soil_temp(self.soil_temp, temp[step])
  1241                                         
  1242                                                         # AFEX
  1243    197.1 MiB     -7.2 MiB       18262                   if afex and julian_day == 365:
  1244                                                             self.add_soil_nutrients(afex_mode)
  1245                                         
  1246                                                         # Loop over communities
  1247    197.1 MiB     -7.2 MiB       18262                   living_pls = 0 # Sum of living PLS in the communities
  1248    197.1 MiB    -14.5 MiB       36524                   for i, community in enumerate(self.metacomm):
  1249                                                             # if i >= len(self.metacomm):
  1250                                                             #     break
  1251                                                             # if community.masked:
  1252                                                             #     # skip this one
  1253                                                             #     continue
  1254    197.1 MiB     -7.2 MiB       18262                       sto[0, :] = inflate_array(community.npls, community.vp_sto[0, :], community.vp_lsid)
  1255    197.1 MiB     -7.2 MiB       18262                       sto[1, :] = inflate_array(community.npls, community.vp_sto[1, :], community.vp_lsid)
  1256    197.1 MiB     -7.2 MiB       18262                       sto[2, :] = inflate_array(community.npls, community.vp_sto[2, :], community.vp_lsid)
  1257                                         
  1258    197.1 MiB     -7.2 MiB       18262                       cleaf_in[:] = inflate_array(community.npls, community.vp_cleaf, community.vp_lsid)
  1259    197.1 MiB     -7.2 MiB       18262                       cwood_in[:] = inflate_array(community.npls, community.vp_cwood, community.vp_lsid)
  1260    197.1 MiB     -7.2 MiB       18262                       croot_in[:] = inflate_array(community.npls, community.vp_croot, community.vp_lsid)
  1261    197.1 MiB     -7.2 MiB       18262                       uptk_costs[:] = inflate_array(community.npls, community.sp_uptk_costs, community.vp_lsid)
  1262    197.1 MiB     -7.2 MiB       18262                       rnpp_in[:] = inflate_array(community.npls, community.construction_npp, community.vp_lsid)
  1263                                         
  1264    197.1 MiB     -7.2 MiB       18262                       ton = self.sp_organic_n #+ self.sp_sorganic_n
  1265    197.1 MiB     -7.2 MiB       18262                       top = self.sp_organic_p #+ self.sp_sorganic_p
  1266                                         
  1267                                                             # Community daily budget calculation
  1268    197.1 MiB    -14.5 MiB       36524                       out = model.daily_budget(community.pls_array, self.wp_water_upper_mm,
  1269    197.1 MiB     -7.2 MiB       18262                                               self.wp_water_lower_mm, self.soil_temp, temp[step],
  1270    197.1 MiB     -7.2 MiB       18262                                               p_atm[step], ipar[step], ru[step], self.sp_available_n,
  1271    197.1 MiB     -7.2 MiB       18262                                               self.sp_available_p, ton, top, self.sp_organic_p,
  1272    197.1 MiB     -7.2 MiB       18262                                               co2, sto, cleaf_in, cwood_in, croot_in, uptk_costs,self.wmax_mm,
  1273    197.1 MiB     -7.2 MiB       18262                                               rnpp_in)
  1274                                         
  1275                                                             # get daily budget results
  1276    197.1 MiB     -7.2 MiB       18262                       daily_output.update(out)
  1277                                         
  1278                                                             # Update the community status
  1279    197.1 MiB     -7.2 MiB       18262                       community.update_lsid(daily_output.ocpavg)
  1280                                         
  1281                                                             # Abort community if no PLSs are left while saving the spin
  1282    197.1 MiB     -7.2 MiB       18262                       if community.masked and save:
  1283                                                                 continue
  1284                                         
  1285    197.1 MiB     -7.2 MiB       18262                       community.ls = community.vp_lsid.size
  1286                                                             # # Restore or seed PLS
  1287    197.1 MiB     -7.2 MiB       18262                       if env_filter and (community.ls < self.metacomm.comm_npls) and not save:
  1288                                                                 if julian_day in self.doy_months:
  1289                                                                     new_id, new_PLS = community.get_unique_pls(self.get_from_main_array)
  1290                                                                     community.seed_pls(new_id, new_PLS, daily_output.cleafavg_pft,
  1291                                                                                        daily_output.cfrootavg_pft, daily_output.cawoodavg_pft)
  1292                                                                     if verbose: print(f"PLS seed in Community {i}: Gridcell: {self.lat} °N, {self.lon} °E: In spin:{s}, step:{step}")
  1293                                         
  1294                                                                     daily_output.ocpavg = pft_area_frac64(daily_output.cleafavg_pft,
  1295                                                                                                     daily_output.cfrootavg_pft,
  1296                                                                                                     daily_output.cawoodavg_pft)
  1297                                                                     community.update_lsid(daily_output.ocpavg)
  1298                                                                     community.ls = community.vp_lsid.size
  1299                                                                 # endif
  1300                                         
  1301                                         
  1302    197.1 MiB     -7.2 MiB       18262                       community.vp_ocp = daily_output.ocpavg[community.vp_lsid]
  1303    197.1 MiB     -7.2 MiB       18262                       community.vp_cleaf = daily_output.cleafavg_pft[community.vp_lsid]
  1304    197.1 MiB     -7.2 MiB       18262                       community.vp_cwood = daily_output.cawoodavg_pft[community.vp_lsid]
  1305    197.1 MiB     -7.2 MiB       18262                       community.vp_croot = daily_output.cfrootavg_pft[community.vp_lsid]
  1306    197.1 MiB     -7.2 MiB       18262                       community.vp_sto = daily_output.stodbg[:, community.vp_lsid].astype('float32')
  1307    197.1 MiB     -7.2 MiB       18262                       community.sp_uptk_costs = daily_output.npp2pay[community.vp_lsid]
  1308    197.1 MiB     -7.2 MiB       18262                       community.construction_npp = daily_output.rnpp_out[community.vp_lsid]
  1309    197.1 MiB     -7.2 MiB       18262                       living_pls += community.ls
  1310                                                             # print(f"Community storage: {community.vp_sto[0, :]}")
  1311                                                             # print(f"Sto_budget_out {daily_output.stodbg[0, :]}")
  1312                                         
  1313                                                             # Limiting nutrient organization:
  1314                                                             # dim1 = leaf wood root, code: 1=N 2=P 4=N,COLIM 5=P,COLIM 6=COLIM 0=NOLIM
  1315    197.1 MiB     -7.2 MiB       18262                       if save:
  1316                                                                 if process_limitation:
  1317                                                                     lim_status_y_leaf[i, :, julian_day - 1] = daily_output.limitation_status[0,:]# type: ignore
  1318                                                                     lim_status_y_stem[i, :, julian_day - 1] = daily_output.limitation_status[1,:]# type: ignore
  1319                                                                     lim_status_y_root[i, :, julian_day - 1] = daily_output.limitation_status[2,:]# type: ignore
  1320                                                                     uptake_strategy_n[i, :, julian_day - 1] = daily_output.uptk_strat[0,:]# type: ignore
  1321                                                                     uptake_strategy_p[i, :, julian_day - 1] = daily_output.uptk_strat[1,:]# type: ignore
  1322                                         
  1323                                                                 community.anpp += cw_mean(community.vp_ocp, community.construction_npp.astype(np.float32))
  1324                                                                 community.uptake_costs += cw_mean(community.vp_ocp, community.sp_uptk_costs.astype(np.float32))
  1325                                         
  1326    197.1 MiB     -7.2 MiB       18262                       if save and julian_day == 365:
  1327                                                                 community.cleaf = cw_mean(community.vp_ocp, community.vp_cleaf.astype(np.float32))
  1328                                                                 community.cwood = cw_mean(community.vp_ocp, community.vp_cwood.astype(np.float32))
  1329                                                                 community.croot = cw_mean(community.vp_ocp, community.vp_croot.astype(np.float32))
  1330                                                                 community.csto = cw_mean(community.vp_ocp, community.vp_sto[0, :])
  1331                                                                 community.shannon_diversity = shannon_diversity(community.vp_ocp)
  1332                                                                 community.shannon_entropy = shannon_entropy(community.vp_ocp)
  1333                                                                 community.shannon_evenness = shannon_evenness(community.vp_ocp)
  1334                                         
  1335                                                                 # process limitation data
  1336                                                                 # Filter non living PLS from the limitation status
  1337                                                                 if process_limitation:
  1338                                                                     _data_leaf = lim_status_y_leaf[i, [community.vp_lsid], :] # type: ignore
  1339                                                                     _data_stem = lim_status_y_stem[i, [community.vp_lsid], :] # type: ignore
  1340                                                                     _data_root = lim_status_y_root[i, [community.vp_lsid], :] # type: ignore
  1341                                         
  1342                                                                     _data_uptake_n = uptake_strategy_n[i, [community.vp_lsid], :]# type: ignore
  1343                                                                     _data_uptake_p = uptake_strategy_p[i, [community.vp_lsid], :]# type: ignore
  1344                                         
  1345                                                                     # Loop over the living PLS to get the unique values and counts
  1346                                                                     pls_lim_leaf = []
  1347                                                                     pls_lim_stem = []
  1348                                                                     pls_lim_root = []
  1349                                                                     pls_uptake_n = []
  1350                                                                     pls_uptake_p = []
  1351                                         
  1352                                                                     for k in range(community.vp_lsid.size):
  1353                                                                         # Get the unique values and counts for leaf limitation
  1354                                                                         unique, counts = np.unique(_data_leaf[0, k, :], return_counts=True)
  1355                                                                         unique = unique.data[unique.mask == False] # type: ignore
  1356                                                                         pls_lim_leaf.append((unique, counts[:unique.size])) # type: ignore
  1357                                         
  1358                                                                         # Stem limitation
  1359                                                                         unique, counts = np.unique(_data_stem[0, k, :], return_counts=True)
  1360                                                                         unique = unique.data[unique.mask == False] # type: ignore
  1361                                                                         pls_lim_stem.append((unique, counts[:unique.size])) # type: ignore
  1362                                         
  1363                                                                         # Root limitation
  1364                                                                         unique, counts = np.unique(_data_root[0, k, :], return_counts=True)
  1365                                                                         unique = unique.data[unique.mask == False]
  1366                                                                         pls_lim_root.append((unique, counts[:unique.size])) # type: ignore
  1367                                         
  1368                                                                         # Uptake strategy N
  1369                                                                         unique, counts = np.unique(_data_uptake_n[0, k, :], return_counts=True)
  1370                                                                         unique = unique.data[unique.mask == False] # type: ignore
  1371                                                                         pls_uptake_n.append((unique, counts[:unique.size])) # type: ignore
  1372                                         
  1373                                                                         # Uptake strategy P
  1374                                                                         unique, counts = np.unique(_data_uptake_p[0, k, :], return_counts=True)
  1375                                                                         unique = unique.data[unique.mask == False]  # type: ignore
  1376                                                                         pls_uptake_p.append((unique, counts[:unique.size])) # type: ignore
  1377                                         
  1378                                                                     community.limitation_status_leaf = pls_lim_leaf
  1379                                                                     community.limitation_status_wood = pls_lim_stem
  1380                                                                     community.limitation_status_root = pls_lim_root
  1381                                                                     community.uptake_strategy_n = pls_uptake_n
  1382                                                                     community.uptake_strategy_p = pls_uptake_p
  1383                                         
  1384                                                                     # Reset the limitation masked arrays
  1385                                                                     lim_status_y_leaf.mask[i, :, :] = np.ones((self.metacomm.comm_npls, 366), dtype=bool) # type: ignore
  1386                                                                     lim_status_y_stem.mask[i, :, :] = np.ones((self.metacomm.comm_npls, 366), dtype=bool) # type: ignore
  1387                                                                     lim_status_y_root.mask[i, :, :] = np.ones((self.metacomm.comm_npls, 366), dtype=bool) # type: ignore
  1388                                                                     uptake_strategy_n.mask[i, :, :] = np.ones((self.metacomm.comm_npls, 366), dtype=bool) # type: ignore
  1389                                                                     uptake_strategy_p.mask[i, :, :] = np.ones((self.metacomm.comm_npls, 366), dtype=bool) # type: ignore
  1390                                                                 else:
  1391                                                                     pass
  1392                                         
  1393    197.1 MiB     -7.2 MiB       18262                       if community.vp_lsid.size < 1:
  1394                                                                 if verbose: print(f"Empty community {i}: Gridcell: {self.lat} °N, {self.lon} °E: In spin:{s}, step:{step}")
  1395                                                                 if reset_community:
  1396                                                                     assert not save, "Cannot save data when resetting communities"
  1397                                                                     if verbose: print(f"Reseting community {i}: Gridcell: {self.lat} °N, {self.lon} °E: In spin:{s}, step:{step}")
  1398                                         
  1399                                                                     new_life_strategies = self.get_from_main_array(community.npls)
  1400                                                                     community.restore_from_main_table(new_life_strategies)
  1401                                                                     # continue
  1402                                         
  1403                                                                 else:
  1404                                                                     # In the transiant run - i.e., when reset_community is false and
  1405                                                                     # kill_and_reset is false; we mask the community if there is no PLS
  1406                                                                     self.metacomm.mask[i] = np.int8(1)
  1407                                                                     # Set mask to true for this community, will not run in the next steps
  1408                                                                     # Set annual values to zero
  1409                                                                     community.masked = np.int8(1)
  1410                                                                     community.cleaf = np.float32(0.0)
  1411                                                                     community.cwood = np.float32(0.0)
  1412                                                                     community.croot = np.float32(0.0)
  1413                                                                     community.csto  = np.float32(0.0)
  1414                                                                     community.shannon_diversity = -9999.0
  1415                                                                     community.shannon_entropy = -9999.0
  1416                                                                     community.shannon_evenness = -9999.0
  1417                                                                     # if the reset_community is true
  1418                                                                     # continue # cycle
  1419                                         
  1420                                                             # Store values for each community
  1421    197.1 MiB     -7.2 MiB       18262                       rnpp_mt[i] = cw_mean(community.vp_ocp, community.construction_npp.astype(np.float32)) # Community Weighted rNPP
  1422    197.1 MiB     -7.2 MiB       18262                       leaf_litter[i] = daily_output.litter_l
  1423    197.1 MiB     -7.2 MiB       18262                       root_litter[i] = daily_output.litter_fr
  1424    197.1 MiB     -7.2 MiB       18262                       cwd[i] = daily_output.cwd
  1425    197.1 MiB     -7.2 MiB       18262                       lnc[:, i] = daily_output.lnc.astype(np.float32)
  1426    197.1 MiB     -7.2 MiB       18262                       c_to_nfixers[i] = daily_output.cp[3]
  1427    197.1 MiB     -7.2 MiB       18262                       evavg[i] = daily_output.evavg
  1428    197.1 MiB     -7.2 MiB       18262                       epavg[i] = daily_output.epavg
  1429    197.1 MiB     -7.2 MiB       18262                       nupt[:, i] = daily_output.nupt #type: ignore
  1430    197.1 MiB     -7.2 MiB       18262                       pupt[:, i] = daily_output.pupt #type: ignore
  1431                                         
  1432    197.1 MiB     -7.2 MiB       18262                       if save:
  1433                                                                 cc[i] = daily_output.c_cost_cwm #type: ignore
  1434                                                                 npp[i] = daily_output.nppavg #type: ignore
  1435                                                                 photo[i] = daily_output.phavg #type: ignore
  1436                                                                 aresp[i] = daily_output.aravg #type: ignore
  1437                                                                 lai[i] = daily_output.laiavg #type: ignore
  1438                                                                 rcm[i] = daily_output.rcavg #type: ignore
  1439                                                                 f5[i] = daily_output.f5avg #type: ignore
  1440                                                                 rm[i] = daily_output.rmavg #type: ignore
  1441                                                                 rg[i] = daily_output.rgavg #type: ignore
  1442                                                                 wue[i] = daily_output.wueavg #type: ignore
  1443                                                                 cue[i] = daily_output.cueavg #type: ignore
  1444                                                                 carbon_deficit[i] = daily_output.c_defavg #type: ignore
  1445                                                                 vcmax[i] = daily_output.vcmax #type: ignore
  1446                                                                 specific_la[i] = daily_output.specific_la #type: ignore
  1447                                         
  1448                                                                 for j in range(daily_output.stodbg.shape[0]):
  1449                                                                     storage_pool[j, i] = cw_mean(community.vp_ocp, community.vp_sto[j, :]) #type: ignore
  1450                                         
  1451                                                         #<- Out of the community loop
  1452                                                         # Save annual state of the metacommunity
  1453    197.1 MiB     -7.2 MiB       18262                   if save:
  1454                                                             if julian_day == 365:
  1455                                                                 y = today.year
  1456                                                                 # m = today.month
  1457                                                                 # d = today.day
  1458                                                                 filename = self.out_dir/f"metacommunity_{y}.pkz"
  1459                                                                 # filename = self.out_dir/f"metacommunity_{d}{m}{y}.pkz"
  1460                                                                 self.metacomm.save_state(filename, y, process_limitation)
  1461                                                                 self.metacomm_output[y] = filename
  1462                                         
  1463                                                                 for community in self.metacomm:
  1464                                                                     # Set annual accumulators to zero
  1465                                                                     community.anpp = np.float32(0.0)
  1466                                                                     community.uptake_costs = np.float32(0.0)
  1467                                         
  1468                                                         # ------------
  1469                                                         # Evapotranspiration
  1470    197.1 MiB     -7.2 MiB       18262                   et = masked_mean(self.metacomm.mask, evavg) #evavg.mean()
  1471                                                         ## Canopy-atmosphere coupling [EXPERIMENTAL]
  1472                                                         # vpd = m.vapor_p_deficit(temp[step], ru[step])
  1473                                                         # et_pot = masked_mean(self.metacomm.mask, np.array(epavg).astype(np.float32)) #epavg.mean()
  1474                                                         # self.evapm[step] = atm_canopy_coupling(et_pot, et, temp[step], vpd)
  1475    197.1 MiB     -7.2 MiB       18262                   self.evapm[step] = et
  1476                                         
  1477                                                         # Update water pools
  1478                                         
  1479    197.1 MiB     -7.2 MiB       18262                   self.runom[step] = self.swp._update_pool(prec[step], self.evapm[step])
  1480    197.1 MiB     -7.2 MiB       18262                   self.swp.w1 = 0.0 if self.swp.w1 < 0.0 else self.swp.w1
  1481    197.1 MiB     -7.2 MiB       18262                   self.swp.w2 = 0.0 if self.swp.w2 < 0.0 else self.swp.w2
  1482    197.1 MiB     -7.2 MiB       18262                   self.wp_water_upper_mm = self.swp.awc1
  1483    197.1 MiB     -7.2 MiB       18262                   self.wp_water_lower_mm = self.swp.awc2
  1484    197.1 MiB     -7.2 MiB       18262                   wtot = self.swp.w1 + self.swp.w2
  1485                                         
  1486                                                         # Update cflux to the soil for output, mean values over the communities
  1487                                                         # Values are also used to update SOM dynamics
  1488    197.1 MiB    -14.5 MiB       36524                   self.litter_l[step] = masked_mean(self.metacomm.mask, leaf_litter) +\
  1489    197.1 MiB     -7.2 MiB       18262                                         masked_mean(self.metacomm.mask, c_to_nfixers)
  1490    197.1 MiB     -7.2 MiB       18262                   self.cwd[step] = masked_mean(self.metacomm.mask, cwd)
  1491    197.1 MiB     -7.2 MiB       18262                   self.litter_fr[step] = masked_mean(self.metacomm.mask, root_litter)
  1492    197.1 MiB     -7.2 MiB       18262                   self.lnc[:, step] = masked_mean_2D(self.metacomm.mask, lnc)
  1493                                         
  1494                                                         # Soil C:N:P balance and OM decomposition
  1495    197.1 MiB    -14.5 MiB       36524                   s_out = soil_dec.carbon3(self.soil_temp, wtot / self.wmax_mm, self.litter_l[step],
  1496    197.1 MiB     -7.2 MiB       18262                                            self.cwd[step], self.litter_fr[step], self.lnc[:, step],
  1497    197.1 MiB     -7.2 MiB       18262                                            self.sp_csoil, self.sp_snc)
  1498    197.1 MiB     -7.2 MiB       18262                   soil_out = catch_out_carbon3(s_out)
  1499                                         
  1500                                                         # Organic C N & P
  1501    197.1 MiB     -7.2 MiB       18262                   self.sp_csoil = soil_out['cs']
  1502    197.1 MiB     -7.2 MiB       18262                   self.sp_snc = np.zeros(shape=8)
  1503    197.1 MiB     -7.2 MiB       18262                   self.sp_snc = soil_out['snc']
  1504    197.1 MiB     -7.2 MiB       18262                   idx = np.where(self.sp_snc < 0.0)[0]
  1505    197.1 MiB     -7.2 MiB       18262                   if len(idx) > 0:
  1506                                                             self.sp_snc[idx] = 0.0
  1507                                         
  1508                                                         # <- Out of the community loop
  1509    197.1 MiB   -124.3 MiB       18262                   self.nupt[:, step] = masked_mean_2D(self.metacomm.mask, nupt)
  1510    197.2 MiB   -153.6 MiB       18262                   self.pupt[:, step] = masked_mean_2D(self.metacomm.mask, pupt)
  1511                                         
  1512                                                         # TODO: Soil nutrient dynamics. Isolate this if branch into a separate method/class/function
  1513                                                         # Critical part of soil nutrient dynamics and availability for plants
  1514                                                         # IF NUTRICYCLE
  1515    197.2 MiB   -212.2 MiB       18262                   if nutri_cycle:
  1516                                                             # UPDATE ORGANIC POOLS
  1517    197.2 MiB   -241.4 MiB       18262                       self.sp_organic_n = self.sp_snc[:2].sum()
  1518    197.1 MiB   -241.5 MiB       18262                       self.sp_sorganic_n = self.sp_snc[2:4].sum()
  1519    197.1 MiB   -124.3 MiB       18262                       self.sp_organic_p = self.sp_snc[4:6].sum()
  1520    197.1 MiB    -65.8 MiB       18262                       self.sp_sorganic_p = self.sp_snc[6:].sum()
  1521                                         
  1522                                                             # Update inorganic pools
  1523    197.1 MiB     -7.2 MiB       18262                       self.sp_available_p += soil_out['pmin']
  1524    197.1 MiB     -7.2 MiB       18262                       self.sp_available_n += soil_out['nmin']
  1525    197.1 MiB     -7.2 MiB       18262                       self.sp_available_p -= self.pupt[0, step]
  1526    197.1 MiB     -7.2 MiB       18262                       self.sp_available_n -= self.nupt[0, step]
  1527                                         
  1528                                                             # NUTRIENT DINAMICS
  1529                                         
  1530                                                             # Inorganic N
  1531                                                             # TODO: NaNs are being sourced upstream , need to track the source and fix it
  1532                                         
  1533    197.1 MiB     -7.2 MiB       18262                       if not np.isfinite(self.sp_in_n):
  1534                                                                 # rwarn(f"Non-finite value detected in sp_in_n pool at step {step}. Resetting to zero.")
  1535                                                                 self.sp_in_n = 0.0
  1536    197.1 MiB     -7.2 MiB       18262                       if not np.isfinite(self.sp_available_n):
  1537                                                                 # rwarn(f"Non-finite value detected in sp_available_n pool at step {step}. Resetting to zero.")
  1538                                                                 self.sp_available_n = 0.0
  1539    197.1 MiB     -7.2 MiB       18262                       if not np.isfinite(self.sp_so_n):
  1540                                                                 # rwarn(f"Non-finite value detected in sp_so_n pool at step {step}. Resetting to zero.")
  1541                                                                 self.sp_so_n = 0.0
  1542                                         
  1543    197.1 MiB     -7.2 MiB       18262                       self.sp_in_n += self.sp_available_n + self.sp_so_n
  1544    197.1 MiB     -7.2 MiB       18262                       self.sp_so_n = soil_dec.sorbed_n_equil(self.sp_in_n)
  1545    197.1 MiB     -7.2 MiB       18262                       self.sp_available_n = soil_dec.solution_n_equil(self.sp_in_n)
  1546    197.1 MiB     -7.2 MiB       18262                       self.sp_in_n -= (self.sp_so_n + self.sp_available_n)
  1547                                         
  1548                                                             # Inorganic P
  1549    197.1 MiB     -7.2 MiB       18262                       if not np.isfinite(self.sp_in_p):
  1550                                                                 # rwarn(f"Non-finite value detected in sp_in_p pool at step {step}. Resetting to zero.")
  1551                                                                 self.sp_in_p = 0.0
  1552    197.1 MiB     -7.2 MiB       18262                       if not np.isfinite(self.sp_available_p):
  1553                                                                 # rwarn(f"Non-finite value detected in sp_available_p pool at step {step}. Resetting to zero.")
  1554                                                                 self.sp_available_p = 0.0
  1555    197.1 MiB     -7.2 MiB       18262                       if not np.isfinite(self.sp_so_p):
  1556                                                                 # rwarn(f"Non-finite value detected in sp_so_p pool at step {step}. Resetting to zero.")
  1557                                                                 self.sp_so_p = 0.0
  1558                                         
  1559    197.1 MiB     -7.2 MiB       18262                       self.sp_in_p += self.sp_available_p + self.sp_so_p
  1560                                                             # sp_so_p is the occluded P in the inorganic pool
  1561    197.1 MiB     -7.2 MiB       18262                       self.sp_so_p = soil_dec.sorbed_p_equil(self.sp_in_p)
  1562                                                             # THe fraction that can be dissolved in soil solution (passive uptake uses transpiration
  1563                                                             # to estimate the amount of P that can be taken up from the soil solution pool)
  1564    197.1 MiB     -7.2 MiB       18262                       self.sp_available_p = soil_dec.solution_p_equil(self.sp_in_p)
  1565                                                             # Inorganic pool that is adsorbed
  1566    197.1 MiB     -7.2 MiB       18262                       self.sp_in_p -= (self.sp_so_p + self.sp_available_p)
  1567                                         
  1568    197.1 MiB     -7.2 MiB       18262                       self.sp_so_p -= self.pupt[1, step]
  1569                                         
  1570    197.1 MiB     -7.2 MiB       18262                       try:
  1571    197.1 MiB     -7.2 MiB       18262                           t1 = np.all(self.sp_snc > 0.0)
  1572                                                             except:
  1573                                                                 if self.sp_snc is None:
  1574                                                                     self.sp_snc = np.zeros(shape=8,)
  1575                                                                     t1 = True
  1576                                                                 elif self.sp_snc is not None:
  1577                                                                     t1 = True
  1578                                                                 rwarn(f"Exception while handling sp_snc pool")
  1579    197.1 MiB     -7.2 MiB       18262                       if not t1:
  1580                                                                 self.sp_snc[np.where(self.sp_snc < 0)[0]] = 0.0
  1581                                         
  1582                                                             # ORGANIC nutrients uptake
  1583    197.1 MiB     -7.2 MiB       18262                       total_on = self.sp_snc[:4].sum()
  1584    197.1 MiB     -7.2 MiB       18262                       if total_on > 0.0 and np.isfinite(total_on):
  1585    197.1 MiB    -50.6 MiB      127834                           frsn = [i / total_on for i in self.sp_snc[:4]]
  1586                                                             else:
  1587                                                                 frsn = [0.0, 0.0, 0.0, 0.0]
  1588    197.1 MiB    -36.1 MiB       91310                       for i, fr in enumerate(frsn):
  1589    197.1 MiB    -28.9 MiB       73048                           self.sp_snc[i] -= (self.nupt[1, step] * fr)
  1590                                         
  1591    197.1 MiB     -7.2 MiB       18262                       idx = np.where(self.sp_snc < 0.0)[0]
  1592    197.1 MiB     -7.2 MiB       18262                       if len(idx) > 0:
  1593                                                                 self.sp_snc[idx] = 0.0
  1594                                         
  1595    197.1 MiB     -7.2 MiB       18262                       self.sp_organic_n = self.sp_snc[:2].sum()
  1596    197.1 MiB     -7.2 MiB       18262                       self.sp_sorganic_n = self.sp_snc[2:4].sum()
  1597                                         
  1598                                                             # P
  1599    197.1 MiB     -7.2 MiB       18262                       total_op = self.sp_snc[4:].sum()
  1600    197.1 MiB     -7.2 MiB       18262                       if total_op > 0.0 and np.isfinite(total_op):
  1601    197.1 MiB    -50.6 MiB      127834                           frsp = [i / total_op for i in self.sp_snc[4:]]
  1602                                                             else:
  1603                                                                 frsp = [0.0, 0.0, 0.0, 0.0]
  1604    197.1 MiB    -36.1 MiB       91310                       for i, fr in enumerate(frsp):
  1605    197.1 MiB    -28.9 MiB       73048                           self.sp_snc[i + 4] -= (self.pupt[2, step] * fr)
  1606                                         
  1607    197.1 MiB     -7.2 MiB       18262                       idx = np.where(self.sp_snc < 0.0)[0]
  1608    197.1 MiB     -7.2 MiB       18262                       if len(idx) > 0:
  1609                                                                 self.sp_snc[idx] = 0.0
  1610                                         
  1611    197.1 MiB     -7.2 MiB       18262                       self.sp_organic_p = self.sp_snc[4:6].sum()
  1612    197.1 MiB     -7.2 MiB       18262                       self.sp_sorganic_p = self.sp_snc[6:].sum()
  1613                                                         # END SOIL NUTRIENT DYNAMICS
  1614                                         
  1615    197.1 MiB     -7.2 MiB       18262                   if save:
  1616                                                             # Plant uptake and Carbon costs of nutrient uptake
  1617                                                             self.storage_pool[:, step] = masked_mean_2D(self.metacomm.mask, storage_pool.astype(np.float32))
  1618                                                             self.carbon_costs[step] = masked_mean(self.metacomm.mask, cc)
  1619                                                             self.tsoil.append(self.soil_temp)
  1620                                                             self.photo[step] = masked_mean(self.metacomm.mask, photo)
  1621                                                             self.aresp[step] = masked_mean(self.metacomm.mask, aresp)
  1622                                                             self.npp[step] = masked_mean(self.metacomm.mask, npp)
  1623                                                             self.rnpp[step] = masked_mean(self.metacomm.mask, rnpp_mt)
  1624                                                             self.lai[step] = masked_mean(self.metacomm.mask, lai)
  1625                                                             self.rcm[step] = masked_mean(self.metacomm.mask, rcm)
  1626                                                             self.f5[step] = masked_mean(self.metacomm.mask, f5)
  1627                                                             self.rm[step] = masked_mean(self.metacomm.mask, rm)
  1628                                                             self.rg[step] = masked_mean(self.metacomm.mask, rg)
  1629                                                             self.wue[step] = masked_mean(self.metacomm.mask, wue)
  1630                                                             self.cue[step] = masked_mean(self.metacomm.mask, cue)
  1631                                                             self.carbon_deficit[step] = masked_mean(self.metacomm.mask, carbon_deficit)
  1632                                                             self.vcmax[step] = masked_mean(self.metacomm.mask, vcmax)
  1633                                                             self.specific_la[step] = masked_mean(self.metacomm.mask, specific_la)
  1634                                                             self.hresp[step] = soil_out['hr']
  1635                                                             self.csoil[:, step] = soil_out['cs']
  1636                                                             self.wsoil[step] = self.swp.calc_total_water()
  1637                                                             self.inorg_n[step] = self.sp_in_n
  1638                                                             self.inorg_p[step] = self.sp_in_p
  1639                                                             self.sorbed_n[step] = self.sp_so_n
  1640                                                             self.sorbed_p[step] = self.sp_so_p
  1641                                                             self.snc[:, step] = soil_out['snc']
  1642                                                             self.nmin[step] = self.sp_available_n
  1643                                                             self.pmin[step] = self.sp_available_p
  1644                                                             self.ls[step] = living_pls
  1645                                         
  1646                                                     # <- Out of the daily loop
  1647                                                     # Save the spin data
  1648                                                     sv: Thread
  1649    197.1 MiB      0.0 MiB           1               if save:
  1650                                                         if s > 0:
  1651                                                             sv.join()  # Wait for the previous thread to finish
  1652                                                             self.flush_data = None
  1653                                                         self.executed_iterations.append((start_date, end_date))
  1654                                                         self.flush_data = self._flush_output(
  1655                                                             'spin', (self.start_index, self.end_index))
  1656                                                         sv = Thread(target=self._save_output, args=(self.flush_data,))
  1657                                                         sv.start()
  1658                                                 # <- Out of spin loop
  1659                                                 # Manage the last thread
  1660    197.7 MiB      0.0 MiB           1           if save:
  1661                                                     sv.join()  # Wait for the last thread to finish
  1662                                                     self.flush_data = None
  1663                                         
  1664                                         
  1665                                                 # Restablish new communities in the end, if applicable
  1666    197.7 MiB      0.0 MiB           1           if kill_and_reset:
  1667                                                     assert not save, "Cannot save data when resetting communities"
  1668                                                     for community in self.metacomm:
  1669                                                         # with lock:
  1670                                                         new_life_strategies = self.get_from_main_array(community.npls)
  1671                                                         community.restore_from_main_table(new_life_strategies)
  1672                                                     # Here we update the metacomm mask to ensure that all communities are active again
  1673                                                     self.metacomm.update_mask()
  1674                                         
  1675    197.7 MiB      0.0 MiB           1           return None


Filename: C:\Users\darel\OneDrive\Desktop\CAETE\src\caete.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
  1013    197.7 MiB    197.7 MiB           1       @profile
  1014                                             # @timer
  1015                                             def run_gridcell(self,
  1016                                                           start_date: str,
  1017                                                           end_date: str,
  1018                                                           spinup: int = 0,
  1019                                                           fixed_co2_atm_conc: Optional[str] | Optional[int] | Optional[float] = None,
  1020                                                           save: bool = True,
  1021                                                           nutri_cycle: bool = True,
  1022                                                           afex: bool = False,
  1023                                                           reset_community: bool = False,
  1024                                                           kill_and_reset: bool = False,
  1025                                                           env_filter: bool = False,
  1026                                                           process_limitation: bool = False,
  1027                                                           verbose: bool = False):
  1028                                                 """
  1029                                                 Run the model for a grid cell.
  1030                                         
  1031                                                 CAETÊ-DVM execution in the start_date - end_date period, can be used for spinup or transient runs.
  1032                                         
  1033                                                 Args:
  1034                                                     start_date (str): Start date for model execution in "yyyymmdd" format.
  1035                                                     end_date (str): End date for model execution in "yyyymmdd" format.
  1036                                                     spinup (int, optional): Number of repetitions in spinup. Set to 0 for a transient run between start_date and end_date. Default is 0.
  1037                                                     fixed_co2_atm_conc (Optional[Union[str, int, float]]): Fixed atmospheric CO2 concentration. If None, use dynamic CO2 levels from a predefined file. If a string with a year (e.g., "1987") That year's value in the provided file will be used. Use a float to set a fixed level in ppm. Default is None.
  1038                                                     save (bool, optional): Whether to save the results. Default is True.
  1039                                                     nutri_cycle (bool, optional): Whether to include nutrient cycling in the model. Default is True.
  1040                                                     afex (bool, optional): Whether to apply nutrient addition to soil in the model. Default is False.
  1041                                                     reset_community (bool, optional): Whether to restart a new community if there are not viable PLS. Default is False.
  1042                                                     kill_and_reset (bool, optional): Whether to kill and reset the community structure at the end of execution (only CVEG pools and PLS IDs). Default is False.
  1043                                                     env_filter (bool, optional): Whether to apply environmental filtering (Include new PLS periodically) []. Default is False.
  1044                                                     verbose (bool, optional): Whether to print detailed logs during execution. Default is False.
  1045                                         
  1046                                                 Returns:
  1047                                                     None
  1048                                         
  1049                                                 Notes:
  1050                                                     - If reset_community is true a new community will be set (reset) when there is no PLSs remaining.
  1051                                                     - If the kill_and_reset is true, after n spins (integer given by spinup parameter - i.e. in the end
  1052                                                       of function execution) all the communities in a gridcell are reset. The reset_community and
  1053                                                       kill_and_reset  arguments are not mutually exclusive. You can use both as true at the same time.
  1054                                                     - The env_filter argument is used to define if new unique PLSs from the main table will be
  1055                                                       seed in the communities that have free slots (PLSs that are not producing). At the moment, the
  1056                                                       interval for the env_filter to add a new PLS to the community is set to  ~15 days.
  1057                                                       If env filter argument is true, then the reset_community argument will have a very low
  1058                                                       probability to trigger a reset because the communities will be constantly filled with new PLS.
  1059                                                       Nonetheless, the reset_community argument will still be able to trigger a reset if the community loses all PLSs.
  1060                                                       With the probability of a reset_community increasing as the interval between new seeds increases. The parameter doy_months
  1061                                                       in the config file (caete.toml) is used to define the interval for the env_filter to add a new PLS to the community.
  1062                                         
  1063                                                       TODO: Implement a more flexible way to define the interval for
  1064                                                             the env_filter to add a new PLS to the community.
  1065                                                 """
  1066                                         
  1067    197.7 MiB      0.0 MiB           1           assert not fixed_co2_atm_conc or\
  1068                                                     isinstance(fixed_co2_atm_conc, str) or\
  1069                                                     fixed_co2_atm_conc > 0,\
  1070                                                         "A fixed value for ATM[CO2] must be a positive number greater than zero or a proper string with the year - e.g., 'yyyy'"
  1071                                         
  1072                                         
  1073                                                 # Define start and end dates (read parameters)
  1074    197.7 MiB      0.0 MiB           1           start = parse_date(start_date)
  1075    197.7 MiB      0.0 MiB           1           end = parse_date(end_date)
  1076                                         
  1077                                                 # Check dates
  1078    197.7 MiB      0.0 MiB           1           assert start < end, "Start date must be before end date"
  1079    197.7 MiB      0.0 MiB           1           assert start >= self.start_date, "initial date out of bounds for the time array"
  1080    197.7 MiB      0.0 MiB           1           assert end <= self.end_date, f"Final date out of bounds for the time array"
  1081                                         
  1082                                         
  1083                                                 # Define time index bounds for this run
  1084                                                 # During a run we are in general using a slice ov the available time span
  1085                                                 # to run the model. For example, we can run the model for a year or a decade
  1086                                                 # at the begining of the input data time series to spin up. This slice is defined
  1087                                                 # by the start and end dates provided in the arguments. Here we get the indices.
  1088    197.7 MiB      0.0 MiB           1           self.start_index = int(cftime.date2num(start, self.time_unit, self.calendar))
  1089    197.7 MiB      0.0 MiB           1           self.end_index =   int(cftime.date2num(end, self.time_unit, self.calendar))
  1090                                         
  1091                                                 # Find the indices in the time array [used to slice the timeseries with driver data  - tas, pr, etc.]
  1092    197.7 MiB      0.0 MiB           1           lower_bound, upper_bound = self.find_index(self.start_index, self.end_index)
  1093                                         
  1094                                                 # Define the time steps range (days)
  1095    197.7 MiB      0.0 MiB           1           steps = np.arange(lower_bound, upper_bound + 1, dtype=np.int64)
  1096                                         
  1097                                                 # Define the number of repetitions for the spinup
  1098    197.7 MiB      0.0 MiB           1           spin = 1 if spinup == 0 else spinup
  1099                                         
  1100                                                 # Define the AFEX mode
  1101    197.7 MiB      0.0 MiB           1           afex_mode = self.afex_config.afex_mode # type: ignore
  1102                                         
  1103                                                 # Slice&Catch climatic input and make conversions
  1104    197.7 MiB      0.0 MiB           1           cv = self.config.conversion_factors_isimip # type: ignore
  1105                                         
  1106                                         
  1107    197.7 MiB      0.0 MiB           1           if self.config.input_handler.input_method == "ih" and self.config.input_handler.input_type == "netcdf":
  1108                                                     # Variables in Netcdf files are already in proprer units
  1109    197.7 MiB      0.0 MiB           1               temp: NDArray[np.float32] = self.tas[lower_bound: upper_bound + 1]   # Air temp: model uses °C
  1110    197.7 MiB      0.0 MiB           1               prec: NDArray[np.float32] = self.pr[lower_bound: upper_bound + 1]    # Precipitation: model uses  mm/day
  1111    197.7 MiB      0.0 MiB           1               p_atm: NDArray[np.float32] = self.ps[lower_bound: upper_bound + 1]   # Atmospheric pressure: model uses hPa
  1112    197.7 MiB      0.0 MiB           1               ipar: NDArray[np.float32] = self.rsds[lower_bound: upper_bound + 1]  # PAR: model uses  mol(photons) m-2 s-1
  1113    197.7 MiB      0.0 MiB           1               ru: NDArray[np.float32] = self.rhs[lower_bound: upper_bound + 1]     # Relative humidity: model uses 0-1
  1114                                                 else:
  1115                                                     temp: NDArray[np.float32] = self.tas[lower_bound: upper_bound + 1] - cv.tas    # Air temp: model uses °C
  1116                                                     prec: NDArray[np.float32] = self.pr[lower_bound: upper_bound + 1] * cv.pr      # Precipitation: model uses  mm/day
  1117                                                     p_atm: NDArray[np.float32] = self.ps[lower_bound: upper_bound + 1] * cv.ps     # Atmospheric pressure: model uses hPa
  1118                                                     ipar: NDArray[np.float32] = self.rsds[lower_bound: upper_bound + 1] * cv.rsds  # PAR: model uses  mol(photons) m-2 s-1
  1119                                                     ru: NDArray[np.float32] = self.rhs[lower_bound: upper_bound + 1] * cv.rhs      # Relative humidity: model uses 0-1
  1120                                         
  1121                                                 # Define the daily values for co2 concentrations
  1122    197.7 MiB      0.0 MiB           1           co2_daily_values = np.zeros(steps.size, dtype=np.float32)
  1123                                         
  1124    197.7 MiB      0.0 MiB           1           if fixed_co2_atm_conc is None:
  1125                                                     # In this case, the co2 concentration will be updated daily.
  1126                                                     # We interpolate linearly between the yearly values of the atm co2 data
  1127    197.7 MiB      0.0 MiB           1               co2 = self.find_co2(start.year)
  1128    197.7 MiB      0.0 MiB           1               today = datetime(start.year, start.month, start.day, start.hour, start.minute, start.second)
  1129    197.7 MiB      0.0 MiB           1               time_step = timedelta(days=1) # Define the time step
  1130    197.7 MiB      0.0 MiB           1               today -= time_step # The first thing we do next is to add a day to the date. So we go back one day
  1131                                                     # Loop over the days and calculate the co2 concentration for each day
  1132    197.7 MiB      0.0 MiB       18263               for step in range(steps.size):
  1133    197.7 MiB      0.0 MiB       18262                   today += time_step
  1134    197.7 MiB      0.0 MiB       18262                   remaining = (datetime(today.year, 12, 31) - today).days + 1
  1135    197.7 MiB      0.0 MiB       18262                   daily_fraction = (self.find_co2(today.year + 1) - co2) / (remaining + 1)
  1136    197.7 MiB      0.0 MiB       18262                   co2 += daily_fraction
  1137    197.7 MiB      0.0 MiB       18262                   co2_daily_values[step] = co2
  1138                                                 elif isinstance(fixed_co2_atm_conc, int) or isinstance(fixed_co2_atm_conc, float):
  1139                                                     # In this case, the co2 concentration will be fixed according to the numeric value provided in the argument
  1140                                                     co2 = fixed_co2_atm_conc
  1141                                                     co2_daily_values += co2
  1142                                                 elif isinstance(fixed_co2_atm_conc, str):
  1143                                                     # In this case, the co2 concentration will be fixed
  1144                                                     # According to the year provided in the argument
  1145                                                     # as a string. Format "yyyy".
  1146                                                     try:
  1147                                                         co2_year = int(fixed_co2_atm_conc)
  1148                                                     except ValueError:
  1149                                                         raise ValueError(
  1150                                                             "The string(\"yyyy\") must be a number in the {self.start_date.year} - {self.end_date.year} interval")
  1151                                                     co2 = self.find_co2(co2_year)
  1152                                                     co2_daily_values += co2
  1153                                                 else:
  1154                                                     raise ValueError("Invalid value for fixed_co2_atm_conc")
  1155                                         
  1156                                                 # Define variables to track dates
  1157    197.7 MiB      0.0 MiB           1           first_day_of_simulation = datetime(start.year, start.month, start.day, start.hour, start.minute, start.second)
  1158                                                 # Define the time step
  1159    197.7 MiB      0.0 MiB           1           time_step = timedelta(days=1)
  1160                                         
  1161                                                 # Define the object to store the outputs from daily_budget
  1162    197.7 MiB      0.0 MiB           1           daily_output = DailyBudget()
  1163                                         
  1164                                                 # Start loops
  1165                                                 # This outer loop is used to run the model for a number
  1166                                                 # of times defined by the spinup argument. The model is
  1167                                                 # executed repeatedly between the start and end dates
  1168                                                 # provided in the arguments
  1169                                         
  1170    199.7 MiB      0.0 MiB           2           for s in range(spin):
  1171                                         
  1172    198.0 MiB      0.2 MiB           1               self._allocate_output(steps.size, self.metacomm.comm_npls, len(self.metacomm), save)
  1173                                         
  1174                                                     # Loop over the days
  1175    198.0 MiB      0.0 MiB           1               today = first_day_of_simulation
  1176                                         
  1177                                                     # Go back one day
  1178    198.0 MiB      0.0 MiB           1               today -= time_step
  1179                                         
  1180                                                     # Arrays to store & pass values for each community in a simulated day
  1181    198.0 MiB      0.0 MiB           1               sto =        np.zeros(shape=(3, self.metacomm.comm_npls), order='F')
  1182    198.0 MiB      0.0 MiB           1               cleaf_in =   np.zeros(self.metacomm.comm_npls, order='F')
  1183    198.0 MiB      0.0 MiB           1               cwood_in =   np.zeros(self.metacomm.comm_npls, order='F')
  1184    198.0 MiB      0.0 MiB           1               croot_in =   np.zeros(self.metacomm.comm_npls, order='F')
  1185    198.0 MiB      0.0 MiB           1               uptk_costs = np.zeros(self.metacomm.comm_npls, order='F')
  1186    198.0 MiB      0.0 MiB           1               rnpp_in =    np.zeros(self.metacomm.comm_npls, order='F')
  1187                                         
  1188                                                     # There are two modes of operation: save and not save.
  1189                                                     # In the save == False mode, the arrays are used to store the values that are
  1190                                                     # needed for model iteration, i.e., the values that are used in the next
  1191                                                     # time step. In the save mode, an extra number arrays is created to be used
  1192                                                     # to store the outputs.
  1193    198.0 MiB      0.0 MiB           1               xsize: int = len(self.metacomm) # Number of communities
  1194    198.0 MiB      0.0 MiB           1               evavg: NDArray[np.float32] = np.zeros(xsize, dtype=np.float32)
  1195    198.0 MiB      0.0 MiB           1               epavg: NDArray[np.float32] = np.zeros(xsize, dtype=np.float32)
  1196    198.0 MiB      0.0 MiB           1               rnpp_mt: NDArray[np.float32] = np.zeros(xsize, dtype=np.float32)
  1197                                         
  1198                                                     # We keep track of these to input in SOM dynamics later. They are used for output also
  1199    198.0 MiB      0.0 MiB           1               leaf_litter: NDArray[np.float32] = np.zeros(xsize, dtype=np.float32)
  1200    198.0 MiB      0.0 MiB           1               cwd: NDArray[np.float32] = np.zeros(xsize, dtype=np.float32)
  1201    198.0 MiB      0.0 MiB           1               root_litter: NDArray[np.float32] = np.zeros(xsize, dtype=np.float32)
  1202    198.0 MiB      0.0 MiB           1               lnc: NDArray[np.float32] = np.zeros(shape=(6, xsize), dtype=np.float32)
  1203                                                     # This is added to leaf litter pool (that is basicaly a fast SOM pool)
  1204    198.0 MiB      0.0 MiB           1               c_to_nfixers: NDArray[np.float32]= np.zeros(xsize, dtype=np.float32)
  1205    198.0 MiB      0.0 MiB           1               nupt = np.zeros(shape=(2, xsize), dtype=np.float32)
  1206    198.0 MiB      0.0 MiB           1               pupt = np.zeros(shape=(3, xsize), dtype=np.float32)
  1207                                         
  1208    198.0 MiB      0.0 MiB           1               if save:
  1209    198.0 MiB      0.0 MiB           1                   cc = np.zeros(xsize, dtype=np.float32)
  1210    198.0 MiB      0.0 MiB           1                   photo = np.zeros(xsize, dtype=np.float32)
  1211    198.0 MiB      0.0 MiB           1                   aresp = np.zeros(xsize, dtype=np.float32)
  1212    198.0 MiB      0.0 MiB           1                   npp = np.zeros(xsize, dtype=np.float32)
  1213    198.0 MiB      0.0 MiB           1                   lai = np.zeros(xsize, dtype=np.float32)
  1214    198.0 MiB      0.0 MiB           1                   rcm = np.zeros(xsize, dtype=np.float32)
  1215    198.0 MiB      0.0 MiB           1                   f5 = np.zeros(xsize, dtype=np.float32)
  1216    198.0 MiB      0.0 MiB           1                   rm = np.zeros(xsize, dtype=np.float32)
  1217    198.0 MiB      0.0 MiB           1                   rg = np.zeros(xsize, dtype=np.float32)
  1218    198.0 MiB      0.0 MiB           1                   wue = np.zeros(xsize, dtype=np.float32)
  1219    198.0 MiB      0.0 MiB           1                   cue = np.zeros(xsize, dtype=np.float32)
  1220    198.0 MiB      0.0 MiB           1                   carbon_deficit = np.zeros(xsize, dtype=np.float32)
  1221    198.0 MiB      0.0 MiB           1                   vcmax = np.zeros(xsize, dtype=np.float32)
  1222    198.0 MiB      0.0 MiB           1                   specific_la = np.zeros(xsize, dtype=np.float32)
  1223    198.0 MiB      0.0 MiB           1                   storage_pool = np.zeros(shape=(3, xsize))
  1224                                         
  1225    198.0 MiB      0.0 MiB           1                   if process_limitation:
  1226                                                             lim_status_y_leaf = np.ma.masked_all((xsize, self.metacomm.comm_npls, 366), dtype=np.int8)
  1227                                                             lim_status_y_stem = np.ma.masked_all((xsize, self.metacomm.comm_npls, 366), dtype=np.int8)
  1228                                                             lim_status_y_root = np.ma.masked_all((xsize, self.metacomm.comm_npls, 366), dtype=np.int8)
  1229                                                             uptake_strategy_n = np.ma.masked_all((xsize, self.metacomm.comm_npls, 366), dtype=np.int8)
  1230                                                             uptake_strategy_p = np.ma.masked_all((xsize, self.metacomm.comm_npls, 366), dtype=np.int8)
  1231                                         
  1232                                                     # <- Daily loop
  1233    199.6 MiB      0.0 MiB       18263               for step in range(steps.size):
  1234    199.6 MiB      0.0 MiB       18262                   today += time_step
  1235    199.6 MiB      0.0 MiB       18262                   julian_day = today.timetuple().tm_yday
  1236                                         
  1237                                                         # Get the co2 concentration for the day
  1238    199.6 MiB      0.0 MiB       18262                   co2 = co2_daily_values[step]
  1239                                                         # Update soil temperature
  1240    199.6 MiB      0.0 MiB       18262                   self.soil_temp = st.soil_temp(self.soil_temp, temp[step])
  1241                                         
  1242                                                         # AFEX
  1243    199.6 MiB      0.0 MiB       18262                   if afex and julian_day == 365:
  1244                                                             self.add_soil_nutrients(afex_mode)
  1245                                         
  1246                                                         # Loop over communities
  1247    199.6 MiB      0.0 MiB       18262                   living_pls = 0 # Sum of living PLS in the communities
  1248    199.6 MiB      0.0 MiB       36524                   for i, community in enumerate(self.metacomm):
  1249                                                             # if i >= len(self.metacomm):
  1250                                                             #     break
  1251                                                             # if community.masked:
  1252                                                             #     # skip this one
  1253                                                             #     continue
  1254    199.6 MiB      0.0 MiB       18262                       sto[0, :] = inflate_array(community.npls, community.vp_sto[0, :], community.vp_lsid)
  1255    199.6 MiB      0.0 MiB       18262                       sto[1, :] = inflate_array(community.npls, community.vp_sto[1, :], community.vp_lsid)
  1256    199.6 MiB      0.0 MiB       18262                       sto[2, :] = inflate_array(community.npls, community.vp_sto[2, :], community.vp_lsid)
  1257                                         
  1258    199.6 MiB      0.0 MiB       18262                       cleaf_in[:] = inflate_array(community.npls, community.vp_cleaf, community.vp_lsid)
  1259    199.6 MiB      0.0 MiB       18262                       cwood_in[:] = inflate_array(community.npls, community.vp_cwood, community.vp_lsid)
  1260    199.6 MiB      0.0 MiB       18262                       croot_in[:] = inflate_array(community.npls, community.vp_croot, community.vp_lsid)
  1261    199.6 MiB      0.0 MiB       18262                       uptk_costs[:] = inflate_array(community.npls, community.sp_uptk_costs, community.vp_lsid)
  1262    199.6 MiB      0.0 MiB       18262                       rnpp_in[:] = inflate_array(community.npls, community.construction_npp, community.vp_lsid)
  1263                                         
  1264    199.6 MiB      0.0 MiB       18262                       ton = self.sp_organic_n #+ self.sp_sorganic_n
  1265    199.6 MiB      0.0 MiB       18262                       top = self.sp_organic_p #+ self.sp_sorganic_p
  1266                                         
  1267                                                             # Community daily budget calculation
  1268    199.6 MiB      0.0 MiB       36524                       out = model.daily_budget(community.pls_array, self.wp_water_upper_mm,
  1269    199.6 MiB      0.0 MiB       18262                                               self.wp_water_lower_mm, self.soil_temp, temp[step],
  1270    199.6 MiB      0.0 MiB       18262                                               p_atm[step], ipar[step], ru[step], self.sp_available_n,
  1271    199.6 MiB      0.0 MiB       18262                                               self.sp_available_p, ton, top, self.sp_organic_p,
  1272    199.6 MiB      0.0 MiB       18262                                               co2, sto, cleaf_in, cwood_in, croot_in, uptk_costs,self.wmax_mm,
  1273    199.6 MiB      0.0 MiB       18262                                               rnpp_in)
  1274                                         
  1275                                                             # get daily budget results
  1276    199.6 MiB      0.0 MiB       18262                       daily_output.update(out)
  1277                                         
  1278                                                             # Update the community status
  1279    199.6 MiB      0.0 MiB       18262                       community.update_lsid(daily_output.ocpavg)
  1280                                         
  1281                                                             # Abort community if no PLSs are left while saving the spin
  1282    199.6 MiB      0.0 MiB       18262                       if community.masked and save:
  1283                                                                 continue
  1284                                         
  1285    199.6 MiB      0.0 MiB       18262                       community.ls = community.vp_lsid.size
  1286                                                             # # Restore or seed PLS
  1287    199.6 MiB      0.0 MiB       18262                       if env_filter and (community.ls < self.metacomm.comm_npls) and not save:
  1288                                                                 if julian_day in self.doy_months:
  1289                                                                     new_id, new_PLS = community.get_unique_pls(self.get_from_main_array)
  1290                                                                     community.seed_pls(new_id, new_PLS, daily_output.cleafavg_pft,
  1291                                                                                        daily_output.cfrootavg_pft, daily_output.cawoodavg_pft)
  1292                                                                     if verbose: print(f"PLS seed in Community {i}: Gridcell: {self.lat} °N, {self.lon} °E: In spin:{s}, step:{step}")
  1293                                         
  1294                                                                     daily_output.ocpavg = pft_area_frac64(daily_output.cleafavg_pft,
  1295                                                                                                     daily_output.cfrootavg_pft,
  1296                                                                                                     daily_output.cawoodavg_pft)
  1297                                                                     community.update_lsid(daily_output.ocpavg)
  1298                                                                     community.ls = community.vp_lsid.size
  1299                                                                 # endif
  1300                                         
  1301                                         
  1302    199.6 MiB      0.0 MiB       18262                       community.vp_ocp = daily_output.ocpavg[community.vp_lsid]
  1303    199.6 MiB      0.0 MiB       18262                       community.vp_cleaf = daily_output.cleafavg_pft[community.vp_lsid]
  1304    199.6 MiB      0.0 MiB       18262                       community.vp_cwood = daily_output.cawoodavg_pft[community.vp_lsid]
  1305    199.6 MiB      0.0 MiB       18262                       community.vp_croot = daily_output.cfrootavg_pft[community.vp_lsid]
  1306    199.6 MiB      0.0 MiB       18262                       community.vp_sto = daily_output.stodbg[:, community.vp_lsid].astype('float32')
  1307    199.6 MiB      0.0 MiB       18262                       community.sp_uptk_costs = daily_output.npp2pay[community.vp_lsid]
  1308    199.6 MiB      0.0 MiB       18262                       community.construction_npp = daily_output.rnpp_out[community.vp_lsid]
  1309    199.6 MiB      0.0 MiB       18262                       living_pls += community.ls
  1310                                                             # print(f"Community storage: {community.vp_sto[0, :]}")
  1311                                                             # print(f"Sto_budget_out {daily_output.stodbg[0, :]}")
  1312                                         
  1313                                                             # Limiting nutrient organization:
  1314                                                             # dim1 = leaf wood root, code: 1=N 2=P 4=N,COLIM 5=P,COLIM 6=COLIM 0=NOLIM
  1315    199.6 MiB      0.0 MiB       18262                       if save:
  1316    199.6 MiB      0.0 MiB       18262                           if process_limitation:
  1317                                                                     lim_status_y_leaf[i, :, julian_day - 1] = daily_output.limitation_status[0,:]# type: ignore
  1318                                                                     lim_status_y_stem[i, :, julian_day - 1] = daily_output.limitation_status[1,:]# type: ignore
  1319                                                                     lim_status_y_root[i, :, julian_day - 1] = daily_output.limitation_status[2,:]# type: ignore
  1320                                                                     uptake_strategy_n[i, :, julian_day - 1] = daily_output.uptk_strat[0,:]# type: ignore
  1321                                                                     uptake_strategy_p[i, :, julian_day - 1] = daily_output.uptk_strat[1,:]# type: ignore
  1322                                         
  1323    199.6 MiB      0.0 MiB       18262                           community.anpp += cw_mean(community.vp_ocp, community.construction_npp.astype(np.float32))
  1324    199.6 MiB      0.0 MiB       18262                           community.uptake_costs += cw_mean(community.vp_ocp, community.sp_uptk_costs.astype(np.float32))
  1325                                         
  1326    199.6 MiB      0.0 MiB       18262                       if save and julian_day == 365:
  1327    199.6 MiB      0.0 MiB          50                           community.cleaf = cw_mean(community.vp_ocp, community.vp_cleaf.astype(np.float32))
  1328    199.6 MiB      0.0 MiB          50                           community.cwood = cw_mean(community.vp_ocp, community.vp_cwood.astype(np.float32))
  1329    199.6 MiB      0.0 MiB          50                           community.croot = cw_mean(community.vp_ocp, community.vp_croot.astype(np.float32))
  1330    199.6 MiB      0.0 MiB          50                           community.csto = cw_mean(community.vp_ocp, community.vp_sto[0, :])
  1331    199.6 MiB      0.5 MiB          50                           community.shannon_diversity = shannon_diversity(community.vp_ocp)
  1332    199.6 MiB      0.0 MiB          50                           community.shannon_entropy = shannon_entropy(community.vp_ocp)
  1333    199.6 MiB      0.1 MiB          50                           community.shannon_evenness = shannon_evenness(community.vp_ocp)
  1334                                         
  1335                                                                 # process limitation data
  1336                                                                 # Filter non living PLS from the limitation status
  1337    199.6 MiB      0.0 MiB          50                           if process_limitation:
  1338                                                                     _data_leaf = lim_status_y_leaf[i, [community.vp_lsid], :] # type: ignore
  1339                                                                     _data_stem = lim_status_y_stem[i, [community.vp_lsid], :] # type: ignore
  1340                                                                     _data_root = lim_status_y_root[i, [community.vp_lsid], :] # type: ignore
  1341                                         
  1342                                                                     _data_uptake_n = uptake_strategy_n[i, [community.vp_lsid], :]# type: ignore
  1343                                                                     _data_uptake_p = uptake_strategy_p[i, [community.vp_lsid], :]# type: ignore
  1344                                         
  1345                                                                     # Loop over the living PLS to get the unique values and counts
  1346                                                                     pls_lim_leaf = []
  1347                                                                     pls_lim_stem = []
  1348                                                                     pls_lim_root = []
  1349                                                                     pls_uptake_n = []
  1350                                                                     pls_uptake_p = []
  1351                                         
  1352                                                                     for k in range(community.vp_lsid.size):
  1353                                                                         # Get the unique values and counts for leaf limitation
  1354                                                                         unique, counts = np.unique(_data_leaf[0, k, :], return_counts=True)
  1355                                                                         unique = unique.data[unique.mask == False] # type: ignore
  1356                                                                         pls_lim_leaf.append((unique, counts[:unique.size])) # type: ignore
  1357                                         
  1358                                                                         # Stem limitation
  1359                                                                         unique, counts = np.unique(_data_stem[0, k, :], return_counts=True)
  1360                                                                         unique = unique.data[unique.mask == False] # type: ignore
  1361                                                                         pls_lim_stem.append((unique, counts[:unique.size])) # type: ignore
  1362                                         
  1363                                                                         # Root limitation
  1364                                                                         unique, counts = np.unique(_data_root[0, k, :], return_counts=True)
  1365                                                                         unique = unique.data[unique.mask == False]
  1366                                                                         pls_lim_root.append((unique, counts[:unique.size])) # type: ignore
  1367                                         
  1368                                                                         # Uptake strategy N
  1369                                                                         unique, counts = np.unique(_data_uptake_n[0, k, :], return_counts=True)
  1370                                                                         unique = unique.data[unique.mask == False] # type: ignore
  1371                                                                         pls_uptake_n.append((unique, counts[:unique.size])) # type: ignore
  1372                                         
  1373                                                                         # Uptake strategy P
  1374                                                                         unique, counts = np.unique(_data_uptake_p[0, k, :], return_counts=True)
  1375                                                                         unique = unique.data[unique.mask == False]  # type: ignore
  1376                                                                         pls_uptake_p.append((unique, counts[:unique.size])) # type: ignore
  1377                                         
  1378                                                                     community.limitation_status_leaf = pls_lim_leaf
  1379                                                                     community.limitation_status_wood = pls_lim_stem
  1380                                                                     community.limitation_status_root = pls_lim_root
  1381                                                                     community.uptake_strategy_n = pls_uptake_n
  1382                                                                     community.uptake_strategy_p = pls_uptake_p
  1383                                         
  1384                                                                     # Reset the limitation masked arrays
  1385                                                                     lim_status_y_leaf.mask[i, :, :] = np.ones((self.metacomm.comm_npls, 366), dtype=bool) # type: ignore
  1386                                                                     lim_status_y_stem.mask[i, :, :] = np.ones((self.metacomm.comm_npls, 366), dtype=bool) # type: ignore
  1387                                                                     lim_status_y_root.mask[i, :, :] = np.ones((self.metacomm.comm_npls, 366), dtype=bool) # type: ignore
  1388                                                                     uptake_strategy_n.mask[i, :, :] = np.ones((self.metacomm.comm_npls, 366), dtype=bool) # type: ignore
  1389                                                                     uptake_strategy_p.mask[i, :, :] = np.ones((self.metacomm.comm_npls, 366), dtype=bool) # type: ignore
  1390                                                                 else:
  1391    199.6 MiB      0.0 MiB          50                               pass
  1392                                         
  1393    199.6 MiB      0.0 MiB       18262                       if community.vp_lsid.size < 1:
  1394                                                                 if verbose: print(f"Empty community {i}: Gridcell: {self.lat} °N, {self.lon} °E: In spin:{s}, step:{step}")
  1395                                                                 if reset_community:
  1396                                                                     assert not save, "Cannot save data when resetting communities"
  1397                                                                     if verbose: print(f"Reseting community {i}: Gridcell: {self.lat} °N, {self.lon} °E: In spin:{s}, step:{step}")
  1398                                         
  1399                                                                     new_life_strategies = self.get_from_main_array(community.npls)
  1400                                                                     community.restore_from_main_table(new_life_strategies)
  1401                                                                     # continue
  1402                                         
  1403                                                                 else:
  1404                                                                     # In the transiant run - i.e., when reset_community is false and
  1405                                                                     # kill_and_reset is false; we mask the community if there is no PLS
  1406                                                                     self.metacomm.mask[i] = np.int8(1)
  1407                                                                     # Set mask to true for this community, will not run in the next steps
  1408                                                                     # Set annual values to zero
  1409                                                                     community.masked = np.int8(1)
  1410                                                                     community.cleaf = np.float32(0.0)
  1411                                                                     community.cwood = np.float32(0.0)
  1412                                                                     community.croot = np.float32(0.0)
  1413                                                                     community.csto  = np.float32(0.0)
  1414                                                                     community.shannon_diversity = -9999.0
  1415                                                                     community.shannon_entropy = -9999.0
  1416                                                                     community.shannon_evenness = -9999.0
  1417                                                                     # if the reset_community is true
  1418                                                                     # continue # cycle
  1419                                         
  1420                                                             # Store values for each community
  1421    199.6 MiB      0.0 MiB       18262                       rnpp_mt[i] = cw_mean(community.vp_ocp, community.construction_npp.astype(np.float32)) # Community Weighted rNPP
  1422    199.6 MiB      0.0 MiB       18262                       leaf_litter[i] = daily_output.litter_l
  1423    199.6 MiB      0.0 MiB       18262                       root_litter[i] = daily_output.litter_fr
  1424    199.6 MiB      0.0 MiB       18262                       cwd[i] = daily_output.cwd
  1425    199.6 MiB      0.0 MiB       18262                       lnc[:, i] = daily_output.lnc.astype(np.float32)
  1426    199.6 MiB      0.0 MiB       18262                       c_to_nfixers[i] = daily_output.cp[3]
  1427    199.6 MiB      0.0 MiB       18262                       evavg[i] = daily_output.evavg
  1428    199.6 MiB      0.0 MiB       18262                       epavg[i] = daily_output.epavg
  1429    199.6 MiB      0.0 MiB       18262                       nupt[:, i] = daily_output.nupt #type: ignore
  1430    199.6 MiB      0.0 MiB       18262                       pupt[:, i] = daily_output.pupt #type: ignore
  1431                                         
  1432    199.6 MiB      0.0 MiB       18262                       if save:
  1433    199.6 MiB      0.0 MiB       18262                           cc[i] = daily_output.c_cost_cwm #type: ignore
  1434    199.6 MiB      0.0 MiB       18262                           npp[i] = daily_output.nppavg #type: ignore
  1435    199.6 MiB      0.0 MiB       18262                           photo[i] = daily_output.phavg #type: ignore
  1436    199.6 MiB      0.0 MiB       18262                           aresp[i] = daily_output.aravg #type: ignore
  1437    199.6 MiB      0.0 MiB       18262                           lai[i] = daily_output.laiavg #type: ignore
  1438    199.6 MiB      0.0 MiB       18262                           rcm[i] = daily_output.rcavg #type: ignore
  1439    199.6 MiB      0.0 MiB       18262                           f5[i] = daily_output.f5avg #type: ignore
  1440    199.6 MiB      0.0 MiB       18262                           rm[i] = daily_output.rmavg #type: ignore
  1441    199.6 MiB      0.0 MiB       18262                           rg[i] = daily_output.rgavg #type: ignore
  1442    199.6 MiB      0.0 MiB       18262                           wue[i] = daily_output.wueavg #type: ignore
  1443    199.6 MiB      0.0 MiB       18262                           cue[i] = daily_output.cueavg #type: ignore
  1444    199.6 MiB      0.0 MiB       18262                           carbon_deficit[i] = daily_output.c_defavg #type: ignore
  1445    199.6 MiB      0.0 MiB       18262                           vcmax[i] = daily_output.vcmax #type: ignore
  1446    199.6 MiB      0.0 MiB       18262                           specific_la[i] = daily_output.specific_la #type: ignore
  1447                                         
  1448    199.6 MiB      0.0 MiB       73048                           for j in range(daily_output.stodbg.shape[0]):
  1449    199.6 MiB      0.0 MiB       54786                               storage_pool[j, i] = cw_mean(community.vp_ocp, community.vp_sto[j, :]) #type: ignore
  1450                                         
  1451                                                         #<- Out of the community loop
  1452                                                         # Save annual state of the metacommunity
  1453    199.6 MiB      0.0 MiB       18262                   if save:
  1454    199.6 MiB      0.0 MiB       18262                       if julian_day == 365:
  1455    199.6 MiB      0.0 MiB          50                           y = today.year
  1456                                                                 # m = today.month
  1457                                                                 # d = today.day
  1458    199.6 MiB      0.0 MiB          50                           filename = self.out_dir/f"metacommunity_{y}.pkz"
  1459                                                                 # filename = self.out_dir/f"metacommunity_{d}{m}{y}.pkz"
  1460    199.6 MiB      0.6 MiB          50                           self.metacomm.save_state(filename, y, process_limitation)
  1461    199.6 MiB      0.0 MiB          50                           self.metacomm_output[y] = filename
  1462                                         
  1463    199.6 MiB      0.0 MiB         100                           for community in self.metacomm:
  1464                                                                     # Set annual accumulators to zero
  1465    199.6 MiB      0.0 MiB          50                               community.anpp = np.float32(0.0)
  1466    199.6 MiB      0.0 MiB          50                               community.uptake_costs = np.float32(0.0)
  1467                                         
  1468                                                         # ------------
  1469                                                         # Evapotranspiration
  1470    199.6 MiB      0.0 MiB       18262                   et = masked_mean(self.metacomm.mask, evavg) #evavg.mean()
  1471                                                         ## Canopy-atmosphere coupling [EXPERIMENTAL]
  1472                                                         # vpd = m.vapor_p_deficit(temp[step], ru[step])
  1473                                                         # et_pot = masked_mean(self.metacomm.mask, np.array(epavg).astype(np.float32)) #epavg.mean()
  1474                                                         # self.evapm[step] = atm_canopy_coupling(et_pot, et, temp[step], vpd)
  1475    199.6 MiB      0.0 MiB       18262                   self.evapm[step] = et
  1476                                         
  1477                                                         # Update water pools
  1478                                         
  1479    199.6 MiB      0.0 MiB       18262                   self.runom[step] = self.swp._update_pool(prec[step], self.evapm[step])
  1480    199.6 MiB      0.0 MiB       18262                   self.swp.w1 = 0.0 if self.swp.w1 < 0.0 else self.swp.w1
  1481    199.6 MiB      0.0 MiB       18262                   self.swp.w2 = 0.0 if self.swp.w2 < 0.0 else self.swp.w2
  1482    199.6 MiB      0.0 MiB       18262                   self.wp_water_upper_mm = self.swp.awc1
  1483    199.6 MiB      0.0 MiB       18262                   self.wp_water_lower_mm = self.swp.awc2
  1484    199.6 MiB      0.0 MiB       18262                   wtot = self.swp.w1 + self.swp.w2
  1485                                         
  1486                                                         # Update cflux to the soil for output, mean values over the communities
  1487                                                         # Values are also used to update SOM dynamics
  1488    199.6 MiB      0.0 MiB       36524                   self.litter_l[step] = masked_mean(self.metacomm.mask, leaf_litter) +\
  1489    199.6 MiB      0.0 MiB       18262                                         masked_mean(self.metacomm.mask, c_to_nfixers)
  1490    199.6 MiB      0.0 MiB       18262                   self.cwd[step] = masked_mean(self.metacomm.mask, cwd)
  1491    199.6 MiB      0.0 MiB       18262                   self.litter_fr[step] = masked_mean(self.metacomm.mask, root_litter)
  1492    199.6 MiB      0.0 MiB       18262                   self.lnc[:, step] = masked_mean_2D(self.metacomm.mask, lnc)
  1493                                         
  1494                                                         # Soil C:N:P balance and OM decomposition
  1495    199.6 MiB      0.0 MiB       36524                   s_out = soil_dec.carbon3(self.soil_temp, wtot / self.wmax_mm, self.litter_l[step],
  1496    199.6 MiB      0.0 MiB       18262                                            self.cwd[step], self.litter_fr[step], self.lnc[:, step],
  1497    199.6 MiB      0.0 MiB       18262                                            self.sp_csoil, self.sp_snc)
  1498    199.6 MiB      0.0 MiB       18262                   soil_out = catch_out_carbon3(s_out)
  1499                                         
  1500                                                         # Organic C N & P
  1501    199.6 MiB      0.0 MiB       18262                   self.sp_csoil = soil_out['cs']
  1502    199.6 MiB      0.0 MiB       18262                   self.sp_snc = np.zeros(shape=8)
  1503    199.6 MiB      0.0 MiB       18262                   self.sp_snc = soil_out['snc']
  1504    199.6 MiB      0.0 MiB       18262                   idx = np.where(self.sp_snc < 0.0)[0]
  1505    199.6 MiB      0.0 MiB       18262                   if len(idx) > 0:
  1506                                                             self.sp_snc[idx] = 0.0
  1507                                         
  1508                                                         # <- Out of the community loop
  1509    199.6 MiB      0.0 MiB       18262                   self.nupt[:, step] = masked_mean_2D(self.metacomm.mask, nupt)
  1510    199.6 MiB      0.0 MiB       18262                   self.pupt[:, step] = masked_mean_2D(self.metacomm.mask, pupt)
  1511                                         
  1512                                                         # TODO: Soil nutrient dynamics. Isolate this if branch into a separate method/class/function
  1513                                                         # Critical part of soil nutrient dynamics and availability for plants
  1514                                                         # IF NUTRICYCLE
  1515    199.6 MiB      0.0 MiB       18262                   if nutri_cycle:
  1516                                                             # UPDATE ORGANIC POOLS
  1517    199.6 MiB      0.0 MiB       18262                       self.sp_organic_n = self.sp_snc[:2].sum()
  1518    199.6 MiB      0.0 MiB       18262                       self.sp_sorganic_n = self.sp_snc[2:4].sum()
  1519    199.6 MiB      0.0 MiB       18262                       self.sp_organic_p = self.sp_snc[4:6].sum()
  1520    199.6 MiB      0.0 MiB       18262                       self.sp_sorganic_p = self.sp_snc[6:].sum()
  1521                                         
  1522                                                             # Update inorganic pools
  1523    199.6 MiB      0.0 MiB       18262                       self.sp_available_p += soil_out['pmin']
  1524    199.6 MiB      0.0 MiB       18262                       self.sp_available_n += soil_out['nmin']
  1525    199.6 MiB      0.0 MiB       18262                       self.sp_available_p -= self.pupt[0, step]
  1526    199.6 MiB      0.0 MiB       18262                       self.sp_available_n -= self.nupt[0, step]
  1527                                         
  1528                                                             # NUTRIENT DINAMICS
  1529                                         
  1530                                                             # Inorganic N
  1531                                                             # TODO: NaNs are being sourced upstream , need to track the source and fix it
  1532                                         
  1533    199.6 MiB      0.0 MiB       18262                       if not np.isfinite(self.sp_in_n):
  1534                                                                 # rwarn(f"Non-finite value detected in sp_in_n pool at step {step}. Resetting to zero.")
  1535                                                                 self.sp_in_n = 0.0
  1536    199.6 MiB      0.0 MiB       18262                       if not np.isfinite(self.sp_available_n):
  1537                                                                 # rwarn(f"Non-finite value detected in sp_available_n pool at step {step}. Resetting to zero.")
  1538                                                                 self.sp_available_n = 0.0
  1539    199.6 MiB      0.0 MiB       18262                       if not np.isfinite(self.sp_so_n):
  1540                                                                 # rwarn(f"Non-finite value detected in sp_so_n pool at step {step}. Resetting to zero.")
  1541                                                                 self.sp_so_n = 0.0
  1542                                         
  1543    199.6 MiB      0.0 MiB       18262                       self.sp_in_n += self.sp_available_n + self.sp_so_n
  1544    199.6 MiB      0.0 MiB       18262                       self.sp_so_n = soil_dec.sorbed_n_equil(self.sp_in_n)
  1545    199.6 MiB      0.0 MiB       18262                       self.sp_available_n = soil_dec.solution_n_equil(self.sp_in_n)
  1546    199.6 MiB      0.0 MiB       18262                       self.sp_in_n -= (self.sp_so_n + self.sp_available_n)
  1547                                         
  1548                                                             # Inorganic P
  1549    199.6 MiB      0.0 MiB       18262                       if not np.isfinite(self.sp_in_p):
  1550                                                                 # rwarn(f"Non-finite value detected in sp_in_p pool at step {step}. Resetting to zero.")
  1551                                                                 self.sp_in_p = 0.0
  1552    199.6 MiB      0.0 MiB       18262                       if not np.isfinite(self.sp_available_p):
  1553                                                                 # rwarn(f"Non-finite value detected in sp_available_p pool at step {step}. Resetting to zero.")
  1554                                                                 self.sp_available_p = 0.0
  1555    199.6 MiB      0.0 MiB       18262                       if not np.isfinite(self.sp_so_p):
  1556                                                                 # rwarn(f"Non-finite value detected in sp_so_p pool at step {step}. Resetting to zero.")
  1557                                                                 self.sp_so_p = 0.0
  1558                                         
  1559    199.6 MiB      0.0 MiB       18262                       self.sp_in_p += self.sp_available_p + self.sp_so_p
  1560                                                             # sp_so_p is the occluded P in the inorganic pool
  1561    199.6 MiB      0.0 MiB       18262                       self.sp_so_p = soil_dec.sorbed_p_equil(self.sp_in_p)
  1562                                                             # THe fraction that can be dissolved in soil solution (passive uptake uses transpiration
  1563                                                             # to estimate the amount of P that can be taken up from the soil solution pool)
  1564    199.6 MiB      0.0 MiB       18262                       self.sp_available_p = soil_dec.solution_p_equil(self.sp_in_p)
  1565                                                             # Inorganic pool that is adsorbed
  1566    199.6 MiB      0.0 MiB       18262                       self.sp_in_p -= (self.sp_so_p + self.sp_available_p)
  1567                                         
  1568    199.6 MiB      0.0 MiB       18262                       self.sp_so_p -= self.pupt[1, step]
  1569                                         
  1570    199.6 MiB      0.0 MiB       18262                       try:
  1571    199.6 MiB      0.0 MiB       18262                           t1 = np.all(self.sp_snc > 0.0)
  1572                                                             except:
  1573                                                                 if self.sp_snc is None:
  1574                                                                     self.sp_snc = np.zeros(shape=8,)
  1575                                                                     t1 = True
  1576                                                                 elif self.sp_snc is not None:
  1577                                                                     t1 = True
  1578                                                                 rwarn(f"Exception while handling sp_snc pool")
  1579    199.6 MiB      0.0 MiB       18262                       if not t1:
  1580                                                                 self.sp_snc[np.where(self.sp_snc < 0)[0]] = 0.0
  1581                                         
  1582                                                             # ORGANIC nutrients uptake
  1583    199.6 MiB      0.0 MiB       18262                       total_on = self.sp_snc[:4].sum()
  1584    199.6 MiB      0.0 MiB       18262                       if total_on > 0.0 and np.isfinite(total_on):
  1585    199.6 MiB      0.4 MiB      127834                           frsn = [i / total_on for i in self.sp_snc[:4]]
  1586                                                             else:
  1587                                                                 frsn = [0.0, 0.0, 0.0, 0.0]
  1588    199.6 MiB      0.0 MiB       91310                       for i, fr in enumerate(frsn):
  1589    199.6 MiB      0.0 MiB       73048                           self.sp_snc[i] -= (self.nupt[1, step] * fr)
  1590                                         
  1591    199.6 MiB      0.0 MiB       18262                       idx = np.where(self.sp_snc < 0.0)[0]
  1592    199.6 MiB      0.0 MiB       18262                       if len(idx) > 0:
  1593                                                                 self.sp_snc[idx] = 0.0
  1594                                         
  1595    199.6 MiB      0.0 MiB       18262                       self.sp_organic_n = self.sp_snc[:2].sum()
  1596    199.6 MiB      0.0 MiB       18262                       self.sp_sorganic_n = self.sp_snc[2:4].sum()
  1597                                         
  1598                                                             # P
  1599    199.6 MiB      0.0 MiB       18262                       total_op = self.sp_snc[4:].sum()
  1600    199.6 MiB      0.0 MiB       18262                       if total_op > 0.0 and np.isfinite(total_op):
  1601    199.6 MiB      0.0 MiB      127834                           frsp = [i / total_op for i in self.sp_snc[4:]]
  1602                                                             else:
  1603                                                                 frsp = [0.0, 0.0, 0.0, 0.0]
  1604    199.6 MiB      0.0 MiB       91310                       for i, fr in enumerate(frsp):
  1605    199.6 MiB      0.0 MiB       73048                           self.sp_snc[i + 4] -= (self.pupt[2, step] * fr)
  1606                                         
  1607    199.6 MiB      0.0 MiB       18262                       idx = np.where(self.sp_snc < 0.0)[0]
  1608    199.6 MiB      0.0 MiB       18262                       if len(idx) > 0:
  1609                                                                 self.sp_snc[idx] = 0.0
  1610                                         
  1611    199.6 MiB      0.0 MiB       18262                       self.sp_organic_p = self.sp_snc[4:6].sum()
  1612    199.6 MiB      0.0 MiB       18262                       self.sp_sorganic_p = self.sp_snc[6:].sum()
  1613                                                         # END SOIL NUTRIENT DYNAMICS
  1614                                         
  1615    199.6 MiB      0.0 MiB       18262                   if save:
  1616                                                             # Plant uptake and Carbon costs of nutrient uptake
  1617    199.6 MiB      0.0 MiB       18262                       self.storage_pool[:, step] = masked_mean_2D(self.metacomm.mask, storage_pool.astype(np.float32))
  1618    199.6 MiB      0.0 MiB       18262                       self.carbon_costs[step] = masked_mean(self.metacomm.mask, cc)
  1619    199.6 MiB      0.0 MiB       18262                       self.tsoil.append(self.soil_temp)
  1620    199.6 MiB      0.0 MiB       18262                       self.photo[step] = masked_mean(self.metacomm.mask, photo)
  1621    199.6 MiB      0.0 MiB       18262                       self.aresp[step] = masked_mean(self.metacomm.mask, aresp)
  1622    199.6 MiB      0.0 MiB       18262                       self.npp[step] = masked_mean(self.metacomm.mask, npp)
  1623    199.6 MiB      0.0 MiB       18262                       self.rnpp[step] = masked_mean(self.metacomm.mask, rnpp_mt)
  1624    199.6 MiB      0.0 MiB       18262                       self.lai[step] = masked_mean(self.metacomm.mask, lai)
  1625    199.6 MiB      0.0 MiB       18262                       self.rcm[step] = masked_mean(self.metacomm.mask, rcm)
  1626    199.6 MiB      0.0 MiB       18262                       self.f5[step] = masked_mean(self.metacomm.mask, f5)
  1627    199.6 MiB      0.0 MiB       18262                       self.rm[step] = masked_mean(self.metacomm.mask, rm)
  1628    199.6 MiB      0.0 MiB       18262                       self.rg[step] = masked_mean(self.metacomm.mask, rg)
  1629    199.6 MiB      0.0 MiB       18262                       self.wue[step] = masked_mean(self.metacomm.mask, wue)
  1630    199.6 MiB      0.0 MiB       18262                       self.cue[step] = masked_mean(self.metacomm.mask, cue)
  1631    199.6 MiB      0.0 MiB       18262                       self.carbon_deficit[step] = masked_mean(self.metacomm.mask, carbon_deficit)
  1632    199.6 MiB      0.0 MiB       18262                       self.vcmax[step] = masked_mean(self.metacomm.mask, vcmax)
  1633    199.6 MiB      0.0 MiB       18262                       self.specific_la[step] = masked_mean(self.metacomm.mask, specific_la)
  1634    199.6 MiB      0.0 MiB       18262                       self.hresp[step] = soil_out['hr']
  1635    199.6 MiB      0.0 MiB       18262                       self.csoil[:, step] = soil_out['cs']
  1636    199.6 MiB      0.0 MiB       18262                       self.wsoil[step] = self.swp.calc_total_water()
  1637    199.6 MiB      0.0 MiB       18262                       self.inorg_n[step] = self.sp_in_n
  1638    199.6 MiB      0.0 MiB       18262                       self.inorg_p[step] = self.sp_in_p
  1639    199.6 MiB      0.0 MiB       18262                       self.sorbed_n[step] = self.sp_so_n
  1640    199.6 MiB      0.0 MiB       18262                       self.sorbed_p[step] = self.sp_so_p
  1641    199.6 MiB      0.0 MiB       18262                       self.snc[:, step] = soil_out['snc']
  1642    199.6 MiB      0.0 MiB       18262                       self.nmin[step] = self.sp_available_n
  1643    199.6 MiB      0.0 MiB       18262                       self.pmin[step] = self.sp_available_p
  1644    199.6 MiB      0.0 MiB       18262                       self.ls[step] = living_pls
  1645                                         
  1646                                                     # <- Out of the daily loop
  1647                                                     # Save the spin data
  1648                                                     sv: Thread
  1649    199.6 MiB      0.0 MiB           1               if save:
  1650    199.6 MiB      0.0 MiB           1                   if s > 0:
  1651                                                             sv.join()  # Wait for the previous thread to finish
  1652                                                             self.flush_data = None
  1653    199.6 MiB      0.0 MiB           1                   self.executed_iterations.append((start_date, end_date))
  1654    199.6 MiB      0.0 MiB           2                   self.flush_data = self._flush_output(
  1655    199.6 MiB      0.0 MiB           1                       'spin', (self.start_index, self.end_index))
  1656    199.6 MiB      0.0 MiB           1                   sv = Thread(target=self._save_output, args=(self.flush_data,))
  1657    199.7 MiB      0.1 MiB           1                   sv.start()
  1658                                                 # <- Out of spin loop
  1659                                                 # Manage the last thread
  1660    199.7 MiB      0.0 MiB           1           if save:
  1661    195.6 MiB     -4.1 MiB           1               sv.join()  # Wait for the last thread to finish
  1662    195.6 MiB      0.0 MiB           1               self.flush_data = None
  1663                                         
  1664                                         
  1665                                                 # Restablish new communities in the end, if applicable
  1666    195.6 MiB     -0.1 MiB           1           if kill_and_reset:
  1667                                                     assert not save, "Cannot save data when resetting communities"
  1668                                                     for community in self.metacomm:
  1669                                                         # with lock:
  1670                                                         new_life_strategies = self.get_from_main_array(community.npls)
  1671                                                         community.restore_from_main_table(new_life_strategies)
  1672                                                     # Here we update the metacomm mask to ensure that all communities are active again
  1673                                                     self.metacomm.update_mask()
  1674                                         
  1675    195.6 MiB     -0.0 MiB           1           return None


  1651                                                             sv.join()  # Wait for the previous thread to finish
  1652                                                             self.flush_data = None
  1653                                                         self.executed_iterations.append((start_date, end_date))
  1654                                                         self.flush_data = self._flush_output(
  1655                                                             'spin', (self.start_index, self.end_index))
  1656                                                         sv = Thread(target=self._save_output, args=(self.flush_data,))
  1657                                                         sv.start()
  1658                                                 # <- Out of spin loop
  1659                                                 # Manage the last thread
  1660    197.1 MiB      0.0 MiB           1           if save:
  1661                                                     sv.join()  # Wait for the last thread to finish
  1662                                                     self.flush_data = None
  1663                                         
  1664                                         
  1665                                                 # Restablish new communities in the end, if applicable
  1666    197.1 MiB      0.0 MiB           1           if kill_and_reset:
  1667                                                     assert not save, "Cannot save data when resetting communities"
  1668                                                     for community in self.metacomm:
  1669                                                         # with lock:
  1670                                                         new_life_strategies = self.get_from_main_array(community.npls)
  1671                                                         community.restore_from_main_table(new_life_strategies)
  1672                                                     # Here we update the metacomm mask to ensure that all communities are active again
  1673                                                     self.metacomm.update_mask()
  1674                                         
  1675    197.1 MiB      0.0 MiB           1           return None


Filename: C:\Users\darel\OneDrive\Desktop\CAETE\src\caete.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
  1013    197.1 MiB    197.1 MiB           1       @profile
  1014                                             # @timer
  1015                                             def run_gridcell(self,
  1016                                                           start_date: str,
  1017                                                           end_date: str,
  1018                                                           spinup: int = 0,
  1019                                                           fixed_co2_atm_conc: Optional[str] | Optional[int] | Optional[float] = None,
  1020                                                           save: bool = True,
  1021                                                           nutri_cycle: bool = True,
  1022                                                           afex: bool = False,
  1023                                                           reset_community: bool = False,
  1024                                                           kill_and_reset: bool = False,
  1025                                                           env_filter: bool = False,
  1026                                                           process_limitation: bool = False,
  1027                                                           verbose: bool = False):
  1028                                                 """
  1029                                                 Run the model for a grid cell.
  1030                                         
  1031                                                 CAETÊ-DVM execution in the start_date - end_date period, can be used for spinup or transient runs.
  1032                                         
  1033                                                 Args:
  1034                                                     start_date (str): Start date for model execution in "yyyymmdd" format.
  1035                                                     end_date (str): End date for model execution in "yyyymmdd" format.
  1036                                                     spinup (int, optional): Number of repetitions in spinup. Set to 0 for a transient run between start_date and end_date. Default is 0.
  1037                                                     fixed_co2_atm_conc (Optional[Union[str, int, float]]): Fixed atmospheric CO2 concentration. If None, use dynamic CO2 levels from a predefined file. If a string with a year (e.g., "1987") That year's value in the provided file will be used. Use a float to set a fixed level in ppm. Default is None.
  1038                                                     save (bool, optional): Whether to save the results. Default is True.
  1039                                                     nutri_cycle (bool, optional): Whether to include nutrient cycling in the model. Default is True.
  1040                                                     afex (bool, optional): Whether to apply nutrient addition to soil in the model. Default is False.
  1041                                                     reset_community (bool, optional): Whether to restart a new community if there are not viable PLS. Default is False.
  1042                                                     kill_and_reset (bool, optional): Whether to kill and reset the community structure at the end of execution (only CVEG pools and PLS IDs). Default is False.
  1043                                                     env_filter (bool, optional): Whether to apply environmental filtering (Include new PLS periodically) []. Default is False.
  1044                                                     verbose (bool, optional): Whether to print detailed logs during execution. Default is False.
  1045                                         
  1046                                                 Returns:
  1047                                                     None
  1048                                         
  1049                                                 Notes:
  1050                                                     - If reset_community is true a new community will be set (reset) when there is no PLSs remaining.
  1051                                                     - If the kill_and_reset is true, after n spins (integer given by spinup parameter - i.e. in the end
  1052                                                       of function execution) all the communities in a gridcell are reset. The reset_community and
  1053                                                       kill_and_reset  arguments are not mutually exclusive. You can use both as true at the same time.
  1054                                                     - The env_filter argument is used to define if new unique PLSs from the main table will be
  1055                                                       seed in the communities that have free slots (PLSs that are not producing). At the moment, the
  1056                                                       interval for the env_filter to add a new PLS to the community is set to  ~15 days.
  1057                                                       If env filter argument is true, then the reset_community argument will have a very low
  1058                                                       probability to trigger a reset because the communities will be constantly filled with new PLS.
  1059                                                       Nonetheless, the reset_community argument will still be able to trigger a reset if the community loses all PLSs.
  1060                                                       With the probability of a reset_community increasing as the interval between new seeds increases. The parameter doy_months
  1061                                                       in the config file (caete.toml) is used to define the interval for the env_filter to add a new PLS to the community.
  1062                                         
  1063                                                       TODO: Implement a more flexible way to define the interval for
  1064                                                             the env_filter to add a new PLS to the community.
  1065                                                 """
  1066                                         
  1067    197.1 MiB      0.0 MiB           1           assert not fixed_co2_atm_conc or\
  1068                                                     isinstance(fixed_co2_atm_conc, str) or\
  1069                                                     fixed_co2_atm_conc > 0,\
  1070                                                         "A fixed value for ATM[CO2] must be a positive number greater than zero or a proper string with the year - e.g., 'yyyy'"
  1071                                         
  1072                                         
  1073                                                 # Define start and end dates (read parameters)
  1074    197.1 MiB      0.0 MiB           1           start = parse_date(start_date)
  1075    197.1 MiB      0.0 MiB           1           end = parse_date(end_date)
  1076                                         
  1077                                                 # Check dates
  1078    197.1 MiB      0.0 MiB           1           assert start < end, "Start date must be before end date"
  1079    197.1 MiB      0.0 MiB           1           assert start >= self.start_date, "initial date out of bounds for the time array"
  1080    197.1 MiB      0.0 MiB           1           assert end <= self.end_date, f"Final date out of bounds for the time array"
  1081                                         
  1082                                         
  1083                                                 # Define time index bounds for this run
  1084                                                 # During a run we are in general using a slice ov the available time span
  1085                                                 # to run the model. For example, we can run the model for a year or a decade
  1086                                                 # at the begining of the input data time series to spin up. This slice is defined
  1087                                                 # by the start and end dates provided in the arguments. Here we get the indices.
  1088    197.1 MiB      0.0 MiB           1           self.start_index = int(cftime.date2num(start, self.time_unit, self.calendar))
  1089    197.1 MiB      0.0 MiB           1           self.end_index =   int(cftime.date2num(end, self.time_unit, self.calendar))
  1090                                         
  1091                                                 # Find the indices in the time array [used to slice the timeseries with driver data  - tas, pr, etc.]
  1092    197.1 MiB      0.0 MiB           1           lower_bound, upper_bound = self.find_index(self.start_index, self.end_index)
  1093                                         
  1094                                                 # Define the time steps range (days)
  1095    197.1 MiB      0.0 MiB           1           steps = np.arange(lower_bound, upper_bound + 1, dtype=np.int64)
  1096                                         
  1097                                                 # Define the number of repetitions for the spinup
  1098    197.1 MiB      0.0 MiB           1           spin = 1 if spinup == 0 else spinup
  1099                                         
  1100                                                 # Define the AFEX mode
  1101    197.1 MiB      0.0 MiB           1           afex_mode = self.afex_config.afex_mode # type: ignore
  1102                                         
  1103                                                 # Slice&Catch climatic input and make conversions
  1104    197.1 MiB      0.0 MiB           1           cv = self.config.conversion_factors_isimip # type: ignore
  1105                                         
  1106                                         
  1107    197.1 MiB      0.0 MiB           1           if self.config.input_handler.input_method == "ih" and self.config.input_handler.input_type == "netcdf":
  1108                                                     # Variables in Netcdf files are already in proprer units
  1109    197.1 MiB      0.0 MiB           1               temp: NDArray[np.float32] = self.tas[lower_bound: upper_bound + 1]   # Air temp: model uses °C
  1110    197.1 MiB      0.0 MiB           1               prec: NDArray[np.float32] = self.pr[lower_bound: upper_bound + 1]    # Precipitation: model uses  mm/day
  1111    197.1 MiB      0.0 MiB           1               p_atm: NDArray[np.float32] = self.ps[lower_bound: upper_bound + 1]   # Atmospheric pressure: model uses hPa
  1112    197.1 MiB      0.0 MiB           1               ipar: NDArray[np.float32] = self.rsds[lower_bound: upper_bound + 1]  # PAR: model uses  mol(photons) m-2 s-1
  1113    197.1 MiB      0.0 MiB           1               ru: NDArray[np.float32] = self.rhs[lower_bound: upper_bound + 1]     # Relative humidity: model uses 0-1
  1114                                                 else:
  1115                                                     temp: NDArray[np.float32] = self.tas[lower_bound: upper_bound + 1] - cv.tas    # Air temp: model uses °C
  1116                                                     prec: NDArray[np.float32] = self.pr[lower_bound: upper_bound + 1] * cv.pr      # Precipitation: model uses  mm/day
  1117                                                     p_atm: NDArray[np.float32] = self.ps[lower_bound: upper_bound + 1] * cv.ps     # Atmospheric pressure: model uses hPa
  1118                                                     ipar: NDArray[np.float32] = self.rsds[lower_bound: upper_bound + 1] * cv.rsds  # PAR: model uses  mol(photons) m-2 s-1
  1119                                                     ru: NDArray[np.float32] = self.rhs[lower_bound: upper_bound + 1] * cv.rhs      # Relative humidity: model uses 0-1
  1120                                         
  1121                                                 # Define the daily values for co2 concentrations
  1122    197.1 MiB      0.0 MiB           1           co2_daily_values = np.zeros(steps.size, dtype=np.float32)
  1123                                         
  1124    197.1 MiB      0.0 MiB           1           if fixed_co2_atm_conc is None:
  1125                                                     # In this case, the co2 concentration will be updated daily.
  1126                                                     # We interpolate linearly between the yearly values of the atm co2 data
  1127    197.1 MiB      0.0 MiB           1               co2 = self.find_co2(start.year)
  1128    197.1 MiB      0.0 MiB           1               today = datetime(start.year, start.month, start.day, start.hour, start.minute, start.second)
  1129    197.1 MiB      0.0 MiB           1               time_step = timedelta(days=1) # Define the time step
  1130    197.1 MiB      0.0 MiB           1               today -= time_step # The first thing we do next is to add a day to the date. So we go back one day
  1131                                                     # Loop over the days and calculate the co2 concentration for each day
  1132    197.1 MiB      0.0 MiB       18263               for step in range(steps.size):
  1133    197.1 MiB      0.0 MiB       18262                   today += time_step
  1134    197.1 MiB      0.0 MiB       18262                   remaining = (datetime(today.year, 12, 31) - today).days + 1
  1135    197.1 MiB      0.0 MiB       18262                   daily_fraction = (self.find_co2(today.year + 1) - co2) / (remaining + 1)
  1136    197.1 MiB      0.0 MiB       18262                   co2 += daily_fraction
  1137    197.1 MiB      0.0 MiB       18262                   co2_daily_values[step] = co2
  1138                                                 elif isinstance(fixed_co2_atm_conc, int) or isinstance(fixed_co2_atm_conc, float):
  1139                                                     # In this case, the co2 concentration will be fixed according to the numeric value provided in the argument
  1140                                                     co2 = fixed_co2_atm_conc
  1141                                                     co2_daily_values += co2
  1142                                                 elif isinstance(fixed_co2_atm_conc, str):
  1143                                                     # In this case, the co2 concentration will be fixed
  1144                                                     # According to the year provided in the argument
  1145                                                     # as a string. Format "yyyy".
  1146                                                     try:
  1147                                                         co2_year = int(fixed_co2_atm_conc)
  1148                                                     except ValueError:
  1149                                                         raise ValueError(
  1150                                                             "The string(\"yyyy\") must be a number in the {self.start_date.year} - {self.end_date.year} interval")
  1151                                                     co2 = self.find_co2(co2_year)
  1152                                                     co2_daily_values += co2
  1153                                                 else:
  1154                                                     raise ValueError("Invalid value for fixed_co2_atm_conc")
  1155                                         
  1156                                                 # Define variables to track dates
  1157    197.1 MiB      0.0 MiB           1           first_day_of_simulation = datetime(start.year, start.month, start.day, start.hour, start.minute, start.second)
  1158                                                 # Define the time step
  1159    197.1 MiB      0.0 MiB           1           time_step = timedelta(days=1)
  1160                                         
  1161                                                 # Define the object to store the outputs from daily_budget
  1162    197.1 MiB      0.0 MiB           1           daily_output = DailyBudget()
  1163                                         
  1164                                                 # Start loops
  1165                                                 # This outer loop is used to run the model for a number
  1166                                                 # of times defined by the spinup argument. The model is
  1167                                                 # executed repeatedly between the start and end dates
  1168                                                 # provided in the arguments
  1169                                         
  1170    199.8 MiB      0.0 MiB           2           for s in range(spin):
  1171                                         
  1172    198.1 MiB      1.0 MiB           1               self._allocate_output(steps.size, self.metacomm.comm_npls, len(self.metacomm), save)
  1173                                         
  1174                                                     # Loop over the days
  1175    198.1 MiB      0.0 MiB           1               today = first_day_of_simulation
  1176                                         
  1177                                                     # Go back one day
  1178    198.1 MiB      0.0 MiB           1               today -= time_step
  1179                                         
  1180                                                     # Arrays to store & pass values for each community in a simulated day
  1181    198.1 MiB      0.0 MiB           1               sto =        np.zeros(shape=(3, self.metacomm.comm_npls), order='F')
  1182    198.1 MiB      0.0 MiB           1               cleaf_in =   np.zeros(self.metacomm.comm_npls, order='F')
  1183    198.1 MiB      0.0 MiB           1               cwood_in =   np.zeros(self.metacomm.comm_npls, order='F')
  1184    198.1 MiB      0.0 MiB           1               croot_in =   np.zeros(self.metacomm.comm_npls, order='F')
  1185    198.1 MiB      0.0 MiB           1               uptk_costs = np.zeros(self.metacomm.comm_npls, order='F')
  1186    198.1 MiB      0.0 MiB           1               rnpp_in =    np.zeros(self.metacomm.comm_npls, order='F')
  1187                                         
  1188                                                     # There are two modes of operation: save and not save.
  1189                                                     # In the save == False mode, the arrays are used to store the values that are
  1190                                                     # needed for model iteration, i.e., the values that are used in the next
  1191                                                     # time step. In the save mode, an extra number arrays is created to be used
  1192                                                     # to store the outputs.
  1193    198.1 MiB      0.0 MiB           1               xsize: int = len(self.metacomm) # Number of communities
  1194    198.1 MiB      0.0 MiB           1               evavg: NDArray[np.float32] = np.zeros(xsize, dtype=np.float32)
  1195    198.1 MiB      0.0 MiB           1               epavg: NDArray[np.float32] = np.zeros(xsize, dtype=np.float32)
  1196    198.1 MiB      0.0 MiB           1               rnpp_mt: NDArray[np.float32] = np.zeros(xsize, dtype=np.float32)
  1197                                         
  1198                                                     # We keep track of these to input in SOM dynamics later. They are used for output also
  1199    198.1 MiB      0.0 MiB           1               leaf_litter: NDArray[np.float32] = np.zeros(xsize, dtype=np.float32)
  1200    198.1 MiB      0.0 MiB           1               cwd: NDArray[np.float32] = np.zeros(xsize, dtype=np.float32)
  1201    198.1 MiB      0.0 MiB           1               root_litter: NDArray[np.float32] = np.zeros(xsize, dtype=np.float32)
  1202    198.1 MiB      0.0 MiB           1               lnc: NDArray[np.float32] = np.zeros(shape=(6, xsize), dtype=np.float32)
  1203                                                     # This is added to leaf litter pool (that is basicaly a fast SOM pool)
  1204    198.1 MiB      0.0 MiB           1               c_to_nfixers: NDArray[np.float32]= np.zeros(xsize, dtype=np.float32)
  1205    198.1 MiB      0.0 MiB           1               nupt = np.zeros(shape=(2, xsize), dtype=np.float32)
  1206    198.1 MiB      0.0 MiB           1               pupt = np.zeros(shape=(3, xsize), dtype=np.float32)
  1207                                         
  1208    198.1 MiB      0.0 MiB           1               if save:
  1209    198.1 MiB      0.0 MiB           1                   cc = np.zeros(xsize, dtype=np.float32)
  1210    198.1 MiB      0.0 MiB           1                   photo = np.zeros(xsize, dtype=np.float32)
  1211    198.1 MiB      0.0 MiB           1                   aresp = np.zeros(xsize, dtype=np.float32)
  1212    198.1 MiB      0.0 MiB           1                   npp = np.zeros(xsize, dtype=np.float32)
  1213    198.1 MiB      0.0 MiB           1                   lai = np.zeros(xsize, dtype=np.float32)
  1214    198.1 MiB      0.0 MiB           1                   rcm = np.zeros(xsize, dtype=np.float32)
  1215    198.1 MiB      0.0 MiB           1                   f5 = np.zeros(xsize, dtype=np.float32)
  1216    198.1 MiB      0.0 MiB           1                   rm = np.zeros(xsize, dtype=np.float32)
  1217    198.1 MiB      0.0 MiB           1                   rg = np.zeros(xsize, dtype=np.float32)
  1218    198.1 MiB      0.0 MiB           1                   wue = np.zeros(xsize, dtype=np.float32)
  1219    198.1 MiB      0.0 MiB           1                   cue = np.zeros(xsize, dtype=np.float32)
  1220    198.1 MiB      0.0 MiB           1                   carbon_deficit = np.zeros(xsize, dtype=np.float32)
  1221    198.1 MiB      0.0 MiB           1                   vcmax = np.zeros(xsize, dtype=np.float32)
  1222    198.1 MiB      0.0 MiB           1                   specific_la = np.zeros(xsize, dtype=np.float32)
  1223    198.1 MiB      0.0 MiB           1                   storage_pool = np.zeros(shape=(3, xsize))
  1224                                         
  1225    198.1 MiB      0.0 MiB           1                   if process_limitation:
  1226                                                             lim_status_y_leaf = np.ma.masked_all((xsize, self.metacomm.comm_npls, 366), dtype=np.int8)
  1227                                                             lim_status_y_stem = np.ma.masked_all((xsize, self.metacomm.comm_npls, 366), dtype=np.int8)
  1228                                                             lim_status_y_root = np.ma.masked_all((xsize, self.metacomm.comm_npls, 366), dtype=np.int8)
  1229                                                             uptake_strategy_n = np.ma.masked_all((xsize, self.metacomm.comm_npls, 366), dtype=np.int8)
  1230                                                             uptake_strategy_p = np.ma.masked_all((xsize, self.metacomm.comm_npls, 366), dtype=np.int8)
  1231                                         
  1232                                                     # <- Daily loop
  1233    199.7 MiB      0.0 MiB       18263               for step in range(steps.size):
  1234    199.7 MiB      0.0 MiB       18262                   today += time_step
  1235    199.7 MiB      0.0 MiB       18262                   julian_day = today.timetuple().tm_yday
  1236                                         
  1237                                                         # Get the co2 concentration for the day
  1238    199.7 MiB      0.0 MiB       18262                   co2 = co2_daily_values[step]
  1239                                                         # Update soil temperature
  1240    199.7 MiB      0.0 MiB       18262                   self.soil_temp = st.soil_temp(self.soil_temp, temp[step])
  1241                                         
  1242                                                         # AFEX
  1243    199.7 MiB      0.0 MiB       18262                   if afex and julian_day == 365:
  1244                                                             self.add_soil_nutrients(afex_mode)
  1245                                         
  1246                                                         # Loop over communities
  1247    199.7 MiB      0.0 MiB       18262                   living_pls = 0 # Sum of living PLS in the communities
  1248    199.7 MiB      0.0 MiB       36524                   for i, community in enumerate(self.metacomm):
  1249                                                             # if i >= len(self.metacomm):
  1250                                                             #     break
  1251                                                             # if community.masked:
  1252                                                             #     # skip this one
  1253                                                             #     continue
  1254    199.7 MiB      0.0 MiB       18262                       sto[0, :] = inflate_array(community.npls, community.vp_sto[0, :], community.vp_lsid)
  1255    199.7 MiB      0.0 MiB       18262                       sto[1, :] = inflate_array(community.npls, community.vp_sto[1, :], community.vp_lsid)
  1256    199.7 MiB      0.0 MiB       18262                       sto[2, :] = inflate_array(community.npls, community.vp_sto[2, :], community.vp_lsid)
  1257                                         
  1258    199.7 MiB      0.0 MiB       18262                       cleaf_in[:] = inflate_array(community.npls, community.vp_cleaf, community.vp_lsid)
  1259    199.7 MiB      0.0 MiB       18262                       cwood_in[:] = inflate_array(community.npls, community.vp_cwood, community.vp_lsid)
  1260    199.7 MiB      0.0 MiB       18262                       croot_in[:] = inflate_array(community.npls, community.vp_croot, community.vp_lsid)
  1261    199.7 MiB      0.0 MiB       18262                       uptk_costs[:] = inflate_array(community.npls, community.sp_uptk_costs, community.vp_lsid)
  1262    199.7 MiB      0.0 MiB       18262                       rnpp_in[:] = inflate_array(community.npls, community.construction_npp, community.vp_lsid)
  1263                                         
  1264    199.7 MiB      0.0 MiB       18262                       ton = self.sp_organic_n #+ self.sp_sorganic_n
  1265    199.7 MiB      0.0 MiB       18262                       top = self.sp_organic_p #+ self.sp_sorganic_p
  1266                                         
  1267                                                             # Community daily budget calculation
  1268    199.7 MiB      0.1 MiB       36524                       out = model.daily_budget(community.pls_array, self.wp_water_upper_mm,
  1269    199.7 MiB      0.0 MiB       18262                                               self.wp_water_lower_mm, self.soil_temp, temp[step],
  1270    199.7 MiB      0.0 MiB       18262                                               p_atm[step], ipar[step], ru[step], self.sp_available_n,
  1271    199.7 MiB      0.0 MiB       18262                                               self.sp_available_p, ton, top, self.sp_organic_p,
  1272    199.7 MiB      0.0 MiB       18262                                               co2, sto, cleaf_in, cwood_in, croot_in, uptk_costs,self.wmax_mm,
  1273    199.7 MiB      0.0 MiB       18262                                               rnpp_in)
  1274                                         
  1275                                                             # get daily budget results
  1276    199.7 MiB      0.0 MiB       18262                       daily_output.update(out)
  1277                                         
  1278                                                             # Update the community status
  1279    199.7 MiB      0.0 MiB       18262                       community.update_lsid(daily_output.ocpavg)
  1280                                         
  1281                                                             # Abort community if no PLSs are left while saving the spin
  1282    199.7 MiB      0.0 MiB       18262                       if community.masked and save:
  1283                                                                 continue
  1284                                         
  1285    199.7 MiB      0.0 MiB       18262                       community.ls = community.vp_lsid.size
  1286                                                             # # Restore or seed PLS
  1287    199.7 MiB      0.0 MiB       18262                       if env_filter and (community.ls < self.metacomm.comm_npls) and not save:
  1288                                                                 if julian_day in self.doy_months:
  1289                                                                     new_id, new_PLS = community.get_unique_pls(self.get_from_main_array)
  1290                                                                     community.seed_pls(new_id, new_PLS, daily_output.cleafavg_pft,
  1291                                                                                        daily_output.cfrootavg_pft, daily_output.cawoodavg_pft)
  1292                                                                     if verbose: print(f"PLS seed in Community {i}: Gridcell: {self.lat} °N, {self.lon} °E: In spin:{s}, step:{step}")
  1293                                         
  1294                                                                     daily_output.ocpavg = pft_area_frac64(daily_output.cleafavg_pft,
  1295                                                                                                     daily_output.cfrootavg_pft,
  1296                                                                                                     daily_output.cawoodavg_pft)
  1297                                                                     community.update_lsid(daily_output.ocpavg)
  1298                                                                     community.ls = community.vp_lsid.size
  1299                                                                 # endif
  1300                                         
  1301                                         
  1302    199.7 MiB      0.0 MiB       18262                       community.vp_ocp = daily_output.ocpavg[community.vp_lsid]
  1303    199.7 MiB      0.0 MiB       18262                       community.vp_cleaf = daily_output.cleafavg_pft[community.vp_lsid]
  1304    199.7 MiB      0.0 MiB       18262                       community.vp_cwood = daily_output.cawoodavg_pft[community.vp_lsid]
  1305    199.7 MiB      0.0 MiB       18262                       community.vp_croot = daily_output.cfrootavg_pft[community.vp_lsid]
  1306    199.7 MiB      0.0 MiB       18262                       community.vp_sto = daily_output.stodbg[:, community.vp_lsid].astype('float32')
  1307    199.7 MiB      0.0 MiB       18262                       community.sp_uptk_costs = daily_output.npp2pay[community.vp_lsid]
  1308    199.7 MiB      0.0 MiB       18262                       community.construction_npp = daily_output.rnpp_out[community.vp_lsid]
  1309    199.7 MiB      0.0 MiB       18262                       living_pls += community.ls
  1310                                                             # print(f"Community storage: {community.vp_sto[0, :]}")
  1311                                                             # print(f"Sto_budget_out {daily_output.stodbg[0, :]}")
  1312                                         
  1313                                                             # Limiting nutrient organization:
  1314                                                             # dim1 = leaf wood root, code: 1=N 2=P 4=N,COLIM 5=P,COLIM 6=COLIM 0=NOLIM
  1315    199.7 MiB      0.0 MiB       18262                       if save:
  1316    199.7 MiB      0.0 MiB       18262                           if process_limitation:
  1317                                                                     lim_status_y_leaf[i, :, julian_day - 1] = daily_output.limitation_status[0,:]# type: ignore
  1318                                                                     lim_status_y_stem[i, :, julian_day - 1] = daily_output.limitation_status[1,:]# type: ignore
  1319                                                                     lim_status_y_root[i, :, julian_day - 1] = daily_output.limitation_status[2,:]# type: ignore
  1320                                                                     uptake_strategy_n[i, :, julian_day - 1] = daily_output.uptk_strat[0,:]# type: ignore
  1321                                                                     uptake_strategy_p[i, :, julian_day - 1] = daily_output.uptk_strat[1,:]# type: ignore
  1322                                         
  1323    199.7 MiB      0.0 MiB       18262                           community.anpp += cw_mean(community.vp_ocp, community.construction_npp.astype(np.float32))
  1324    199.7 MiB      0.0 MiB       18262                           community.uptake_costs += cw_mean(community.vp_ocp, community.sp_uptk_costs.astype(np.float32))
  1325                                         
  1326    199.7 MiB      0.0 MiB       18262                       if save and julian_day == 365:
  1327    199.7 MiB      0.0 MiB          50                           community.cleaf = cw_mean(community.vp_ocp, community.vp_cleaf.astype(np.float32))
  1328    199.7 MiB      0.0 MiB          50                           community.cwood = cw_mean(community.vp_ocp, community.vp_cwood.astype(np.float32))
  1329    199.7 MiB      0.0 MiB          50                           community.croot = cw_mean(community.vp_ocp, community.vp_croot.astype(np.float32))
  1330    199.7 MiB      0.0 MiB          50                           community.csto = cw_mean(community.vp_ocp, community.vp_sto[0, :])
  1331    199.7 MiB      0.3 MiB          50                           community.shannon_diversity = shannon_diversity(community.vp_ocp)
  1332    199.7 MiB      0.0 MiB          50                           community.shannon_entropy = shannon_entropy(community.vp_ocp)
  1333    199.7 MiB      0.1 MiB          50                           community.shannon_evenness = shannon_evenness(community.vp_ocp)
  1334                                         
  1335                                                                 # process limitation data
  1336                                                                 # Filter non living PLS from the limitation status
  1337    199.7 MiB      0.0 MiB          50                           if process_limitation:
  1338                                                                     _data_leaf = lim_status_y_leaf[i, [community.vp_lsid], :] # type: ignore
  1339                                                                     _data_stem = lim_status_y_stem[i, [community.vp_lsid], :] # type: ignore
  1340                                                                     _data_root = lim_status_y_root[i, [community.vp_lsid], :] # type: ignore
  1341                                         
  1342                                                                     _data_uptake_n = uptake_strategy_n[i, [community.vp_lsid], :]# type: ignore
  1343                                                                     _data_uptake_p = uptake_strategy_p[i, [community.vp_lsid], :]# type: ignore
  1344                                         
  1345                                                                     # Loop over the living PLS to get the unique values and counts
  1346                                                                     pls_lim_leaf = []
  1347                                                                     pls_lim_stem = []
  1348                                                                     pls_lim_root = []
  1349                                                                     pls_uptake_n = []
  1350                                                                     pls_uptake_p = []
  1351                                         
  1352                                                                     for k in range(community.vp_lsid.size):
  1353                                                                         # Get the unique values and counts for leaf limitation
  1354                                                                         unique, counts = np.unique(_data_leaf[0, k, :], return_counts=True)
  1355                                                                         unique = unique.data[unique.mask == False] # type: ignore
  1356                                                                         pls_lim_leaf.append((unique, counts[:unique.size])) # type: ignore
  1357                                         
  1358                                                                         # Stem limitation
  1359                                                                         unique, counts = np.unique(_data_stem[0, k, :], return_counts=True)
  1360                                                                         unique = unique.data[unique.mask == False] # type: ignore
  1361                                                                         pls_lim_stem.append((unique, counts[:unique.size])) # type: ignore
  1362                                         
  1363                                                                         # Root limitation
  1364                                                                         unique, counts = np.unique(_data_root[0, k, :], return_counts=True)
  1365                                                                         unique = unique.data[unique.mask == False]
  1366                                                                         pls_lim_root.append((unique, counts[:unique.size])) # type: ignore
  1367                                         
  1368                                                                         # Uptake strategy N
  1369                                                                         unique, counts = np.unique(_data_uptake_n[0, k, :], return_counts=True)
  1370                                                                         unique = unique.data[unique.mask == False] # type: ignore
  1371                                                                         pls_uptake_n.append((unique, counts[:unique.size])) # type: ignore
  1372                                         
  1373                                                                         # Uptake strategy P
  1374                                                                         unique, counts = np.unique(_data_uptake_p[0, k, :], return_counts=True)
  1375                                                                         unique = unique.data[unique.mask == False]  # type: ignore
  1376                                                                         pls_uptake_p.append((unique, counts[:unique.size])) # type: ignore
  1377                                         
  1378                                                                     community.limitation_status_leaf = pls_lim_leaf
  1379                                                                     community.limitation_status_wood = pls_lim_stem
  1380                                                                     community.limitation_status_root = pls_lim_root
  1381                                                                     community.uptake_strategy_n = pls_uptake_n
  1382                                                                     community.uptake_strategy_p = pls_uptake_p
  1383                                         
  1384                                                                     # Reset the limitation masked arrays
  1385                                                                     lim_status_y_leaf.mask[i, :, :] = np.ones((self.metacomm.comm_npls, 366), dtype=bool) # type: ignore
  1386                                                                     lim_status_y_stem.mask[i, :, :] = np.ones((self.metacomm.comm_npls, 366), dtype=bool) # type: ignore
  1387                                                                     lim_status_y_root.mask[i, :, :] = np.ones((self.metacomm.comm_npls, 366), dtype=bool) # type: ignore
  1388                                                                     uptake_strategy_n.mask[i, :, :] = np.ones((self.metacomm.comm_npls, 366), dtype=bool) # type: ignore
  1389                                                                     uptake_strategy_p.mask[i, :, :] = np.ones((self.metacomm.comm_npls, 366), dtype=bool) # type: ignore
  1390                                                                 else:
  1391    199.7 MiB      0.0 MiB          50                               pass
  1392                                         
  1393    199.7 MiB      0.0 MiB       18262                       if community.vp_lsid.size < 1:
  1394                                                                 if verbose: print(f"Empty community {i}: Gridcell: {self.lat} °N, {self.lon} °E: In spin:{s}, step:{step}")
  1395                                                                 if reset_community:
  1396                                                                     assert not save, "Cannot save data when resetting communities"
  1397                                                                     if verbose: print(f"Reseting community {i}: Gridcell: {self.lat} °N, {self.lon} °E: In spin:{s}, step:{step}")
  1398                                         
  1399                                                                     new_life_strategies = self.get_from_main_array(community.npls)
  1400                                                                     community.restore_from_main_table(new_life_strategies)
  1401                                                                     # continue
  1402                                         
  1403                                                                 else:
  1404                                                                     # In the transiant run - i.e., when reset_community is false and
  1405                                                                     # kill_and_reset is false; we mask the community if there is no PLS
  1406                                                                     self.metacomm.mask[i] = np.int8(1)
  1407                                                                     # Set mask to true for this community, will not run in the next steps
  1408                                                                     # Set annual values to zero
  1409                                                                     community.masked = np.int8(1)
  1410                                                                     community.cleaf = np.float32(0.0)
  1411                                                                     community.cwood = np.float32(0.0)
  1412                                                                     community.croot = np.float32(0.0)
  1413                                                                     community.csto  = np.float32(0.0)
  1414                                                                     community.shannon_diversity = -9999.0
  1415                                                                     community.shannon_entropy = -9999.0
  1416                                                                     community.shannon_evenness = -9999.0
  1417                                                                     # if the reset_community is true
  1418                                                                     # continue # cycle
  1419                                         
  1420                                                             # Store values for each community
  1421    199.7 MiB      0.0 MiB       18262                       rnpp_mt[i] = cw_mean(community.vp_ocp, community.construction_npp.astype(np.float32)) # Community Weighted rNPP
  1422    199.7 MiB      0.0 MiB       18262                       leaf_litter[i] = daily_output.litter_l
  1423    199.7 MiB      0.0 MiB       18262                       root_litter[i] = daily_output.litter_fr
  1424    199.7 MiB      0.0 MiB       18262                       cwd[i] = daily_output.cwd
  1425    199.7 MiB      0.0 MiB       18262                       lnc[:, i] = daily_output.lnc.astype(np.float32)
  1426    199.7 MiB      0.0 MiB       18262                       c_to_nfixers[i] = daily_output.cp[3]
  1427    199.7 MiB      0.0 MiB       18262                       evavg[i] = daily_output.evavg
  1428    199.7 MiB      0.0 MiB       18262                       epavg[i] = daily_output.epavg
  1429    199.7 MiB      0.0 MiB       18262                       nupt[:, i] = daily_output.nupt #type: ignore
  1430    199.7 MiB      0.0 MiB       18262                       pupt[:, i] = daily_output.pupt #type: ignore
  1431                                         
  1432    199.7 MiB      0.0 MiB       18262                       if save:
  1433    199.7 MiB      0.0 MiB       18262                           cc[i] = daily_output.c_cost_cwm #type: ignore
  1434    199.7 MiB      0.0 MiB       18262                           npp[i] = daily_output.nppavg #type: ignore
  1435    199.7 MiB      0.0 MiB       18262                           photo[i] = daily_output.phavg #type: ignore
  1436    199.7 MiB      0.0 MiB       18262                           aresp[i] = daily_output.aravg #type: ignore
  1437    199.7 MiB      0.0 MiB       18262                           lai[i] = daily_output.laiavg #type: ignore
  1438    199.7 MiB      0.0 MiB       18262                           rcm[i] = daily_output.rcavg #type: ignore
  1439    199.7 MiB      0.0 MiB       18262                           f5[i] = daily_output.f5avg #type: ignore
  1440    199.7 MiB      0.0 MiB       18262                           rm[i] = daily_output.rmavg #type: ignore
  1441    199.7 MiB      0.0 MiB       18262                           rg[i] = daily_output.rgavg #type: ignore
  1442    199.7 MiB      0.0 MiB       18262                           wue[i] = daily_output.wueavg #type: ignore
  1443    199.7 MiB      0.0 MiB       18262                           cue[i] = daily_output.cueavg #type: ignore
  1444    199.7 MiB      0.0 MiB       18262                           carbon_deficit[i] = daily_output.c_defavg #type: ignore
  1445    199.7 MiB      0.0 MiB       18262                           vcmax[i] = daily_output.vcmax #type: ignore
  1446    199.7 MiB      0.0 MiB       18262                           specific_la[i] = daily_output.specific_la #type: ignore
  1447                                         
  1448    199.7 MiB      0.0 MiB       73048                           for j in range(daily_output.stodbg.shape[0]):
  1449    199.7 MiB      0.0 MiB       54786                               storage_pool[j, i] = cw_mean(community.vp_ocp, community.vp_sto[j, :]) #type: ignore
  1450                                         
  1451                                                         #<- Out of the community loop
  1452                                                         # Save annual state of the metacommunity
  1453    199.7 MiB      0.0 MiB       18262                   if save:
  1454    199.7 MiB      0.0 MiB       18262                       if julian_day == 365:
  1455    199.7 MiB      0.0 MiB          50                           y = today.year
  1456                                                                 # m = today.month
  1457                                                                 # d = today.day
  1458    199.7 MiB      0.0 MiB          50                           filename = self.out_dir/f"metacommunity_{y}.pkz"
  1459                                                                 # filename = self.out_dir/f"metacommunity_{d}{m}{y}.pkz"
  1460    199.7 MiB      0.7 MiB          50                           self.metacomm.save_state(filename, y, process_limitation)
  1461    199.7 MiB      0.0 MiB          50                           self.metacomm_output[y] = filename
  1462                                         
  1463    199.7 MiB      0.0 MiB         100                           for community in self.metacomm:
  1464                                                                     # Set annual accumulators to zero
  1465    199.7 MiB      0.0 MiB          50                               community.anpp = np.float32(0.0)
  1466    199.7 MiB      0.0 MiB          50                               community.uptake_costs = np.float32(0.0)
  1467                                         
  1468                                                         # ------------
  1469                                                         # Evapotranspiration
  1470    199.7 MiB      0.0 MiB       18262                   et = masked_mean(self.metacomm.mask, evavg) #evavg.mean()
  1471                                                         ## Canopy-atmosphere coupling [EXPERIMENTAL]
  1472                                                         # vpd = m.vapor_p_deficit(temp[step], ru[step])
  1473                                                         # et_pot = masked_mean(self.metacomm.mask, np.array(epavg).astype(np.float32)) #epavg.mean()
  1474                                                         # self.evapm[step] = atm_canopy_coupling(et_pot, et, temp[step], vpd)
  1475    199.7 MiB      0.0 MiB       18262                   self.evapm[step] = et
  1476                                         
  1477                                                         # Update water pools
  1478                                         
  1479    199.7 MiB      0.0 MiB       18262                   self.runom[step] = self.swp._update_pool(prec[step], self.evapm[step])
  1480    199.7 MiB      0.0 MiB       18262                   self.swp.w1 = 0.0 if self.swp.w1 < 0.0 else self.swp.w1
  1481    199.7 MiB      0.0 MiB       18262                   self.swp.w2 = 0.0 if self.swp.w2 < 0.0 else self.swp.w2
  1482    199.7 MiB      0.0 MiB       18262                   self.wp_water_upper_mm = self.swp.awc1
  1483    199.7 MiB      0.0 MiB       18262                   self.wp_water_lower_mm = self.swp.awc2
  1484    199.7 MiB      0.0 MiB       18262                   wtot = self.swp.w1 + self.swp.w2
  1485                                         
  1486                                                         # Update cflux to the soil for output, mean values over the communities
  1487                                                         # Values are also used to update SOM dynamics
  1488    199.7 MiB      0.0 MiB       36524                   self.litter_l[step] = masked_mean(self.metacomm.mask, leaf_litter) +\
  1489    199.7 MiB      0.0 MiB       18262                                         masked_mean(self.metacomm.mask, c_to_nfixers)
  1490    199.7 MiB      0.0 MiB       18262                   self.cwd[step] = masked_mean(self.metacomm.mask, cwd)
  1491    199.7 MiB      0.0 MiB       18262                   self.litter_fr[step] = masked_mean(self.metacomm.mask, root_litter)
  1492    199.7 MiB      0.0 MiB       18262                   self.lnc[:, step] = masked_mean_2D(self.metacomm.mask, lnc)
  1493                                         
  1494                                                         # Soil C:N:P balance and OM decomposition
  1495    199.7 MiB      0.0 MiB       36524                   s_out = soil_dec.carbon3(self.soil_temp, wtot / self.wmax_mm, self.litter_l[step],
  1496    199.7 MiB      0.0 MiB       18262                                            self.cwd[step], self.litter_fr[step], self.lnc[:, step],
  1497    199.7 MiB      0.0 MiB       18262                                            self.sp_csoil, self.sp_snc)
  1498    199.7 MiB      0.0 MiB       18262                   soil_out = catch_out_carbon3(s_out)
  1499                                         
  1500                                                         # Organic C N & P
  1501    199.7 MiB      0.0 MiB       18262                   self.sp_csoil = soil_out['cs']
  1502    199.7 MiB      0.0 MiB       18262                   self.sp_snc = np.zeros(shape=8)
  1503    199.7 MiB      0.0 MiB       18262                   self.sp_snc = soil_out['snc']
  1504    199.7 MiB      0.0 MiB       18262                   idx = np.where(self.sp_snc < 0.0)[0]
  1505    199.7 MiB      0.0 MiB       18262                   if len(idx) > 0:
  1506                                                             self.sp_snc[idx] = 0.0
  1507                                         
  1508                                                         # <- Out of the community loop
  1509    199.7 MiB      0.0 MiB       18262                   self.nupt[:, step] = masked_mean_2D(self.metacomm.mask, nupt)
  1510    199.7 MiB      0.0 MiB       18262                   self.pupt[:, step] = masked_mean_2D(self.metacomm.mask, pupt)
  1511                                         
  1512                                                         # TODO: Soil nutrient dynamics. Isolate this if branch into a separate method/class/function
  1513                                                         # Critical part of soil nutrient dynamics and availability for plants
  1514                                                         # IF NUTRICYCLE
  1515    199.7 MiB      0.0 MiB       18262                   if nutri_cycle:
  1516                                                             # UPDATE ORGANIC POOLS
  1517    199.7 MiB      0.0 MiB       18262                       self.sp_organic_n = self.sp_snc[:2].sum()
  1518    199.7 MiB      0.0 MiB       18262                       self.sp_sorganic_n = self.sp_snc[2:4].sum()
  1519    199.7 MiB      0.0 MiB       18262                       self.sp_organic_p = self.sp_snc[4:6].sum()
  1520    199.7 MiB      0.0 MiB       18262                       self.sp_sorganic_p = self.sp_snc[6:].sum()
  1521                                         
  1522                                                             # Update inorganic pools
  1523    199.7 MiB      0.0 MiB       18262                       self.sp_available_p += soil_out['pmin']
  1524    199.7 MiB      0.0 MiB       18262                       self.sp_available_n += soil_out['nmin']
  1525    199.7 MiB      0.0 MiB       18262                       self.sp_available_p -= self.pupt[0, step]
  1526    199.7 MiB      0.0 MiB       18262                       self.sp_available_n -= self.nupt[0, step]
  1527                                         
  1528                                                             # NUTRIENT DINAMICS
  1529                                         
  1530                                                             # Inorganic N
  1531                                                             # TODO: NaNs are being sourced upstream , need to track the source and fix it
  1532                                         
  1533    199.7 MiB      0.0 MiB       18262                       if not np.isfinite(self.sp_in_n):
  1534                                                                 # rwarn(f"Non-finite value detected in sp_in_n pool at step {step}. Resetting to zero.")
  1535                                                                 self.sp_in_n = 0.0
  1536    199.7 MiB      0.0 MiB       18262                       if not np.isfinite(self.sp_available_n):
  1537                                                                 # rwarn(f"Non-finite value detected in sp_available_n pool at step {step}. Resetting to zero.")
  1538                                                                 self.sp_available_n = 0.0
  1539    199.7 MiB      0.0 MiB       18262                       if not np.isfinite(self.sp_so_n):
  1540                                                                 # rwarn(f"Non-finite value detected in sp_so_n pool at step {step}. Resetting to zero.")
  1541                                                                 self.sp_so_n = 0.0
  1542                                         
  1543    199.7 MiB      0.0 MiB       18262                       self.sp_in_n += self.sp_available_n + self.sp_so_n
  1544    199.7 MiB      0.0 MiB       18262                       self.sp_so_n = soil_dec.sorbed_n_equil(self.sp_in_n)
  1545    199.7 MiB      0.0 MiB       18262                       self.sp_available_n = soil_dec.solution_n_equil(self.sp_in_n)
  1546    199.7 MiB      0.0 MiB       18262                       self.sp_in_n -= (self.sp_so_n + self.sp_available_n)
  1547                                         
  1548                                                             # Inorganic P
  1549    199.7 MiB      0.0 MiB       18262                       if not np.isfinite(self.sp_in_p):
  1550                                                                 # rwarn(f"Non-finite value detected in sp_in_p pool at step {step}. Resetting to zero.")
  1551                                                                 self.sp_in_p = 0.0
  1552    199.7 MiB      0.0 MiB       18262                       if not np.isfinite(self.sp_available_p):
  1553                                                                 # rwarn(f"Non-finite value detected in sp_available_p pool at step {step}. Resetting to zero.")
  1554                                                                 self.sp_available_p = 0.0
  1555    199.7 MiB      0.0 MiB       18262                       if not np.isfinite(self.sp_so_p):
  1556                                                                 # rwarn(f"Non-finite value detected in sp_so_p pool at step {step}. Resetting to zero.")
  1557                                                                 self.sp_so_p = 0.0
  1558                                         
  1559    199.7 MiB      0.0 MiB       18262                       self.sp_in_p += self.sp_available_p + self.sp_so_p
  1560                                                             # sp_so_p is the occluded P in the inorganic pool
  1561    199.7 MiB      0.0 MiB       18262                       self.sp_so_p = soil_dec.sorbed_p_equil(self.sp_in_p)
  1562                                                             # THe fraction that can be dissolved in soil solution (passive uptake uses transpiration
  1563                                                             # to estimate the amount of P that can be taken up from the soil solution pool)
  1564    199.7 MiB      0.0 MiB       18262                       self.sp_available_p = soil_dec.solution_p_equil(self.sp_in_p)
  1565                                                             # Inorganic pool that is adsorbed
  1566    199.7 MiB      0.0 MiB       18262                       self.sp_in_p -= (self.sp_so_p + self.sp_available_p)
  1567                                         
  1568    199.7 MiB      0.0 MiB       18262                       self.sp_so_p -= self.pupt[1, step]
  1569                                         
  1570    199.7 MiB      0.0 MiB       18262                       try:
  1571    199.7 MiB      0.0 MiB       18262                           t1 = np.all(self.sp_snc > 0.0)
  1572                                                             except:
  1573                                                                 if self.sp_snc is None:
  1574                                                                     self.sp_snc = np.zeros(shape=8,)
  1575                                                                     t1 = True
  1576                                                                 elif self.sp_snc is not None:
  1577                                                                     t1 = True
  1578                                                                 rwarn(f"Exception while handling sp_snc pool")
  1579    199.7 MiB      0.0 MiB       18262                       if not t1:
  1580                                                                 self.sp_snc[np.where(self.sp_snc < 0)[0]] = 0.0
  1581                                         
  1582                                                             # ORGANIC nutrients uptake
  1583    199.7 MiB      0.0 MiB       18262                       total_on = self.sp_snc[:4].sum()
  1584    199.7 MiB      0.0 MiB       18262                       if total_on > 0.0 and np.isfinite(total_on):
  1585    199.7 MiB      0.4 MiB      127834                           frsn = [i / total_on for i in self.sp_snc[:4]]
  1586                                                             else:
  1587                                                                 frsn = [0.0, 0.0, 0.0, 0.0]
  1588    199.7 MiB      0.0 MiB       91310                       for i, fr in enumerate(frsn):
  1589    199.7 MiB      0.0 MiB       73048                           self.sp_snc[i] -= (self.nupt[1, step] * fr)
  1590                                         
  1591    199.7 MiB      0.0 MiB       18262                       idx = np.where(self.sp_snc < 0.0)[0]
  1592    199.7 MiB      0.0 MiB       18262                       if len(idx) > 0:
  1593                                                                 self.sp_snc[idx] = 0.0
  1594                                         
  1595    199.7 MiB      0.0 MiB       18262                       self.sp_organic_n = self.sp_snc[:2].sum()
  1596    199.7 MiB      0.0 MiB       18262                       self.sp_sorganic_n = self.sp_snc[2:4].sum()
  1597                                         
  1598                                                             # P
  1599    199.7 MiB      0.0 MiB       18262                       total_op = self.sp_snc[4:].sum()
  1600    199.7 MiB      0.0 MiB       18262                       if total_op > 0.0 and np.isfinite(total_op):
  1601    199.7 MiB      0.0 MiB      127834                           frsp = [i / total_op for i in self.sp_snc[4:]]
  1602                                                             else:
  1603                                                                 frsp = [0.0, 0.0, 0.0, 0.0]
  1604    199.7 MiB      0.0 MiB       91310                       for i, fr in enumerate(frsp):
  1605    199.7 MiB      0.0 MiB       73048                           self.sp_snc[i + 4] -= (self.pupt[2, step] * fr)
  1606                                         
  1607    199.7 MiB      0.0 MiB       18262                       idx = np.where(self.sp_snc < 0.0)[0]
  1608    199.7 MiB      0.0 MiB       18262                       if len(idx) > 0:
  1609                                                                 self.sp_snc[idx] = 0.0
  1610                                         
  1611    199.7 MiB      0.0 MiB       18262                       self.sp_organic_p = self.sp_snc[4:6].sum()
  1612    199.7 MiB      0.0 MiB       18262                       self.sp_sorganic_p = self.sp_snc[6:].sum()
  1613                                                         # END SOIL NUTRIENT DYNAMICS
  1614                                         
  1615    199.7 MiB      0.0 MiB       18262                   if save:
  1616                                                             # Plant uptake and Carbon costs of nutrient uptake
  1617    199.7 MiB      0.0 MiB       18262                       self.storage_pool[:, step] = masked_mean_2D(self.metacomm.mask, storage_pool.astype(np.float32))
  1618    199.7 MiB      0.0 MiB       18262                       self.carbon_costs[step] = masked_mean(self.metacomm.mask, cc)
  1619    199.7 MiB      0.0 MiB       18262                       self.tsoil.append(self.soil_temp)
  1620    199.7 MiB      0.0 MiB       18262                       self.photo[step] = masked_mean(self.metacomm.mask, photo)
  1621    199.7 MiB      0.0 MiB       18262                       self.aresp[step] = masked_mean(self.metacomm.mask, aresp)
  1622    199.7 MiB      0.0 MiB       18262                       self.npp[step] = masked_mean(self.metacomm.mask, npp)
  1623    199.7 MiB      0.0 MiB       18262                       self.rnpp[step] = masked_mean(self.metacomm.mask, rnpp_mt)
  1624    199.7 MiB      0.0 MiB       18262                       self.lai[step] = masked_mean(self.metacomm.mask, lai)
  1625    199.7 MiB      0.0 MiB       18262                       self.rcm[step] = masked_mean(self.metacomm.mask, rcm)
  1626    199.7 MiB      0.0 MiB       18262                       self.f5[step] = masked_mean(self.metacomm.mask, f5)
  1627    199.7 MiB      0.0 MiB       18262                       self.rm[step] = masked_mean(self.metacomm.mask, rm)
  1628    199.7 MiB      0.0 MiB       18262                       self.rg[step] = masked_mean(self.metacomm.mask, rg)
  1629    199.7 MiB      0.0 MiB       18262                       self.wue[step] = masked_mean(self.metacomm.mask, wue)
  1630    199.7 MiB      0.0 MiB       18262                       self.cue[step] = masked_mean(self.metacomm.mask, cue)
  1631    199.7 MiB      0.0 MiB       18262                       self.carbon_deficit[step] = masked_mean(self.metacomm.mask, carbon_deficit)
  1632    199.7 MiB      0.0 MiB       18262                       self.vcmax[step] = masked_mean(self.metacomm.mask, vcmax)
  1633    199.7 MiB      0.0 MiB       18262                       self.specific_la[step] = masked_mean(self.metacomm.mask, specific_la)
  1634    199.7 MiB      0.0 MiB       18262                       self.hresp[step] = soil_out['hr']
  1635    199.7 MiB      0.0 MiB       18262                       self.csoil[:, step] = soil_out['cs']
  1636    199.7 MiB      0.0 MiB       18262                       self.wsoil[step] = self.swp.calc_total_water()
  1637    199.7 MiB      0.0 MiB       18262                       self.inorg_n[step] = self.sp_in_n
  1638    199.7 MiB      0.0 MiB       18262                       self.inorg_p[step] = self.sp_in_p
  1639    199.7 MiB      0.0 MiB       18262                       self.sorbed_n[step] = self.sp_so_n
  1640    199.7 MiB      0.0 MiB       18262                       self.sorbed_p[step] = self.sp_so_p
  1641    199.7 MiB      0.0 MiB       18262                       self.snc[:, step] = soil_out['snc']
  1642    199.7 MiB      0.0 MiB       18262                       self.nmin[step] = self.sp_available_n
  1643    199.7 MiB      0.0 MiB       18262                       self.pmin[step] = self.sp_available_p
  1644    199.7 MiB      0.0 MiB       18262                       self.ls[step] = living_pls
  1645                                         
  1646                                                     # <- Out of the daily loop
  1647                                                     # Save the spin data
  1648                                                     sv: Thread
  1649    199.7 MiB      0.0 MiB           1               if save:
  1650    199.7 MiB      0.0 MiB           1                   if s > 0:
  1651                                                             sv.join()  # Wait for the previous thread to finish
  1652                                                             self.flush_data = None
  1653    199.7 MiB      0.0 MiB           1                   self.executed_iterations.append((start_date, end_date))
  1654    199.7 MiB      0.0 MiB           2                   self.flush_data = self._flush_output(
  1655    199.7 MiB      0.0 MiB           1                       'spin', (self.start_index, self.end_index))
  1656    199.7 MiB      0.0 MiB           1                   sv = Thread(target=self._save_output, args=(self.flush_data,))
  1657    199.8 MiB      0.1 MiB           1                   sv.start()
  1658                                                 # <- Out of spin loop
  1659                                                 # Manage the last thread
  1660    199.8 MiB      0.0 MiB           1           if save:
  1661    195.3 MiB     -4.5 MiB           1               sv.join()  # Wait for the last thread to finish
  1662    195.3 MiB      0.0 MiB           1               self.flush_data = None
  1663                                         
  1664                                         
  1665                                                 # Restablish new communities in the end, if applicable
  1666    195.3 MiB     -0.0 MiB           1           if kill_and_reset:
  1667                                                     assert not save, "Cannot save data when resetting communities"
  1668                                                     for community in self.metacomm:
  1669                                                         # with lock:
  1670                                                         new_life_strategies = self.get_from_main_array(community.npls)
  1671                                                         community.restore_from_main_table(new_life_strategies)
  1672                                                     # Here we update the metacomm mask to ensure that all communities are active again
  1673                                                     self.metacomm.update_mask()
  1674                                         
  1675    195.2 MiB     -0.0 MiB           1           return None



Progress: |██████████████████████████████| 100.00% Complete

Progress: |------------------------------| 0.00% CompleteFilename: C:\Users\darel\OneDrive\Desktop\CAETE\src\caete.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
  1013    188.6 MiB    188.6 MiB           1       @profile
  1014                                             # @timer
  1015                                             def run_gridcell(self,
  1016                                                           start_date: str,
  1017                                                           end_date: str,
  1018                                                           spinup: int = 0,
  1019                                                           fixed_co2_atm_conc: Optional[str] | Optional[int] | Optional[float] = None,
  1020                                                           save: bool = True,
  1021                                                           nutri_cycle: bool = True,
  1022                                                           afex: bool = False,
  1023                                                           reset_community: bool = False,
  1024                                                           kill_and_reset: bool = False,
  1025                                                           env_filter: bool = False,
  1026                                                           process_limitation: bool = False,
  1027                                                           verbose: bool = False):
  1028                                                 """
  1029                                                 Run the model for a grid cell.
  1030                                         
  1031                                                 CAETÊ-DVM execution in the start_date - end_date period, can be used for spinup or transient runs.
  1032                                         
  1033                                                 Args:
  1034                                                     start_date (str): Start date for model execution in "yyyymmdd" format.
  1035                                                     end_date (str): End date for model execution in "yyyymmdd" format.
  1036                                                     spinup (int, optional): Number of repetitions in spinup. Set to 0 for a transient run between start_date and end_date. Default is 0.
  1037                                                     fixed_co2_atm_conc (Optional[Union[str, int, float]]): Fixed atmospheric CO2 concentration. If None, use dynamic CO2 levels from a predefined file. If a string with a year (e.g., "1987") That year's value in the provided file will be used. Use a float to set a fixed level in ppm. Default is None.
  1038                                                     save (bool, optional): Whether to save the results. Default is True.
  1039                                                     nutri_cycle (bool, optional): Whether to include nutrient cycling in the model. Default is True.
  1040                                                     afex (bool, optional): Whether to apply nutrient addition to soil in the model. Default is False.
  1041                                                     reset_community (bool, optional): Whether to restart a new community if there are not viable PLS. Default is False.
  1042                                                     kill_and_reset (bool, optional): Whether to kill and reset the community structure at the end of execution (only CVEG pools and PLS IDs). Default is False.
  1043                                                     env_filter (bool, optional): Whether to apply environmental filtering (Include new PLS periodically) []. Default is False.
  1044                                                     verbose (bool, optional): Whether to print detailed logs during execution. Default is False.
  1045                                         
  1046                                                 Returns:
  1047                                                     None
  1048                                         
  1049                                                 Notes:
  1050                                                     - If reset_community is true a new community will be set (reset) when there is no PLSs remaining.
  1051                                                     - If the kill_and_reset is true, after n spins (integer given by spinup parameter - i.e. in the end
  1052                                                       of function execution) all the communities in a gridcell are reset. The reset_community and
  1053                                                       kill_and_reset  arguments are not mutually exclusive. You can use both as true at the same time.
  1054                                                     - The env_filter argument is used to define if new unique PLSs from the main table will be
  1055                                                       seed in the communities that have free slots (PLSs that are not producing). At the moment, the
  1056                                                       interval for the env_filter to add a new PLS to the community is set to  ~15 days.
  1057                                                       If env filter argument is true, then the reset_community argument will have a very low
  1058                                                       probability to trigger a reset because the communities will be constantly filled with new PLS.
  1059                                                       Nonetheless, the reset_community argument will still be able to trigger a reset if the community loses all PLSs.
  1060                                                       With the probability of a reset_community increasing as the interval between new seeds increases. The parameter doy_months
  1061                                                       in the config file (caete.toml) is used to define the interval for the env_filter to add a new PLS to the community.
  1062                                         
  1063                                                       TODO: Implement a more flexible way to define the interval for
  1064                                                             the env_filter to add a new PLS to the community.
  1065                                                 """
  1066                                         
  1067    188.6 MiB      0.0 MiB           1           assert not fixed_co2_atm_conc or\
  1068                                                     isinstance(fixed_co2_atm_conc, str) or\
  1069                                                     fixed_co2_atm_conc > 0,\
  1070                                                         "A fixed value for ATM[CO2] must be a positive number greater than zero or a proper string with the year - e.g., 'yyyy'"
  1071                                         
  1072                                         
  1073                                                 # Define start and end dates (read parameters)
  1074    188.6 MiB      0.0 MiB           1           start = parse_date(start_date)
  1075    188.6 MiB      0.0 MiB           1           end = parse_date(end_date)
  1076                                         
  1077                                                 # Check dates
  1078    188.6 MiB      0.0 MiB           1           assert start < end, "Start date must be before end date"
  1079    188.7 MiB      0.0 MiB           1           assert start >= self.start_date, "initial date out of bounds for the time array"
  1080    188.7 MiB      0.0 MiB           1           assert end <= self.end_date, f"Final date out of bounds for the time array"
  1081                                         
  1082                                         
  1083                                                 # Define time index bounds for this run
  1084                                                 # During a run we are in general using a slice ov the available time span
  1085                                                 # to run the model. For example, we can run the model for a year or a decade
  1086                                                 # at the begining of the input data time series to spin up. This slice is defined
  1087                                                 # by the start and end dates provided in the arguments. Here we get the indices.
  1088    188.7 MiB      0.1 MiB           1           self.start_index = int(cftime.date2num(start, self.time_unit, self.calendar))
  1089    188.7 MiB      0.0 MiB           1           self.end_index =   int(cftime.date2num(end, self.time_unit, self.calendar))
  1090                                         
  1091                                                 # Find the indices in the time array [used to slice the timeseries with driver data  - tas, pr, etc.]
  1092    189.0 MiB      0.3 MiB           1           lower_bound, upper_bound = self.find_index(self.start_index, self.end_index)
  1093                                         
  1094                                                 # Define the time steps range (days)
  1095    189.0 MiB      0.0 MiB           1           steps = np.arange(lower_bound, upper_bound + 1, dtype=np.int64)
  1096                                         
  1097                                                 # Define the number of repetitions for the spinup
  1098    189.0 MiB      0.0 MiB           1           spin = 1 if spinup == 0 else spinup
  1099                                         
  1100                                                 # Define the AFEX mode
  1101    189.0 MiB      0.0 MiB           1           afex_mode = self.afex_config.afex_mode # type: ignore
  1102                                         
  1103                                                 # Slice&Catch climatic input and make conversions
  1104    189.0 MiB      0.0 MiB           1           cv = self.config.conversion_factors_isimip # type: ignore
  1105                                         
  1106                                         
  1107    189.0 MiB      0.0 MiB           1           if self.config.input_handler.input_method == "ih" and self.config.input_handler.input_type == "netcdf":
  1108                                                     # Variables in Netcdf files are already in proprer units
  1109    189.0 MiB      0.0 MiB           1               temp: NDArray[np.float32] = self.tas[lower_bound: upper_bound + 1]   # Air temp: model uses °C
  1110    189.0 MiB      0.0 MiB           1               prec: NDArray[np.float32] = self.pr[lower_bound: upper_bound + 1]    # Precipitation: model uses  mm/day
  1111    189.0 MiB      0.0 MiB           1               p_atm: NDArray[np.float32] = self.ps[lower_bound: upper_bound + 1]   # Atmospheric pressure: model uses hPa
  1112    189.0 MiB      0.0 MiB           1               ipar: NDArray[np.float32] = self.rsds[lower_bound: upper_bound + 1]  # PAR: model uses  mol(photons) m-2 s-1
  1113    189.0 MiB      0.0 MiB           1               ru: NDArray[np.float32] = self.rhs[lower_bound: upper_bound + 1]     # Relative humidity: model uses 0-1
  1114                                                 else:
  1115                                                     temp: NDArray[np.float32] = self.tas[lower_bound: upper_bound + 1] - cv.tas    # Air temp: model uses °C
  1116                                                     prec: NDArray[np.float32] = self.pr[lower_bound: upper_bound + 1] * cv.pr      # Precipitation: model uses  mm/day
  1117                                                     p_atm: NDArray[np.float32] = self.ps[lower_bound: upper_bound + 1] * cv.ps     # Atmospheric pressure: model uses hPa
  1118                                                     ipar: NDArray[np.float32] = self.rsds[lower_bound: upper_bound + 1] * cv.rsds  # PAR: model uses  mol(photons) m-2 s-1
  1119                                                     ru: NDArray[np.float32] = self.rhs[lower_bound: upper_bound + 1] * cv.rhs      # Relative humidity: model uses 0-1
  1120                                         
  1121                                                 # Define the daily values for co2 concentrations
  1122    189.0 MiB      0.0 MiB           1           co2_daily_values = np.zeros(steps.size, dtype=np.float32)
  1123                                         
  1124    189.0 MiB      0.0 MiB           1           if fixed_co2_atm_conc is None:
  1125                                                     # In this case, the co2 concentration will be updated daily.
  1126                                                     # We interpolate linearly between the yearly values of the atm co2 data
  1127    189.0 MiB      0.0 MiB           1               co2 = self.find_co2(start.year)
  1128    189.0 MiB      0.0 MiB           1               today = datetime(start.year, start.month, start.day, start.hour, start.minute, start.second)
  1129    189.0 MiB      0.0 MiB           1               time_step = timedelta(days=1) # Define the time step
  1130    189.0 MiB      0.0 MiB           1               today -= time_step # The first thing we do next is to add a day to the date. So we go back one day
  1131                                                     # Loop over the days and calculate the co2 concentration for each day
  1132    189.0 MiB      0.0 MiB        5845               for step in range(steps.size):
  1133    189.0 MiB      0.0 MiB        5844                   today += time_step
  1134    189.0 MiB      0.0 MiB        5844                   remaining = (datetime(today.year, 12, 31) - today).days + 1
  1135    189.0 MiB      0.0 MiB        5844                   daily_fraction = (self.find_co2(today.year + 1) - co2) / (remaining + 1)
  1136    189.0 MiB      0.0 MiB        5844                   co2 += daily_fraction
  1137    189.0 MiB      0.0 MiB        5844                   co2_daily_values[step] = co2
  1138                                                 elif isinstance(fixed_co2_atm_conc, int) or isinstance(fixed_co2_atm_conc, float):
  1139                                                     # In this case, the co2 concentration will be fixed according to the numeric value provided in the argument
  1140                                                     co2 = fixed_co2_atm_conc
  1141                                                     co2_daily_values += co2
  1142                                                 elif isinstance(fixed_co2_atm_conc, str):
  1143                                                     # In this case, the co2 concentration will be fixed
  1144                                                     # According to the year provided in the argument
  1145                                                     # as a string. Format "yyyy".
  1146                                                     try:
  1147                                                         co2_year = int(fixed_co2_atm_conc)
  1148                                                     except ValueError:
  1149                                                         raise ValueError(
  1150                                                             "The string(\"yyyy\") must be a number in the {self.start_date.year} - {self.end_date.year} interval")
  1151                                                     co2 = self.find_co2(co2_year)
  1152                                                     co2_daily_values += co2
  1153                                                 else:
  1154                                                     raise ValueError("Invalid value for fixed_co2_atm_conc")
  1155                                         
  1156                                                 # Define variables to track dates
  1157    189.0 MiB      0.0 MiB           1           first_day_of_simulation = datetime(start.year, start.month, start.day, start.hour, start.minute, start.second)
  1158                                                 # Define the time step
  1159    189.0 MiB      0.0 MiB           1           time_step = timedelta(days=1)
  1160                                         
  1161                                                 # Define the object to store the outputs from daily_budget
  1162    189.0 MiB      0.0 MiB           1           daily_output = DailyBudget()
  1163                                         
  1164                                                 # Start loops
  1165                                                 # This outer loop is used to run the model for a number
  1166                                                 # of times defined by the spinup argument. The model is
  1167                                                 # executed repeatedly between the start and end dates
  1168                                                 # provided in the arguments
  1169                                         
  1170    198.1 MiB     -0.0 MiB           5           for s in range(spin):
  1171                                         
  1172    199.2 MiB      5.7 MiB           4               self._allocate_output(steps.size, self.metacomm.comm_npls, len(self.metacomm), save)
  1173                                         
  1174                                                     # Loop over the days
  1175    199.2 MiB      0.0 MiB           4               today = first_day_of_simulation
  1176                                         
  1177                                                     # Go back one day
  1178    199.2 MiB      0.0 MiB           4               today -= time_step
  1179                                         
  1180                                                     # Arrays to store & pass values for each community in a simulated day
  1181    199.2 MiB      0.0 MiB           4               sto =        np.zeros(shape=(3, self.metacomm.comm_npls), order='F')
  1182    199.2 MiB      0.0 MiB           4               cleaf_in =   np.zeros(self.metacomm.comm_npls, order='F')
  1183    199.2 MiB      0.0 MiB           4               cwood_in =   np.zeros(self.metacomm.comm_npls, order='F')
  1184    199.2 MiB      0.0 MiB           4               croot_in =   np.zeros(self.metacomm.comm_npls, order='F')
  1185    199.2 MiB      0.0 MiB           4               uptk_costs = np.zeros(self.metacomm.comm_npls, order='F')
  1186    199.2 MiB      0.0 MiB           4               rnpp_in =    np.zeros(self.metacomm.comm_npls, order='F')
  1187                                         
  1188                                                     # There are two modes of operation: save and not save.
  1189                                                     # In the save == False mode, the arrays are used to store the values that are
  1190                                                     # needed for model iteration, i.e., the values that are used in the next
  1191                                                     # time step. In the save mode, an extra number arrays is created to be used
  1192                                                     # to store the outputs.
  1193    199.2 MiB      0.0 MiB           4               xsize: int = len(self.metacomm) # Number of communities
  1194    199.2 MiB      0.0 MiB           4               evavg: NDArray[np.float32] = np.zeros(xsize, dtype=np.float32)
  1195    199.2 MiB      0.0 MiB           4               epavg: NDArray[np.float32] = np.zeros(xsize, dtype=np.float32)
  1196    199.2 MiB      0.0 MiB           4               rnpp_mt: NDArray[np.float32] = np.zeros(xsize, dtype=np.float32)
  1197                                         
  1198                                                     # We keep track of these to input in SOM dynamics later. They are used for output also
  1199    199.2 MiB      0.0 MiB           4               leaf_litter: NDArray[np.float32] = np.zeros(xsize, dtype=np.float32)
  1200    199.2 MiB      0.0 MiB           4               cwd: NDArray[np.float32] = np.zeros(xsize, dtype=np.float32)
  1201    199.2 MiB      0.0 MiB           4               root_litter: NDArray[np.float32] = np.zeros(xsize, dtype=np.float32)
  1202    199.2 MiB      0.0 MiB           4               lnc: NDArray[np.float32] = np.zeros(shape=(6, xsize), dtype=np.float32)
  1203                                                     # This is added to leaf litter pool (that is basicaly a fast SOM pool)
  1204    199.2 MiB      0.0 MiB           4               c_to_nfixers: NDArray[np.float32]= np.zeros(xsize, dtype=np.float32)
  1205    199.2 MiB      0.0 MiB           4               nupt = np.zeros(shape=(2, xsize), dtype=np.float32)
  1206    199.2 MiB      0.0 MiB           4               pupt = np.zeros(shape=(3, xsize), dtype=np.float32)
  1207                                         
  1208    199.2 MiB      0.0 MiB           4               if save:
  1209    199.2 MiB      0.0 MiB           4                   cc = np.zeros(xsize, dtype=np.float32)
  1210    199.2 MiB      0.0 MiB           4                   photo = np.zeros(xsize, dtype=np.float32)
  1211    199.2 MiB      0.0 MiB           4                   aresp = np.zeros(xsize, dtype=np.float32)
  1212    199.2 MiB      0.0 MiB           4                   npp = np.zeros(xsize, dtype=np.float32)
  1213    199.2 MiB      0.0 MiB           4                   lai = np.zeros(xsize, dtype=np.float32)
  1214    199.2 MiB      0.0 MiB           4                   rcm = np.zeros(xsize, dtype=np.float32)
  1215    199.2 MiB      0.0 MiB           4                   f5 = np.zeros(xsize, dtype=np.float32)
  1216    199.2 MiB      0.0 MiB           4                   rm = np.zeros(xsize, dtype=np.float32)
  1217    199.2 MiB      0.0 MiB           4                   rg = np.zeros(xsize, dtype=np.float32)
  1218    199.2 MiB      0.0 MiB           4                   wue = np.zeros(xsize, dtype=np.float32)
  1219    199.2 MiB      0.0 MiB           4                   cue = np.zeros(xsize, dtype=np.float32)
  1220    199.2 MiB      0.0 MiB           4                   carbon_deficit = np.zeros(xsize, dtype=np.float32)
  1221    199.2 MiB      0.0 MiB           4                   vcmax = np.zeros(xsize, dtype=np.float32)
  1222    199.2 MiB      0.0 MiB           4                   specific_la = np.zeros(xsize, dtype=np.float32)
  1223    199.3 MiB      0.1 MiB           4                   storage_pool = np.zeros(shape=(3, xsize))
  1224                                         
  1225    199.3 MiB      0.0 MiB           4                   if process_limitation:
  1226                                                             lim_status_y_leaf = np.ma.masked_all((xsize, self.metacomm.comm_npls, 366), dtype=np.int8)
  1227                                                             lim_status_y_stem = np.ma.masked_all((xsize, self.metacomm.comm_npls, 366), dtype=np.int8)
  1228                                                             lim_status_y_root = np.ma.masked_all((xsize, self.metacomm.comm_npls, 366), dtype=np.int8)
  1229                                                             uptake_strategy_n = np.ma.masked_all((xsize, self.metacomm.comm_npls, 366), dtype=np.int8)
  1230                                                             uptake_strategy_p = np.ma.masked_all((xsize, self.metacomm.comm_npls, 366), dtype=np.int8)
  1231                                         
  1232                                                     # <- Daily loop
  1233    200.0 MiB -25499.2 MiB       23380               for step in range(steps.size):
  1234    200.0 MiB -25496.1 MiB       23376                   today += time_step
  1235    200.0 MiB -25496.1 MiB       23376                   julian_day = today.timetuple().tm_yday
  1236                                         
  1237                                                         # Get the co2 concentration for the day
  1238    200.0 MiB -25496.1 MiB       23376                   co2 = co2_daily_values[step]
  1239                                                         # Update soil temperature
  1240    200.0 MiB -25496.0 MiB       23376                   self.soil_temp = st.soil_temp(self.soil_temp, temp[step])
  1241                                         
  1242                                                         # AFEX
  1243    200.0 MiB -25496.1 MiB       23376                   if afex and julian_day == 365:
  1244                                                             self.add_soil_nutrients(afex_mode)
  1245                                         
  1246                                                         # Loop over communities
  1247    200.0 MiB -25496.1 MiB       23376                   living_pls = 0 # Sum of living PLS in the communities
  1248    200.0 MiB -50630.6 MiB       46752                   for i, community in enumerate(self.metacomm):
  1249                                                             # if i >= len(self.metacomm):
  1250                                                             #     break
  1251                                                             # if community.masked:
  1252                                                             #     # skip this one
  1253                                                             #     continue
  1254    200.0 MiB -25495.7 MiB       23376                       sto[0, :] = inflate_array(community.npls, community.vp_sto[0, :], community.vp_lsid)
  1255    200.0 MiB -25496.1 MiB       23376                       sto[1, :] = inflate_array(community.npls, community.vp_sto[1, :], community.vp_lsid)
  1256    200.0 MiB -25496.1 MiB       23376                       sto[2, :] = inflate_array(community.npls, community.vp_sto[2, :], community.vp_lsid)
  1257                                         
  1258    200.0 MiB -25495.8 MiB       23376                       cleaf_in[:] = inflate_array(community.npls, community.vp_cleaf, community.vp_lsid)
  1259    200.0 MiB -25496.1 MiB       23376                       cwood_in[:] = inflate_array(community.npls, community.vp_cwood, community.vp_lsid)
  1260    200.0 MiB -25496.1 MiB       23376                       croot_in[:] = inflate_array(community.npls, community.vp_croot, community.vp_lsid)
  1261    200.0 MiB -25496.1 MiB       23376                       uptk_costs[:] = inflate_array(community.npls, community.sp_uptk_costs, community.vp_lsid)
  1262    200.0 MiB -25496.1 MiB       23376                       rnpp_in[:] = inflate_array(community.npls, community.construction_npp, community.vp_lsid)
  1263                                         
  1264    200.0 MiB -25496.1 MiB       23376                       ton = self.sp_organic_n #+ self.sp_sorganic_n
  1265    200.0 MiB -25496.1 MiB       23376                       top = self.sp_organic_p #+ self.sp_sorganic_p
  1266                                         
  1267                                                             # Community daily budget calculation
  1268    200.0 MiB -50994.3 MiB       46752                       out = model.daily_budget(community.pls_array, self.wp_water_upper_mm,
  1269    200.0 MiB -25496.0 MiB       23376                                               self.wp_water_lower_mm, self.soil_temp, temp[step],
  1270    200.0 MiB -25496.1 MiB       23376                                               p_atm[step], ipar[step], ru[step], self.sp_available_n,
  1271    200.0 MiB -25496.1 MiB       23376                                               self.sp_available_p, ton, top, self.sp_organic_p,
  1272    200.0 MiB -25496.1 MiB       23376                                               co2, sto, cleaf_in, cwood_in, croot_in, uptk_costs,self.wmax_mm,
  1273    200.0 MiB -25496.1 MiB       23376                                               rnpp_in)
  1274                                         
  1275                                                             # get daily budget results
  1276    200.0 MiB -25499.5 MiB       23376                       daily_output.update(out)
  1277                                         
  1278                                                             # Update the community status
  1279    200.0 MiB -25134.1 MiB       23376                       community.update_lsid(daily_output.ocpavg)
  1280                                         
  1281                                                             # Abort community if no PLSs are left while saving the spin
  1282    200.0 MiB -25134.5 MiB       23376                       if community.masked and save:
  1283                                                                 continue
  1284                                         
  1285    200.0 MiB -25134.5 MiB       23376                       community.ls = community.vp_lsid.size
  1286                                                             # # Restore or seed PLS
  1287    200.0 MiB -25134.5 MiB       23376                       if env_filter and (community.ls < self.metacomm.comm_npls) and not save:
  1288                                                                 if julian_day in self.doy_months:
  1289                                                                     new_id, new_PLS = community.get_unique_pls(self.get_from_main_array)
  1290                                                                     community.seed_pls(new_id, new_PLS, daily_output.cleafavg_pft,
  1291                                                                                        daily_output.cfrootavg_pft, daily_output.cawoodavg_pft)
  1292                                                                     if verbose: print(f"PLS seed in Community {i}: Gridcell: {self.lat} °N, {self.lon} °E: In spin:{s}, step:{step}")
  1293                                         
  1294                                                                     daily_output.ocpavg = pft_area_frac64(daily_output.cleafavg_pft,
  1295                                                                                                     daily_output.cfrootavg_pft,
  1296                                                                                                     daily_output.cawoodavg_pft)
  1297                                                                     community.update_lsid(daily_output.ocpavg)
  1298                                                                     community.ls = community.vp_lsid.size
  1299                                                                 # endif
  1300                                         
  1301                                         
  1302    200.0 MiB -25134.4 MiB       23376                       community.vp_ocp = daily_output.ocpavg[community.vp_lsid]
  1303    200.0 MiB -25134.4 MiB       23376                       community.vp_cleaf = daily_output.cleafavg_pft[community.vp_lsid]
  1304    200.0 MiB -25134.4 MiB       23376                       community.vp_cwood = daily_output.cawoodavg_pft[community.vp_lsid]
  1305    200.0 MiB -25134.4 MiB       23376                       community.vp_croot = daily_output.cfrootavg_pft[community.vp_lsid]
  1306    200.0 MiB -25134.4 MiB       23376                       community.vp_sto = daily_output.stodbg[:, community.vp_lsid].astype('float32')
  1307    200.0 MiB -25134.4 MiB       23376                       community.sp_uptk_costs = daily_output.npp2pay[community.vp_lsid]
  1308    200.0 MiB -25134.4 MiB       23376                       community.construction_npp = daily_output.rnpp_out[community.vp_lsid]
  1309    200.0 MiB -25134.4 MiB       23376                       living_pls += community.ls
  1310                                                             # print(f"Community storage: {community.vp_sto[0, :]}")
  1311                                                             # print(f"Sto_budget_out {daily_output.stodbg[0, :]}")
  1312                                         
  1313                                                             # Limiting nutrient organization:
  1314                                                             # dim1 = leaf wood root, code: 1=N 2=P 4=N,COLIM 5=P,COLIM 6=COLIM 0=NOLIM
  1315    200.0 MiB -25134.4 MiB       23376                       if save:
  1316    200.0 MiB -25134.4 MiB       23376                           if process_limitation:
  1317                                                                     lim_status_y_leaf[i, :, julian_day - 1] = daily_output.limitation_status[0,:]# type: ignore
  1318                                                                     lim_status_y_stem[i, :, julian_day - 1] = daily_output.limitation_status[1,:]# type: ignore
  1319                                                                     lim_status_y_root[i, :, julian_day - 1] = daily_output.limitation_status[2,:]# type: ignore
  1320                                                                     uptake_strategy_n[i, :, julian_day - 1] = daily_output.uptk_strat[0,:]# type: ignore
  1321                                                                     uptake_strategy_p[i, :, julian_day - 1] = daily_output.uptk_strat[1,:]# type: ignore
  1322                                         
  1323    200.0 MiB -25134.4 MiB       23376                           community.anpp += cw_mean(community.vp_ocp, community.construction_npp.astype(np.float32))
  1324    200.0 MiB -25134.4 MiB       23376                           community.uptake_costs += cw_mean(community.vp_ocp, community.sp_uptk_costs.astype(np.float32))
  1325                                         
  1326    200.0 MiB -25134.4 MiB       23376                       if save and julian_day == 365:
  1327    198.1 MiB    -68.9 MiB          64                           community.cleaf = cw_mean(community.vp_ocp, community.vp_cleaf.astype(np.float32))
  1328    198.1 MiB     -0.7 MiB          64                           community.cwood = cw_mean(community.vp_ocp, community.vp_cwood.astype(np.float32))
  1329    198.1 MiB     -0.7 MiB          64                           community.croot = cw_mean(community.vp_ocp, community.vp_croot.astype(np.float32))
  1330    198.1 MiB     -0.7 MiB          64                           community.csto = cw_mean(community.vp_ocp, community.vp_sto[0, :])
  1331    198.1 MiB     -0.3 MiB          64                           community.shannon_diversity = shannon_diversity(community.vp_ocp)
  1332    198.1 MiB     -0.5 MiB          64                           community.shannon_entropy = shannon_entropy(community.vp_ocp)
  1333    198.1 MiB     -0.4 MiB          64                           community.shannon_evenness = shannon_evenness(community.vp_ocp)
  1334                                         
  1335                                                                 # process limitation data
  1336                                                                 # Filter non living PLS from the limitation status
  1337    198.1 MiB     -0.7 MiB          64                           if process_limitation:
  1338                                                                     _data_leaf = lim_status_y_leaf[i, [community.vp_lsid], :] # type: ignore
  1339                                                                     _data_stem = lim_status_y_stem[i, [community.vp_lsid], :] # type: ignore
  1340                                                                     _data_root = lim_status_y_root[i, [community.vp_lsid], :] # type: ignore
  1341                                         
  1342                                                                     _data_uptake_n = uptake_strategy_n[i, [community.vp_lsid], :]# type: ignore
  1343                                                                     _data_uptake_p = uptake_strategy_p[i, [community.vp_lsid], :]# type: ignore
  1344                                         
  1345                                                                     # Loop over the living PLS to get the unique values and counts
  1346                                                                     pls_lim_leaf = []
  1347                                                                     pls_lim_stem = []
  1348                                                                     pls_lim_root = []
  1349                                                                     pls_uptake_n = []
  1350                                                                     pls_uptake_p = []
  1351                                         
  1352                                                                     for k in range(community.vp_lsid.size):
  1353                                                                         # Get the unique values and counts for leaf limitation
  1354                                                                         unique, counts = np.unique(_data_leaf[0, k, :], return_counts=True)
  1355                                                                         unique = unique.data[unique.mask == False] # type: ignore
  1356                                                                         pls_lim_leaf.append((unique, counts[:unique.size])) # type: ignore
  1357                                         
  1358                                                                         # Stem limitation
  1359                                                                         unique, counts = np.unique(_data_stem[0, k, :], return_counts=True)
  1360                                                                         unique = unique.data[unique.mask == False] # type: ignore
  1361                                                                         pls_lim_stem.append((unique, counts[:unique.size])) # type: ignore
  1362                                         
  1363                                                                         # Root limitation
  1364                                                                         unique, counts = np.unique(_data_root[0, k, :], return_counts=True)
  1365                                                                         unique = unique.data[unique.mask == False]
  1366                                                                         pls_lim_root.append((unique, counts[:unique.size])) # type: ignore
  1367                                         
  1368                                                                         # Uptake strategy N
  1369                                                                         unique, counts = np.unique(_data_uptake_n[0, k, :], return_counts=True)
  1370                                                                         unique = unique.data[unique.mask == False] # type: ignore
  1371                                                                         pls_uptake_n.append((unique, counts[:unique.size])) # type: ignore
  1372                                         
  1373                                                                         # Uptake strategy P
  1374                                                                         unique, counts = np.unique(_data_uptake_p[0, k, :], return_counts=True)
  1375                                                                         unique = unique.data[unique.mask == False]  # type: ignore
  1376                                                                         pls_uptake_p.append((unique, counts[:unique.size])) # type: ignore
  1377                                         
  1378                                                                     community.limitation_status_leaf = pls_lim_leaf
  1379                                                                     community.limitation_status_wood = pls_lim_stem
  1380                                                                     community.limitation_status_root = pls_lim_root
  1381                                                                     community.uptake_strategy_n = pls_uptake_n
  1382                                                                     community.uptake_strategy_p = pls_uptake_p
  1383                                         
  1384                                                                     # Reset the limitation masked arrays
  1385                                                                     lim_status_y_leaf.mask[i, :, :] = np.ones((self.metacomm.comm_npls, 366), dtype=bool) # type: ignore
  1386                                                                     lim_status_y_stem.mask[i, :, :] = np.ones((self.metacomm.comm_npls, 366), dtype=bool) # type: ignore
  1387                                                                     lim_status_y_root.mask[i, :, :] = np.ones((self.metacomm.comm_npls, 366), dtype=bool) # type: ignore
  1388                                                                     uptake_strategy_n.mask[i, :, :] = np.ones((self.metacomm.comm_npls, 366), dtype=bool) # type: ignore
  1389                                                                     uptake_strategy_p.mask[i, :, :] = np.ones((self.metacomm.comm_npls, 366), dtype=bool) # type: ignore
  1390                                                                 else:
  1391    198.1 MiB     -0.7 MiB          64                               pass
  1392                                         
  1393    200.0 MiB -25066.1 MiB       23376                       if community.vp_lsid.size < 1:
  1394                                                                 if verbose: print(f"Empty community {i}: Gridcell: {self.lat} °N, {self.lon} °E: In spin:{s}, step:{step}")
  1395                                                                 if reset_community:
  1396                                                                     assert not save, "Cannot save data when resetting communities"
  1397                                                                     if verbose: print(f"Reseting community {i}: Gridcell: {self.lat} °N, {self.lon} °E: In spin:{s}, step:{step}")
  1398                                         
  1399                                                                     new_life_strategies = self.get_from_main_array(community.npls)
  1400                                                                     community.restore_from_main_table(new_life_strategies)
  1401                                                                     # continue
  1402                                         
  1403                                                                 else:
  1404                                                                     # In the transiant run - i.e., when reset_community is false and
  1405                                                                     # kill_and_reset is false; we mask the community if there is no PLS
  1406                                                                     self.metacomm.mask[i] = np.int8(1)
  1407                                                                     # Set mask to true for this community, will not run in the next steps
  1408                                                                     # Set annual values to zero
  1409                                                                     community.masked = np.int8(1)
  1410                                                                     community.cleaf = np.float32(0.0)
  1411                                                                     community.cwood = np.float32(0.0)
  1412                                                                     community.croot = np.float32(0.0)
  1413                                                                     community.csto  = np.float32(0.0)
  1414                                                                     community.shannon_diversity = -9999.0
  1415                                                                     community.shannon_entropy = -9999.0
  1416                                                                     community.shannon_evenness = -9999.0
  1417                                                                     # if the reset_community is true
  1418                                                                     # continue # cycle
  1419                                         
  1420                                                             # Store values for each community
  1421    200.0 MiB -25134.4 MiB       23376                       rnpp_mt[i] = cw_mean(community.vp_ocp, community.construction_npp.astype(np.float32)) # Community Weighted rNPP
  1422    200.0 MiB -25134.4 MiB       23376                       leaf_litter[i] = daily_output.litter_l
  1423    200.0 MiB -25134.4 MiB       23376                       root_litter[i] = daily_output.litter_fr
  1424    200.0 MiB -25134.4 MiB       23376                       cwd[i] = daily_output.cwd
  1425    200.0 MiB -25134.4 MiB       23376                       lnc[:, i] = daily_output.lnc.astype(np.float32)
  1426    200.0 MiB -25134.5 MiB       23376                       c_to_nfixers[i] = daily_output.cp[3]
  1427    200.0 MiB -25134.5 MiB       23376                       evavg[i] = daily_output.evavg
  1428    200.0 MiB -25134.5 MiB       23376                       epavg[i] = daily_output.epavg
  1429    200.0 MiB -25134.5 MiB       23376                       nupt[:, i] = daily_output.nupt #type: ignore
  1430    200.0 MiB -25134.5 MiB       23376                       pupt[:, i] = daily_output.pupt #type: ignore
  1431                                         
  1432    200.0 MiB -25134.5 MiB       23376                       if save:
  1433    200.0 MiB -25134.5 MiB       23376                           cc[i] = daily_output.c_cost_cwm #type: ignore
  1434    200.0 MiB -25134.5 MiB       23376                           npp[i] = daily_output.nppavg #type: ignore
  1435    200.0 MiB -25134.5 MiB       23376                           photo[i] = daily_output.phavg #type: ignore
  1436    200.0 MiB -25134.4 MiB       23376                           aresp[i] = daily_output.aravg #type: ignore
  1437    200.0 MiB -25134.5 MiB       23376                           lai[i] = daily_output.laiavg #type: ignore
  1438    200.0 MiB -25134.5 MiB       23376                           rcm[i] = daily_output.rcavg #type: ignore
  1439    200.0 MiB -25134.5 MiB       23376                           f5[i] = daily_output.f5avg #type: ignore
  1440    200.0 MiB -25134.5 MiB       23376                           rm[i] = daily_output.rmavg #type: ignore
  1441    200.0 MiB -25134.5 MiB       23376                           rg[i] = daily_output.rgavg #type: ignore
  1442    200.0 MiB -25134.5 MiB       23376                           wue[i] = daily_output.wueavg #type: ignore
  1443    200.0 MiB -25134.5 MiB       23376                           cue[i] = daily_output.cueavg #type: ignore
  1444    200.0 MiB -25134.5 MiB       23376                           carbon_deficit[i] = daily_output.c_defavg #type: ignore
  1445    200.0 MiB -25134.5 MiB       23376                           vcmax[i] = daily_output.vcmax #type: ignore
  1446    200.0 MiB -25134.5 MiB       23376                           specific_la[i] = daily_output.specific_la #type: ignore
  1447                                         
  1448    200.0 MiB -100537.8 MiB       93504                           for j in range(daily_output.stodbg.shape[0]):
  1449    200.0 MiB -75403.4 MiB       70128                               storage_pool[j, i] = cw_mean(community.vp_ocp, community.vp_sto[j, :]) #type: ignore
  1450                                         
  1451                                                         #<- Out of the community loop
  1452                                                         # Save annual state of the metacommunity
  1453    200.0 MiB -25499.5 MiB       23376                   if save:
  1454    200.0 MiB -25134.4 MiB       23376                       if julian_day == 365:
  1455    198.1 MiB    -68.9 MiB          64                           y = today.year
  1456                                                                 # m = today.month
  1457                                                                 # d = today.day
  1458    198.1 MiB     -0.7 MiB          64                           filename = self.out_dir/f"metacommunity_{y}.pkz"
  1459                                                                 # filename = self.out_dir/f"metacommunity_{d}{m}{y}.pkz"
  1460    198.1 MiB     -0.3 MiB          64                           self.metacomm.save_state(filename, y, process_limitation)
  1461    198.1 MiB     -0.7 MiB          64                           self.metacomm_output[y] = filename
  1462                                         
  1463    198.1 MiB     -1.3 MiB         128                           for community in self.metacomm:
  1464                                                                     # Set annual accumulators to zero
  1465    198.1 MiB     -0.7 MiB          64                               community.anpp = np.float32(0.0)
  1466    198.1 MiB     -0.7 MiB          64                               community.uptake_costs = np.float32(0.0)
  1467                                         
  1468                                                         # ------------
  1469                                                         # Evapotranspiration
  1470    200.0 MiB -25066.2 MiB       23376                   et = masked_mean(self.metacomm.mask, evavg) #evavg.mean()
  1471                                                         ## Canopy-atmosphere coupling [EXPERIMENTAL]
  1472                                                         # vpd = m.vapor_p_deficit(temp[step], ru[step])
  1473                                                         # et_pot = masked_mean(self.metacomm.mask, np.array(epavg).astype(np.float32)) #epavg.mean()
  1474                                                         # self.evapm[step] = atm_canopy_coupling(et_pot, et, temp[step], vpd)
  1475    200.0 MiB -25134.5 MiB       23376                   self.evapm[step] = et
  1476                                         
  1477                                                         # Update water pools
  1478                                         
  1479    200.0 MiB -25134.3 MiB       23376                   self.runom[step] = self.swp._update_pool(prec[step], self.evapm[step])
  1480    200.0 MiB -25134.5 MiB       23376                   self.swp.w1 = 0.0 if self.swp.w1 < 0.0 else self.swp.w1
  1481    200.0 MiB -25134.5 MiB       23376                   self.swp.w2 = 0.0 if self.swp.w2 < 0.0 else self.swp.w2
  1482    200.0 MiB -25134.5 MiB       23376                   self.wp_water_upper_mm = self.swp.awc1
  1483    200.0 MiB -25134.4 MiB       23376                   self.wp_water_lower_mm = self.swp.awc2
  1484    200.0 MiB -25499.5 MiB       23376                   wtot = self.swp.w1 + self.swp.w2
  1485                                         
  1486                                                         # Update cflux to the soil for output, mean values over the communities
  1487                                                         # Values are also used to update SOM dynamics
  1488    200.0 MiB -50998.9 MiB       46752                   self.litter_l[step] = masked_mean(self.metacomm.mask, leaf_litter) +\
  1489    200.0 MiB -25499.5 MiB       23376                                         masked_mean(self.metacomm.mask, c_to_nfixers)
  1490    200.0 MiB -25499.5 MiB       23376                   self.cwd[step] = masked_mean(self.metacomm.mask, cwd)
  1491    200.0 MiB -25499.5 MiB       23376                   self.litter_fr[step] = masked_mean(self.metacomm.mask, root_litter)
  1492    200.0 MiB -25499.5 MiB       23376                   self.lnc[:, step] = masked_mean_2D(self.metacomm.mask, lnc)
  1493                                         
  1494                                                         # Soil C:N:P balance and OM decomposition
  1495    200.0 MiB -50998.9 MiB       46752                   s_out = soil_dec.carbon3(self.soil_temp, wtot / self.wmax_mm, self.litter_l[step],
  1496    200.0 MiB -25499.5 MiB       23376                                            self.cwd[step], self.litter_fr[step], self.lnc[:, step],
  1497    200.0 MiB -25499.5 MiB       23376                                            self.sp_csoil, self.sp_snc)
  1498    200.0 MiB -25499.5 MiB       23376                   soil_out = catch_out_carbon3(s_out)
  1499                                         
  1500                                                         # Organic C N & P
  1501    200.0 MiB -25499.5 MiB       23376                   self.sp_csoil = soil_out['cs']
  1502    200.0 MiB -25499.4 MiB       23376                   self.sp_snc = np.zeros(shape=8)
  1503    200.0 MiB -25499.5 MiB       23376                   self.sp_snc = soil_out['snc']
  1504    200.0 MiB -25499.4 MiB       23376                   idx = np.where(self.sp_snc < 0.0)[0]
  1505    200.0 MiB -25499.5 MiB       23376                   if len(idx) > 0:
  1506                                                             self.sp_snc[idx] = 0.0
  1507                                         
  1508                                                         # <- Out of the community loop
  1509    200.0 MiB -25499.5 MiB       23376                   self.nupt[:, step] = masked_mean_2D(self.metacomm.mask, nupt)
  1510    200.0 MiB -25499.5 MiB       23376                   self.pupt[:, step] = masked_mean_2D(self.metacomm.mask, pupt)
  1511                                         
  1512                                                         # TODO: Soil nutrient dynamics. Isolate this if branch into a separate method/class/function
  1513                                                         # Critical part of soil nutrient dynamics and availability for plants
  1514                                                         # IF NUTRICYCLE
  1515    200.0 MiB -25499.5 MiB       23376                   if nutri_cycle:
  1516                                                             # UPDATE ORGANIC POOLS
  1517    200.0 MiB -25499.3 MiB       23376                       self.sp_organic_n = self.sp_snc[:2].sum()
  1518    200.0 MiB -25499.4 MiB       23376                       self.sp_sorganic_n = self.sp_snc[2:4].sum()
  1519    200.0 MiB -25499.4 MiB       23376                       self.sp_organic_p = self.sp_snc[4:6].sum()
  1520    200.0 MiB -25499.4 MiB       23376                       self.sp_sorganic_p = self.sp_snc[6:].sum()
  1521                                         
  1522                                                             # Update inorganic pools
  1523    200.0 MiB -25499.4 MiB       23376                       self.sp_available_p += soil_out['pmin']
  1524    200.0 MiB -25499.4 MiB       23376                       self.sp_available_n += soil_out['nmin']
  1525    200.0 MiB -25499.4 MiB       23376                       self.sp_available_p -= self.pupt[0, step]
  1526    200.0 MiB -25499.4 MiB       23376                       self.sp_available_n -= self.nupt[0, step]
  1527                                         
  1528                                                             # NUTRIENT DINAMICS
  1529                                         
  1530                                                             # Inorganic N
  1531                                                             # TODO: NaNs are being sourced upstream , need to track the source and fix it
  1532                                         
  1533    200.0 MiB -25499.4 MiB       23376                       if not np.isfinite(self.sp_in_n):
  1534                                                                 # rwarn(f"Non-finite value detected in sp_in_n pool at step {step}. Resetting to zero.")
  1535                                                                 self.sp_in_n = 0.0
  1536    200.0 MiB -25499.4 MiB       23376                       if not np.isfinite(self.sp_available_n):
  1537                                                                 # rwarn(f"Non-finite value detected in sp_available_n pool at step {step}. Resetting to zero.")
  1538                                                                 self.sp_available_n = 0.0
  1539    200.0 MiB -25499.4 MiB       23376                       if not np.isfinite(self.sp_so_n):
  1540                                                                 # rwarn(f"Non-finite value detected in sp_so_n pool at step {step}. Resetting to zero.")
  1541                                                                 self.sp_so_n = 0.0
  1542                                         
  1543    200.0 MiB -25499.4 MiB       23376                       self.sp_in_n += self.sp_available_n + self.sp_so_n
  1544    200.0 MiB -25499.4 MiB       23376                       self.sp_so_n = soil_dec.sorbed_n_equil(self.sp_in_n)
  1545    200.0 MiB -25499.4 MiB       23376                       self.sp_available_n = soil_dec.solution_n_equil(self.sp_in_n)
  1546    200.0 MiB -25499.4 MiB       23376                       self.sp_in_n -= (self.sp_so_n + self.sp_available_n)
  1547                                         
  1548                                                             # Inorganic P
  1549    200.0 MiB -25499.5 MiB       23376                       if not np.isfinite(self.sp_in_p):
  1550                                                                 # rwarn(f"Non-finite value detected in sp_in_p pool at step {step}. Resetting to zero.")
  1551                                                                 self.sp_in_p = 0.0
  1552    200.0 MiB -25499.4 MiB       23376                       if not np.isfinite(self.sp_available_p):
  1553                                                                 # rwarn(f"Non-finite value detected in sp_available_p pool at step {step}. Resetting to zero.")
  1554                                                                 self.sp_available_p = 0.0
  1555    200.0 MiB -25499.5 MiB       23376                       if not np.isfinite(self.sp_so_p):
  1556                                                                 # rwarn(f"Non-finite value detected in sp_so_p pool at step {step}. Resetting to zero.")
  1557                                                                 self.sp_so_p = 0.0
  1558                                         
  1559    200.0 MiB -25499.5 MiB       23376                       self.sp_in_p += self.sp_available_p + self.sp_so_p
  1560                                                             # sp_so_p is the occluded P in the inorganic pool
  1561    200.0 MiB -25499.5 MiB       23376                       self.sp_so_p = soil_dec.sorbed_p_equil(self.sp_in_p)
  1562                                                             # THe fraction that can be dissolved in soil solution (passive uptake uses transpiration
  1563                                                             # to estimate the amount of P that can be taken up from the soil solution pool)
  1564    200.0 MiB -25499.5 MiB       23376                       self.sp_available_p = soil_dec.solution_p_equil(self.sp_in_p)
  1565                                                             # Inorganic pool that is adsorbed
  1566    200.0 MiB -25499.5 MiB       23376                       self.sp_in_p -= (self.sp_so_p + self.sp_available_p)
  1567                                         
  1568    200.0 MiB -25499.4 MiB       23376                       self.sp_so_p -= self.pupt[1, step]
  1569                                         
  1570    200.0 MiB -25499.3 MiB       23376                       try:
  1571    200.0 MiB -25499.3 MiB       23376                           t1 = np.all(self.sp_snc > 0.0)
  1572                                                             except:
  1573                                                                 if self.sp_snc is None:
  1574                                                                     self.sp_snc = np.zeros(shape=8,)
  1575                                                                     t1 = True
  1576                                                                 elif self.sp_snc is not None:
  1577                                                                     t1 = True
  1578                                                                 rwarn(f"Exception while handling sp_snc pool")
  1579    200.0 MiB -25499.4 MiB       23376                       if not t1:
  1580                                                                 self.sp_snc[np.where(self.sp_snc < 0)[0]] = 0.0
  1581                                         
  1582                                                             # ORGANIC nutrients uptake
  1583    200.0 MiB -25499.4 MiB       23376                       total_on = self.sp_snc[:4].sum()
  1584    200.0 MiB -25499.4 MiB       23376                       if total_on > 0.0 and np.isfinite(total_on):
  1585    200.0 MiB -178495.6 MiB      163632                           frsn = [i / total_on for i in self.sp_snc[:4]]
  1586                                                             else:
  1587                                                                 frsn = [0.0, 0.0, 0.0, 0.0]
  1588    200.0 MiB -127496.9 MiB      116880                       for i, fr in enumerate(frsn):
  1589    200.0 MiB -101997.6 MiB       93504                           self.sp_snc[i] -= (self.nupt[1, step] * fr)
  1590                                         
  1591    200.0 MiB -25499.3 MiB       23376                       idx = np.where(self.sp_snc < 0.0)[0]
  1592    200.0 MiB -25499.4 MiB       23376                       if len(idx) > 0:
  1593                                                                 self.sp_snc[idx] = 0.0
  1594                                         
  1595    200.0 MiB -25499.4 MiB       23376                       self.sp_organic_n = self.sp_snc[:2].sum()
  1596    200.0 MiB -25499.4 MiB       23376                       self.sp_sorganic_n = self.sp_snc[2:4].sum()
  1597                                         
  1598                                                             # P
  1599    200.0 MiB -25499.4 MiB       23376                       total_op = self.sp_snc[4:].sum()
  1600    200.0 MiB -25499.4 MiB       23376                       if total_op > 0.0 and np.isfinite(total_op):
  1601    200.0 MiB -178495.6 MiB      163632                           frsp = [i / total_op for i in self.sp_snc[4:]]
  1602                                                             else:
  1603                                                                 frsp = [0.0, 0.0, 0.0, 0.0]
  1604    200.0 MiB -127496.9 MiB      116880                       for i, fr in enumerate(frsp):
  1605    200.0 MiB -101997.5 MiB       93504                           self.sp_snc[i + 4] -= (self.pupt[2, step] * fr)
  1606                                         
  1607    200.0 MiB -25499.4 MiB       23376                       idx = np.where(self.sp_snc < 0.0)[0]
  1608    200.0 MiB -25499.4 MiB       23376                       if len(idx) > 0:
  1609                                                                 self.sp_snc[idx] = 0.0
  1610                                         
  1611    200.0 MiB -25499.4 MiB       23376                       self.sp_organic_p = self.sp_snc[4:6].sum()
  1612    200.0 MiB -25499.4 MiB       23376                       self.sp_sorganic_p = self.sp_snc[6:].sum()
  1613                                                         # END SOIL NUTRIENT DYNAMICS
  1614                                         
  1615    200.0 MiB -25499.4 MiB       23376                   if save:
  1616                                                             # Plant uptake and Carbon costs of nutrient uptake
  1617    200.0 MiB -25499.4 MiB       23376                       self.storage_pool[:, step] = masked_mean_2D(self.metacomm.mask, storage_pool.astype(np.float32))
  1618    200.0 MiB -25499.4 MiB       23376                       self.carbon_costs[step] = masked_mean(self.metacomm.mask, cc)
  1619    200.0 MiB -25499.3 MiB       23376                       self.tsoil.append(self.soil_temp)
  1620    200.0 MiB -25499.3 MiB       23376                       self.photo[step] = masked_mean(self.metacomm.mask, photo)
  1621    200.0 MiB -25499.3 MiB       23376                       self.aresp[step] = masked_mean(self.metacomm.mask, aresp)
Filename: C:\Users\darel\OneDrive\Desktop\CAETE\src\caete.py

Line #    Mem usage    Increment  Occurrences   Line Contents
=============================================================
  1013    189.0 MiB    189.0 MiB           1       @profile
  1014                                             # @timer
  1015                                             def run_gridcell(self,
  1016                                                           start_date: str,
  1017                                                           end_date: str,
  1018                                                           spinup: int = 0,
  1019                                                           fixed_co2_atm_conc: Optional[str] | Optional[int] | Optional[float] = None,
  1020                                                           save: bool = True,
  1021                                                           nutri_cycle: bool = True,
  1022                                                           afex: bool = False,
  1023                                                           reset_community: bool = False,
  1024                                                           kill_and_reset: bool = False,
  1025                                                           env_filter: bool = False,
  1026                                                           process_limitation: bool = False,
  1027                                                           verbose: bool = False):
  1028                                                 """
  1029                                                 Run the model for a grid cell.
  1030                                         
  1031                                                 CAETÊ-DVM execution in the start_date - end_date period, can be used for spinup or transient runs.
  1032                                         
  1033                                                 Args:
  1034                                                     start_date (str): Start date for model execution in "yyyymmdd" format.
  1035                                                     end_date (str): End date for model execution in "yyyymmdd" format.
  1036                                                     spinup (int, optional): Number of repetitions in spinup. Set to 0 for a transient run between start_date and end_date. Default is 0.
  1037                                                     fixed_co2_atm_conc (Optional[Union[str, int, float]]): Fixed atmospheric CO2 concentration. If None, use dynamic CO2 levels from a predefined file. If a string with a year (e.g., "1987") That year's value in the provided file will be used. Use a float to set a fixed level in ppm. Default is None.
  1038                                                     save (bool, optional): Whether to save the results. Default is True.
  1039                                                     nutri_cycle (bool, optional): Whether to include nutrient cycling in the model. Default is True.
  1040                                                     afex (bool, optional): Whether to apply nutrient addition to soil in the model. Default is False.
  1041                                                     reset_community (bool, optional): Whether to restart a new community if there are not viable PLS. Default is False.
  1042                                                     kill_and_reset (bool, optional): Whether to kill and reset the community structure at the end of execution (only CVEG pools and PLS IDs). Default is False.
  1043                                                     env_filter (bool, optional): Whether to apply environmental filtering (Include new PLS periodically) []. Default is False.
  1044                                                     verbose (bool, optional): Whether to print detailed logs during execution. Default is False.
  1045                                         
  1046                                                 Returns:
  1047                                                     None
  1048                                         
  1049                                                 Notes:
  1050                                                     - If reset_community is true a new community will be set (reset) when there is no PLSs remaining.
  1051                                                     - If the kill_and_reset is true, after n spins (integer given by spinup parameter - i.e. in the end
  1052                                                       of function execution) all the communities in a gridcell are reset. The reset_community and
  1053                                                       kill_and_reset  arguments are not mutually exclusive. You can use both as true at the same time.
  1054                                                     - The env_filter argument is used to define if new unique PLSs from the main table will be
  1055                                                       seed in the communities that have free slots (PLSs that are not producing). At the moment, the
  1056                                                       interval for the env_filter to add a new PLS to the community is set to  ~15 days.
  1057                                                       If env filter argument is true, then the reset_community argument will have a very low
  1058                                                       probability to trigger a reset because the communities will be constantly filled with new PLS.
  1059                                                       Nonetheless, the reset_community argument will still be able to trigger a reset if the community loses all PLSs.
  1060                                                       With the probability of a reset_community increasing as the interval between new seeds increases. The parameter doy_months
  1061                                                       in the config file (caete.toml) is used to define the interval for the env_filter to add a new PLS to the community.
  1062                                         
  1063                                                       TODO: Implement a more flexible way to define the interval for
  1064                                                             the env_filter to add a new PLS to the community.
  1065                                                 """
  1066                                         
  1067    189.0 MiB      0.0 MiB           1           assert not fixed_co2_atm_conc or\
  1068                                                     isinstance(fixed_co2_atm_conc, str) or\
  1069                                                     fixed_co2_atm_conc > 0,\
  1070                                                         "A fixed value for ATM[CO2] must be a positive number greater than zero or a proper string with the year - e.g., 'yyyy'"
  1071                                         
  1072                                         
  1073                                                 # Define start and end dates (read parameters)
  1074    189.0 MiB      0.1 MiB           1           start = parse_date(start_date)
  1075    189.0 MiB      0.0 MiB           1           end = parse_date(end_date)
  1076                                         
  1077                                                 # Check dates
  1078    189.0 MiB      0.0 MiB           1           assert start < end, "Start date must be before end date"
  1079    189.0 MiB      0.0 MiB           1           assert start >= self.start_date, "initial date out of bounds for the time array"
  1080    189.0 MiB      0.0 MiB           1           assert end <= self.end_date, f"Final date out of bounds for the time array"
  1081                                         
  1082                                         
  1083                                                 # Define time index bounds for this run
  1084                                                 # During a run we are in general using a slice ov the available time span
  1085                                                 # to run the model. For example, we can run the model for a year or a decade
  1086                                                 # at the begining of the input data time series to spin up. This slice is defined
  1087                                                 # by the start and end dates provided in the arguments. Here we get the indices.
  1088    189.1 MiB      0.1 MiB           1           self.start_index = int(cftime.date2num(start, self.time_unit, self.calendar))
  1089    189.1 MiB      0.0 MiB           1           self.end_index =   int(cftime.date2num(end, self.time_unit, self.calendar))
  1090                                         
  1091                                                 # Find the indices in the time array [used to slice the timeseries with driver data  - tas, pr, etc.]
  1092    189.4 MiB      0.3 MiB           1           lower_bound, upper_bound = self.find_index(self.start_index, self.end_index)
  1093                                         
  1094                                                 # Define the time steps range (days)
  1095    189.4 MiB      0.0 MiB           1           steps = np.arange(lower_bound, upper_bound + 1, dtype=np.int64)
  1096                                         
  1097                                                 # Define the number of repetitions for the spinup
  1098    189.4 MiB      0.0 MiB           1           spin = 1 if spinup == 0 else spinup
  1099                                         
  1100                                                 # Define the AFEX mode
  1101    189.4 MiB      0.0 MiB           1           afex_mode = self.afex_config.afex_mode # type: ignore
  1102                                         
  1103                                                 # Slice&Catch climatic input and make conversions
  1104    189.4 MiB      0.0 MiB           1           cv = self.config.conversion_factors_isimip # type: ignore
  1105                                         
  1106                                         
  1107    189.4 MiB      0.0 MiB           1           if self.config.input_handler.input_method == "ih" and self.config.input_handler.input_type == "netcdf":
  1108                                                     # Variables in Netcdf files are already in proprer units
  1109    189.4 MiB      0.0 MiB           1               temp: NDArray[np.float32] = self.tas[lower_bound: upper_bound + 1]   # Air temp: model uses °C
  1110    189.4 MiB      0.0 MiB           1               prec: NDArray[np.float32] = self.pr[lower_bound: upper_bound + 1]    # Precipitation: model uses  mm/day
  1111    189.4 MiB      0.0 MiB           1               p_atm: NDArray[np.float32] = self.ps[lower_bound: upper_bound + 1]   # Atmospheric pressure: model uses hPa
  1112    189.4 MiB      0.0 MiB           1               ipar: NDArray[np.float32] = self.rsds[lower_bound: upper_bound + 1]  # PAR: model uses  mol(photons) m-2 s-1
  1113    189.4 MiB      0.0 MiB           1               ru: NDArray[np.float32] = self.rhs[lower_bound: upper_bound + 1]     # Relative humidity: model uses 0-1
  1114                                                 else:
  1115                                                     temp: NDArray[np.float32] = self.tas[lower_bound: upper_bound + 1] - cv.tas    # Air temp: model uses °C
  1116                                                     prec: NDArray[np.float32] = self.pr[lower_bound: upper_bound + 1] * cv.pr      # Precipitation: model uses  mm/day
  1117                                                     p_atm: NDArray[np.float32] = self.ps[lower_bound: upper_bound + 1] * cv.ps     # Atmospheric pressure: model uses hPa
  1118                                                     ipar: NDArray[np.float32] = self.rsds[lower_bound: upper_bound + 1] * cv.rsds  # PAR: model uses  mol(photons) m-2 s-1
  1119                                                     ru: NDArray[np.float32] = self.rhs[lower_bound: upper_bound + 1] * cv.rhs      # Relative humidity: model uses 0-1
  1120                                         
  1121                                                 # Define the daily values for co2 concentrations
  1122    189.4 MiB      0.0 MiB           1           co2_daily_values = np.zeros(steps.size, dtype=np.float32)
  1123                                         
  1124    189.4 MiB      0.0 MiB           1           if fixed_co2_atm_conc is None:
  1125                                                     # In this case, the co2 concentration will be updated daily.
  1126                                                     # We interpolate linearly between the yearly values of the atm co2 data
  1127    189.4 MiB      0.0 MiB           1               co2 = self.find_co2(start.year)
  1128    189.4 MiB      0.0 MiB           1               today = datetime(start.year, start.month, start.day, start.hour, start.minute, start.second)
  1129    189.4 MiB      0.0 MiB           1               time_step = timedelta(days=1) # Define the time step
  1130    189.4 MiB      0.0 MiB           1               today -= time_step # The first thing we do next is to add a day to the date. So we go back one day
  1131                                                     # Loop over the days and calculate the co2 concentration for each day
  1132    189.4 MiB      0.0 MiB        5845               for step in range(steps.size):
  1133    189.4 MiB      0.0 MiB        5844                   today += time_step
  1134    189.4 MiB      0.0 MiB        5844                   remaining = (datetime(today.year, 12, 31) - today).days + 1
  1135    189.4 MiB      0.0 MiB        5844                   daily_fraction = (self.find_co2(today.year + 1) - co2) / (remaining + 1)
  1136    189.4 MiB      0.0 MiB        5844                   co2 += daily_fraction
  1137    189.4 MiB      0.0 MiB        5844                   co2_daily_values[step] = co2
  1138                                                 elif isinstance(fixed_co2_atm_conc, int) or isinstance(fixed_co2_atm_conc, float):
  1139                                                     # In this case, the co2 concentration will be fixed according to the numeric value provided in the argument
  1140                                                     co2 = fixed_co2_atm_conc
  1141                                                     co2_daily_values += co2
  1142                                                 elif isinstance(fixed_co2_atm_conc, str):
  1143                                                     # In this case, the co2 concentration will be fixed
  1144                                                     # According to the year provided in the argument
  1145                                                     # as a string. Format "yyyy".
  1146                                                     try:
  1147                                                         co2_year = int(fixed_co2_atm_conc)
  1148                                                     except ValueError:
  1149                                                         raise ValueError(
  1150                                                             "The string(\"yyyy\") must be a number in the {self.start_date.year} - {self.end_date.year} interval")
  1151                                                     co2 = self.find_co2(co2_year)
  1152                                                     co2_daily_values += co2
  1153                                                 else:
  1154                                                     raise ValueError("Invalid value for fixed_co2_atm_conc")
  1155                                         
  1156                                                 # Define variables to track dates
  1157    189.4 MiB      0.0 MiB           1           first_day_of_simulation = datetime(start.year, start.month, start.day, start.hour, start.minute, start.second)
  1158                                                 # Define the time step
  1159    189.4 MiB      0.0 MiB           1           time_step = timedelta(days=1)
  1160                                         
  1161                                                 # Define the object to store the outputs from daily_budget
  1162    189.4 MiB      0.0 MiB           1           daily_output = DailyBudget()
  1163                                         
  1164                                                 # Start loops
  1165                                                 # This outer loop is used to run the model for a number
  1166                                                 # of times defined by the spinup argument. The model is
  1167                                                 # executed repeatedly between the start and end dates
  1168                                                 # provided in the arguments
  1169                                         
  1170    198.7 MiB     -0.0 MiB           5           for s in range(spin):
  1171                                         
  1172    198.7 MiB      4.8 MiB           4               self._allocate_output(steps.size, self.metacomm.comm_npls, len(self.metacomm), save)
  1173                                         
  1174                                                     # Loop over the days
  1175    198.7 MiB      0.0 MiB           4               today = first_day_of_simulation
  1176                                         
  1177                                                     # Go back one day
  1178    198.7 MiB      0.0 MiB           4               today -= time_step
  1179                                         
  1180                                                     # Arrays to store & pass values for each community in a simulated day
  1181    198.7 MiB      0.0 MiB           4               sto =        np.zeros(shape=(3, self.metacomm.comm_npls), order='F')
  1182    198.7 MiB      0.0 MiB           4               cleaf_in =   np.zeros(self.metacomm.comm_npls, order='F')
  1183    198.7 MiB      0.0 MiB           4               cwood_in =   np.zeros(self.metacomm.comm_npls, order='F')
  1184    198.7 MiB      0.0 MiB           4               croot_in =   np.zeros(self.metacomm.comm_npls, order='F')
  1185    198.7 MiB      0.0 MiB           4               uptk_costs = np.zeros(self.metacomm.comm_npls, order='F')
  1186    198.7 MiB      0.0 MiB           4               rnpp_in =    np.zeros(self.metacomm.comm_npls, order='F')
  1187                                         
  1188                                                     # There are two modes of operation: save and not save.
  1189                                                     # In the save == False mode, the arrays are used to store the values that are
  1190                                                     # needed for model iteration, i.e., the values that are used in the next
  1191                                                     # time step. In the save mode, an extra number arrays is created to be used
  1192                                                     # to store the outputs.
  1193    198.7 MiB      0.0 MiB           4               xsize: int = len(self.metacomm) # Number of communities
  1194    198.7 MiB      0.0 MiB           4               evavg: NDArray[np.float32] = np.zeros(xsize, dtype=np.float32)
  1195    198.7 MiB      0.0 MiB           4               epavg: NDArray[np.float32] = np.zeros(xsize, dtype=np.float32)
  1196    198.7 MiB      0.0 MiB           4               rnpp_mt: NDArray[np.float32] = np.zeros(xsize, dtype=np.float32)
  1197                                         
  1198                                                     # We keep track of these to input in SOM dynamics later. They are used for output also
  1199    198.7 MiB      0.0 MiB           4               leaf_litter: NDArray[np.float32] = np.zeros(xsize, dtype=np.float32)
  1200    198.7 MiB      0.0 MiB           4               cwd: NDArray[np.float32] = np.zeros(xsize, dtype=np.float32)
  1201    198.7 MiB      0.0 MiB           4               root_litter: NDArray[np.float32] = np.zeros(xsize, dtype=np.float32)
  1202    198.7 MiB      0.0 MiB           4               lnc: NDArray[np.float32] = np.zeros(shape=(6, xsize), dtype=np.float32)
  1203                                                     # This is added to leaf litter pool (that is basicaly a fast SOM pool)
  1204    198.7 MiB      0.0 MiB           4               c_to_nfixers: NDArray[np.float32]= np.zeros(xsize, dtype=np.float32)
  1205    198.7 MiB      0.0 MiB           4               nupt = np.zeros(shape=(2, xsize), dtype=np.float32)
  1206    198.7 MiB      0.0 MiB           4               pupt = np.zeros(shape=(3, xsize), dtype=np.float32)
  1207                                         
  1208    198.7 MiB      0.0 MiB           4               if save:
  1209    198.7 MiB      0.0 MiB           4                   cc = np.zeros(xsize, dtype=np.float32)
  1210    198.7 MiB      0.0 MiB           4                   photo = np.zeros(xsize, dtype=np.float32)
  1211    198.7 MiB      0.0 MiB           4                   aresp = np.zeros(xsize, dtype=np.float32)
  1212    198.7 MiB      0.0 MiB           4                   npp = np.zeros(xsize, dtype=np.float32)
  1213    198.7 MiB      0.0 MiB           4                   lai = np.zeros(xsize, dtype=np.float32)
  1214    198.7 MiB      0.0 MiB           4                   rcm = np.zeros(xsize, dtype=np.float32)
  1215    198.7 MiB      0.0 MiB           4                   f5 = np.zeros(xsize, dtype=np.float32)
  1216    198.7 MiB      0.0 MiB           4                   rm = np.zeros(xsize, dtype=np.float32)
  1217    198.7 MiB      0.0 MiB           4                   rg = np.zeros(xsize, dtype=np.float32)
  1218    198.7 MiB      0.0 MiB           4                   wue = np.zeros(xsize, dtype=np.float32)
  1219    198.7 MiB      0.0 MiB           4                   cue = np.zeros(xsize, dtype=np.float32)
  1220    198.7 MiB      0.0 MiB           4                   carbon_deficit = np.zeros(xsize, dtype=np.float32)
  1221    198.7 MiB      0.0 MiB           4                   vcmax = np.zeros(xsize, dtype=np.float32)
  1222    198.7 MiB      0.0 MiB           4                   specific_la = np.zeros(xsize, dtype=np.float32)
  1223    198.7 MiB      0.0 MiB           4                   storage_pool = np.zeros(shape=(3, xsize))
  1224                                         
  1225    198.7 MiB      0.0 MiB           4                   if process_limitation:
  1226                                                             lim_status_y_leaf = np.ma.masked_all((xsize, self.metacomm.comm_npls, 366), dtype=np.int8)
  1227                                                             lim_status_y_stem = np.ma.masked_all((xsize, self.metacomm.comm_npls, 366), dtype=np.int8)
  1228                                                             lim_status_y_root = np.ma.masked_all((xsize, self.metacomm.comm_npls, 366), dtype=np.int8)
  1229                                                             uptake_strategy_n = np.ma.masked_all((xsize, self.metacomm.comm_npls, 366), dtype=np.int8)
  1230                                                             uptake_strategy_p = np.ma.masked_all((xsize, self.metacomm.comm_npls, 366), dtype=np.int8)
  1231                                         
  1232                                                     # <- Daily loop
  1233    200.5 MiB -25954.3 MiB       23380               for step in range(steps.size):
  1234    200.5 MiB -25952.2 MiB       23376                   today += time_step
  1235    200.5 MiB -25952.2 MiB       23376                   julian_day = today.timetuple().tm_yday
  1236                                         
  1237                                                         # Get the co2 concentration for the day
  1238    200.5 MiB -25952.2 MiB       23376                   co2 = co2_daily_values[step]
  1239                                                         # Update soil temperature
  1240    200.5 MiB -25952.0 MiB       23376                   self.soil_temp = st.soil_temp(self.soil_temp, temp[step])
  1241                                         
  1242                                                         # AFEX
  1243    200.5 MiB -25952.1 MiB       23376                   if afex and julian_day == 365:
  1244                                                             self.add_soil_nutrients(afex_mode)
  1245                                         
  1246                                                         # Loop over communities
  1247    200.5 MiB -25952.2 MiB       23376                   living_pls = 0 # Sum of living PLS in the communities
  1248    200.5 MiB -51176.8 MiB       46752                   for i, community in enumerate(self.metacomm):
  1249                                                             # if i >= len(self.metacomm):
  1250                                                             #     break
  1251                                                             # if community.masked:
  1252                                                             #     # skip this one
  1253                                                             #     continue
  1254    200.5 MiB -25951.9 MiB       23376                       sto[0, :] = inflate_array(community.npls, community.vp_sto[0, :], community.vp_lsid)
  1255    200.5 MiB -25952.2 MiB       23376                       sto[1, :] = inflate_array(community.npls, community.vp_sto[1, :], community.vp_lsid)
  1256    200.5 MiB -25952.2 MiB       23376                       sto[2, :] = inflate_array(community.npls, community.vp_sto[2, :], community.vp_lsid)
  1257                                         
  1258    200.5 MiB -25951.9 MiB       23376                       cleaf_in[:] = inflate_array(community.npls, community.vp_cleaf, community.vp_lsid)
  1259    200.5 MiB -25952.2 MiB       23376                       cwood_in[:] = inflate_array(community.npls, community.vp_cwood, community.vp_lsid)
  1260    200.5 MiB -25952.2 MiB       23376                       croot_in[:] = inflate_array(community.npls, community.vp_croot, community.vp_lsid)
  1261    200.5 MiB -25952.2 MiB       23376                       uptk_costs[:] = inflate_array(community.npls, community.sp_uptk_costs, community.vp_lsid)
  1262    200.5 MiB -25952.2 MiB       23376                       rnpp_in[:] = inflate_array(community.npls, community.construction_npp, community.vp_lsid)
  1263                                         
  1264    200.5 MiB -25952.2 MiB       23376                       ton = self.sp_organic_n #+ self.sp_sorganic_n
  1265    200.5 MiB -25952.2 MiB       23376                       top = self.sp_organic_p #+ self.sp_sorganic_p
  1266                                         
  1267                                                             # Community daily budget calculation
  1268    200.5 MiB -51905.8 MiB       46752                       out = model.daily_budget(community.pls_array, self.wp_water_upper_mm,
  1269    200.5 MiB -25952.2 MiB       23376                                               self.wp_water_lower_mm, self.soil_temp, temp[step],
  1270    200.5 MiB -25952.2 MiB       23376                                               p_atm[step], ipar[step], ru[step], self.sp_available_n,
  1271    200.5 MiB -25952.2 MiB       23376                                               self.sp_available_p, ton, top, self.sp_organic_p,
  1272    200.5 MiB -25952.2 MiB       23376                                               co2, sto, cleaf_in, cwood_in, croot_in, uptk_costs,self.wmax_mm,
  1273    200.5 MiB -25952.2 MiB       23376                                               rnpp_in)
  1274                                         
  1275                                                             # get daily budget results
  1276    200.4 MiB -25955.0 MiB       23376                       daily_output.update(out)
  1277                                         
  1278                                                             # Update the community status
  1279    200.4 MiB -24859.3 MiB       23376                       community.update_lsid(daily_output.ocpavg)
  1280                                         
  1281                                                             # Abort community if no PLSs are left while saving the spin
  1282    200.4 MiB -24859.6 MiB       23376                       if community.masked and save:
  1283                                                                 continue
  1284                                         
  1285    200.4 MiB -24859.7 MiB       23376                       community.ls = community.vp_lsid.size
  1286                                                             # # Restore or seed PLS
  1287    200.4 MiB -24859.6 MiB       23376                       if env_filter and (community.ls < self.metacomm.comm_npls) and not save:
  1288                                                                 if julian_day in self.doy_months:
  1289                                                                     new_id, new_PLS = community.get_unique_pls(self.get_from_main_array)
  1290                                                                     community.seed_pls(new_id, new_PLS, daily_output.cleafavg_pft,
  1291                                                                                        daily_output.cfrootavg_pft, daily_output.cawoodavg_pft)
  1292                                                                     if verbose: print(f"PLS seed in Community {i}: Gridcell: {self.lat} °N, {self.lon} °E: In spin:{s}, step:{step}")
  1293                                         
  1294                                                                     daily_output.ocpavg = pft_area_frac64(daily_output.cleafavg_pft,
  1295                                                                                                     daily_output.cfrootavg_pft,
  1296                                                                                                     daily_output.cawoodavg_pft)
  1297                                                                     community.update_lsid(daily_output.ocpavg)
  1298                                                                     community.ls = community.vp_lsid.size
  1299                                                                 # endif
  1300                                         
  1301                                         
  1302    200.4 MiB -24859.7 MiB       23376                       community.vp_ocp = daily_output.ocpavg[community.vp_lsid]
  1303    200.4 MiB -24859.7 MiB       23376                       community.vp_cleaf = daily_output.cleafavg_pft[community.vp_lsid]
  1304    200.4 MiB -24859.7 MiB       23376                       community.vp_cwood = daily_output.cawoodavg_pft[community.vp_lsid]
  1305    200.4 MiB -24859.7 MiB       23376                       community.vp_croot = daily_output.cfrootavg_pft[community.vp_lsid]
  1306    200.4 MiB -24859.6 MiB       23376                       community.vp_sto = daily_output.stodbg[:, community.vp_lsid].astype('float32')
  1307    200.4 MiB -24859.6 MiB       23376                       community.sp_uptk_costs = daily_output.npp2pay[community.vp_lsid]
  1308    200.4 MiB -24859.7 MiB       23376                       community.construction_npp = daily_output.rnpp_out[community.vp_lsid]
  1309    200.5 MiB -24859.6 MiB       23376                       living_pls += community.ls
  1310                                                             # print(f"Community storage: {community.vp_sto[0, :]}")
  1311                                                             # print(f"Sto_budget_out {daily_output.stodbg[0, :]}")
  1312                                         
  1313                                                             # Limiting nutrient organization:
  1314                                                             # dim1 = leaf wood root, code: 1=N 2=P 4=N,COLIM 5=P,COLIM 6=COLIM 0=NOLIM
  1315    200.5 MiB -25224.5 MiB       23376                       if save:
  1316    200.5 MiB -25224.5 MiB       23376                           if process_limitation:
  1317                                                                     lim_status_y_leaf[i, :, julian_day - 1] = daily_output.limitation_status[0,:]# type: ignore
  1318                                                                     lim_status_y_stem[i, :, julian_day - 1] = daily_output.limitation_status[1,:]# type: ignore
  1319                                                                     lim_status_y_root[i, :, julian_day - 1] = daily_output.limitation_status[2,:]# type: ignore
  1320                                                                     uptake_strategy_n[i, :, julian_day - 1] = daily_output.uptk_strat[0,:]# type: ignore
  1321                                                                     uptake_strategy_p[i, :, julian_day - 1] = daily_output.uptk_strat[1,:]# type: ignore
  1322                                         
  1323    200.5 MiB -25224.5 MiB       23376                           community.anpp += cw_mean(community.vp_ocp, community.construction_npp.astype(np.float32))
  1324    200.5 MiB -25224.5 MiB       23376                           community.uptake_costs += cw_mean(community.vp_ocp, community.sp_uptk_costs.astype(np.float32))
  1325                                         
  1326    200.5 MiB -25224.5 MiB       23376                       if save and julian_day == 365:
  1327    198.6 MiB    -69.2 MiB          64                           community.cleaf = cw_mean(community.vp_ocp, community.vp_cleaf.astype(np.float32))
  1328    198.6 MiB     -0.8 MiB          64                           community.cwood = cw_mean(community.vp_ocp, community.vp_cwood.astype(np.float32))
  1329    198.6 MiB     -0.8 MiB          64                           community.croot = cw_mean(community.vp_ocp, community.vp_croot.astype(np.float32))
  1330    198.6 MiB     -0.8 MiB          64                           community.csto = cw_mean(community.vp_ocp, community.vp_sto[0, :])
  1331    198.6 MiB     -0.3 MiB          64                           community.shannon_diversity = shannon_diversity(community.vp_ocp)
  1332    198.6 MiB     -0.6 MiB          64                           community.shannon_entropy = shannon_entropy(community.vp_ocp)
  1333    198.6 MiB     -0.5 MiB          64                           community.shannon_evenness = shannon_evenness(community.vp_ocp)
  1334                                         
  1335                                                                 # process limitation data
  1336                                                                 # Filter non living PLS from the limitation status
  1337    198.6 MiB     -0.8 MiB          64                           if process_limitation:
  1338                                                                     _data_leaf = lim_status_y_leaf[i, [community.vp_lsid], :] # type: ignore
  1339                                                                     _data_stem = lim_status_y_stem[i, [community.vp_lsid], :] # type: ignore
  1340                                                                     _data_root = lim_status_y_root[i, [community.vp_lsid], :] # type: ignore
  1341                                         
  1342                                                                     _data_uptake_n = uptake_strategy_n[i, [community.vp_lsid], :]# type: ignore
  1343                                                                     _data_uptake_p = uptake_strategy_p[i, [community.vp_lsid], :]# type: ignore
  1344                                         
  1345                                                                     # Loop over the living PLS to get the unique values and counts
  1346                                                                     pls_lim_leaf = []
  1347                                                                     pls_lim_stem = []
  1348                                                                     pls_lim_root = []
  1349                                                                     pls_uptake_n = []
  1350                                                                     pls_uptake_p = []
  1351                                         
  1352                                                                     for k in range(community.vp_lsid.size):
  1353                                                                         # Get the unique values and counts for leaf limitation
  1354                                                                         unique, counts = np.unique(_data_leaf[0, k, :], return_counts=True)
  1355                                                                         unique = unique.data[unique.mask == False] # type: ignore
  1356                                                                         pls_lim_leaf.append((unique, counts[:unique.size])) # type: ignore
  1357                                         
  1358                                                                         # Stem limitation
  1359                                                                         unique, counts = np.unique(_data_stem[0, k, :], return_counts=True)
  1360                                                                         unique = unique.data[unique.mask == False] # type: ignore
  1361                                                                         pls_lim_stem.append((unique, counts[:unique.size])) # type: ignore
  1362                                         
  1363                                                                         # Root limitation
  1364                                                                         unique, counts = np.unique(_data_root[0, k, :], return_counts=True)
  1365                                                                         unique = unique.data[unique.mask == False]
  1366                                                                         pls_lim_root.append((unique, counts[:unique.size])) # type: ignore
  1367                                         
  1368                                                                         # Uptake strategy N
  1369                                                                         unique, counts = np.unique(_data_uptake_n[0, k, :], return_counts=True)
  1370                                                                         unique = unique.data[unique.mask == False] # type: ignore
  1371                                                                         pls_uptake_n.append((unique, counts[:unique.size])) # type: ignore
  1372                                         
  1373                                                                         # Uptake strategy P
  1374                                                                         unique, counts = np.unique(_data_uptake_p[0, k, :], return_counts=True)
  1375                                                                         unique = unique.data[unique.mask == False]  # type: ignore
  1376                                                                         pls_uptake_p.append((unique, counts[:unique.size])) # type: ignore
  1377                                         
  1378                                                                     community.limitation_status_leaf = pls_lim_leaf
  1379                                                                     community.limitation_status_wood = pls_lim_stem
  1380                                                                     community.limitation_status_root = pls_lim_root
  1381                                                                     community.uptake_strategy_n = pls_uptake_n
  1382                                                                     community.uptake_strategy_p = pls_uptake_p
  1383                                         
  1384                                                                     # Reset the limitation masked arrays
  1385                                                                     lim_status_y_leaf.mask[i, :, :] = np.ones((self.metacomm.comm_npls, 366), dtype=bool) # type: ignore
  1386                                                                     lim_status_y_stem.mask[i, :, :] = np.ones((self.metacomm.comm_npls, 366), dtype=bool) # type: ignore
  1387                                                                     lim_status_y_root.mask[i, :, :] = np.ones((self.metacomm.comm_npls, 366), dtype=bool) # type: ignore
  1388                                                                     uptake_strategy_n.mask[i, :, :] = np.ones((self.metacomm.comm_npls, 366), dtype=bool) # type: ignore
  1389                                                                     uptake_strategy_p.mask[i, :, :] = np.ones((self.metacomm.comm_npls, 366), dtype=bool) # type: ignore
  1390                                                                 else:
  1391    198.6 MiB     -0.8 MiB          64                               pass
  1392                                         
  1393    200.5 MiB -25156.1 MiB       23376                       if community.vp_lsid.size < 1:
  1394                                                                 if verbose: print(f"Empty community {i}: Gridcell: {self.lat} °N, {self.lon} °E: In spin:{s}, step:{step}")
  1395                                                                 if reset_community:
  1396                                                                     assert not save, "Cannot save data when resetting communities"
  1397                                                                     if verbose: print(f"Reseting community {i}: Gridcell: {self.lat} °N, {self.lon} °E: In spin:{s}, step:{step}")
  1398                                         
  1399                                                                     new_life_strategies = self.get_from_main_array(community.npls)
  1400                                                                     community.restore_from_main_table(new_life_strategies)
  1401                                                                     # continue
  1402                                         
  1403                                                                 else:
  1404                                                                     # In the transiant run - i.e., when reset_community is false and
  1405                                                                     # kill_and_reset is false; we mask the community if there is no PLS
  1406                                                                     self.metacomm.mask[i] = np.int8(1)
  1407                                                                     # Set mask to true for this community, will not run in the next steps
  1408                                                                     # Set annual values to zero
  1409                                                                     community.masked = np.int8(1)
  1410                                                                     community.cleaf = np.float32(0.0)
  1411                                                                     community.cwood = np.float32(0.0)
  1412                                                                     community.croot = np.float32(0.0)
  1413                                                                     community.csto  = np.float32(0.0)
  1414                                                                     community.shannon_diversity = -9999.0
  1415                                                                     community.shannon_entropy = -9999.0
  1416                                                                     community.shannon_evenness = -9999.0
  1417                                                                     # if the reset_community is true
  1418                                                                     # continue # cycle
  1419                                         
  1420                                                             # Store values for each community
  1421    200.5 MiB -25224.5 MiB       23376                       rnpp_mt[i] = cw_mean(community.vp_ocp, community.construction_npp.astype(np.float32)) # Community Weighted rNPP
  1422    200.5 MiB -25224.5 MiB       23376                       leaf_litter[i] = daily_output.litter_l
  1423    200.5 MiB -25224.5 MiB       23376                       root_litter[i] = daily_output.litter_fr
  1424    200.5 MiB -25224.5 MiB       23376                       cwd[i] = daily_output.cwd
  1425    200.5 MiB -25224.5 MiB       23376                       lnc[:, i] = daily_output.lnc.astype(np.float32)
  1426    200.5 MiB -25224.5 MiB       23376                       c_to_nfixers[i] = daily_output.cp[3]
  1427    200.5 MiB -25224.5 MiB       23376                       evavg[i] = daily_output.evavg
  1428    200.5 MiB -25224.5 MiB       23376                       epavg[i] = daily_output.epavg
  1429    200.5 MiB -25224.5 MiB       23376                       nupt[:, i] = daily_output.nupt #type: ignore
  1430    200.5 MiB -25224.5 MiB       23376                       pupt[:, i] = daily_output.pupt #type: ignore
  1431                                         
  1432    200.5 MiB -25224.5 MiB       23376                       if save:
  1433    200.5 MiB -25224.4 MiB       23376                           cc[i] = daily_output.c_cost_cwm #type: ignore
  1434    200.5 MiB -25224.4 MiB       23376                           npp[i] = daily_output.nppavg #type: ignore
  1435    200.5 MiB -25224.4 MiB       23376                           photo[i] = daily_output.phavg #type: ignore
  1436    200.5 MiB -25224.4 MiB       23376                           aresp[i] = daily_output.aravg #type: ignore
  1437    200.5 MiB -25224.4 MiB       23376                           lai[i] = daily_output.laiavg #type: ignore
  1438    200.5 MiB -25224.4 MiB       23376                           rcm[i] = daily_output.rcavg #type: ignore
  1439    200.5 MiB -25224.4 MiB       23376                           f5[i] = daily_output.f5avg #type: ignore
  1440    200.5 MiB -25224.4 MiB       23376                           rm[i] = daily_output.rmavg #type: ignore
  1441    200.5 MiB -25224.4 MiB       23376                           rg[i] = daily_output.rgavg #type: ignore
  1442    200.5 MiB -25224.4 MiB       23376                           wue[i] = daily_output.wueavg #type: ignore
  1443    200.5 MiB -25224.4 MiB       23376                           cue[i] = daily_output.cueavg #type: ignore
  1444    200.5 MiB -25224.4 MiB       23376                           carbon_deficit[i] = daily_output.c_defavg #type: ignore
  1445    200.5 MiB -25224.4 MiB       23376                           vcmax[i] = daily_output.vcmax #type: ignore
  1446    200.5 MiB -25224.4 MiB       23376                           specific_la[i] = daily_output.specific_la #type: ignore
  1447                                         
  1448    200.5 MiB -100898.1 MiB       93504                           for j in range(daily_output.stodbg.shape[0]):
  1449    200.5 MiB -75673.9 MiB       70128                               storage_pool[j, i] = cw_mean(community.vp_ocp, community.vp_sto[j, :]) #type: ignore
  1450                                         
  1451                                                         #<- Out of the community loop
  1452                                                         # Save annual state of the metacommunity
  1453    200.5 MiB -25954.9 MiB       23376                   if save:
  1454    200.5 MiB -25224.6 MiB       23376                       if julian_day == 365:
  1455    198.6 MiB    -69.2 MiB          64                           y = today.year
  1456                                                                 # m = today.month
  1457                                                                 # d = today.day
  1458    198.6 MiB     -0.8 MiB          64                           filename = self.out_dir/f"metacommunity_{y}.pkz"
  1459                                                                 # filename = self.out_dir/f"metacommunity_{d}{m}{y}.pkz"
  1460    198.6 MiB     -0.4 MiB          64                           self.metacomm.save_state(filename, y, process_limitation)
  1461    198.6 MiB     -0.8 MiB          64                           self.metacomm_output[y] = filename
  1462                                         
  1463    198.6 MiB     -1.5 MiB         128                           for community in self.metacomm:
  1464                                                                     # Set annual accumulators to zero
  1465    198.6 MiB     -0.8 MiB          64                               community.anpp = np.float32(0.0)
  1466    198.6 MiB     -0.8 MiB          64                               community.uptake_costs = np.float32(0.0)
  1467                                         
  1468                                                         # ------------
  1469                                                         # Evapotranspiration
  1470    200.5 MiB -25156.1 MiB       23376                   et = masked_mean(self.metacomm.mask, evavg) #evavg.mean()
  1471                                                         ## Canopy-atmosphere coupling [EXPERIMENTAL]
  1472                                                         # vpd = m.vapor_p_deficit(temp[step], ru[step])
  1473                                                         # et_pot = masked_mean(self.metacomm.mask, np.array(epavg).astype(np.float32)) #epavg.mean()
  1474                                                         # self.evapm[step] = atm_canopy_coupling(et_pot, et, temp[step], vpd)
  1475    200.5 MiB -25224.6 MiB       23376                   self.evapm[step] = et
  1476                                         
  1477                                                         # Update water pools
  1478                                         
  1479    200.5 MiB -25224.5 MiB       23376                   self.runom[step] = self.swp._update_pool(prec[step], self.evapm[step])
  1480    200.5 MiB -25224.6 MiB       23376                   self.swp.w1 = 0.0 if self.swp.w1 < 0.0 else self.swp.w1
  1481    200.5 MiB -25224.6 MiB       23376                   self.swp.w2 = 0.0 if self.swp.w2 < 0.0 else self.swp.w2
  1482    200.5 MiB -25224.5 MiB       23376                   self.wp_water_upper_mm = self.swp.awc1
  1483    200.5 MiB -25589.7 MiB       23376                   self.wp_water_lower_mm = self.swp.awc2
  1484    200.5 MiB -25589.7 MiB       23376                   wtot = self.swp.w1 + self.swp.w2
  1485                                         
  1486                                                         # Update cflux to the soil for output, mean values over the communities
  1487                                                         # Values are also used to update SOM dynamics
  1488    200.5 MiB -51179.5 MiB       46752                   self.litter_l[step] = masked_mean(self.metacomm.mask, leaf_litter) +\
  1489    200.5 MiB -25589.7 MiB       23376                                         masked_mean(self.metacomm.mask, c_to_nfixers)
  1490    200.5 MiB -25589.7 MiB       23376                   self.cwd[step] = masked_mean(self.metacomm.mask, cwd)
  1491    200.5 MiB -25589.7 MiB       23376                   self.litter_fr[step] = masked_mean(self.metacomm.mask, root_litter)
  1492    200.5 MiB -25589.7 MiB       23376                   self.lnc[:, step] = masked_mean_2D(self.metacomm.mask, lnc)
  1493                                         
  1494                                                         # Soil C:N:P balance and OM decomposition
  1495    200.5 MiB -51179.3 MiB       46752                   s_out = soil_dec.carbon3(self.soil_temp, wtot / self.wmax_mm, self.litter_l[step],
  1496    200.5 MiB -25589.7 MiB       23376                                            self.cwd[step], self.litter_fr[step], self.lnc[:, step],
  1497    200.5 MiB -25589.7 MiB       23376                                            self.sp_csoil, self.sp_snc)
  1498    200.5 MiB -25589.7 MiB       23376                   soil_out = catch_out_carbon3(s_out)
  1499                                         
  1500                                                         # Organic C N & P
  1501    200.5 MiB -25589.7 MiB       23376                   self.sp_csoil = soil_out['cs']
  1502    200.5 MiB -25589.7 MiB       23376                   self.sp_snc = np.zeros(shape=8)
  1503    200.5 MiB -25589.7 MiB       23376                   self.sp_snc = soil_out['snc']
  1504    200.5 MiB -25589.6 MiB       23376                   idx = np.where(self.sp_snc < 0.0)[0]
  1505    200.5 MiB -25589.6 MiB       23376                   if len(idx) > 0:
  1506                                                             self.sp_snc[idx] = 0.0
  1507                                         
  1508                                                         # <- Out of the community loop
  1509    200.5 MiB -25589.7 MiB       23376                   self.nupt[:, step] = masked_mean_2D(self.metacomm.mask, nupt)
  1510    200.5 MiB -25589.7 MiB       23376                   self.pupt[:, step] = masked_mean_2D(self.metacomm.mask, pupt)
  1511                                         
  1512                                                         # TODO: Soil nutrient dynamics. Isolate this if branch into a separate method/class/function
  1513                                                         # Critical part of soil nutrient dynamics and availability for plants
  1514                                                         # IF NUTRICYCLE
  1515    200.5 MiB -25589.7 MiB       23376                   if nutri_cycle:
  1516                                                             # UPDATE ORGANIC POOLS
  1517    200.5 MiB -25589.7 MiB       23376                       self.sp_organic_n = self.sp_snc[:2].sum()
  1518    200.5 MiB -25589.7 MiB       23376                       self.sp_sorganic_n = self.sp_snc[2:4].sum()
  1519    200.5 MiB -25589.7 MiB       23376                       self.sp_organic_p = self.sp_snc[4:6].sum()
  1520    200.5 MiB -25589.7 MiB       23376                       self.sp_sorganic_p = self.sp_snc[6:].sum()
  1521                                         
  1522                                                             # Update inorganic pools
  1523    200.5 MiB -25589.7 MiB       23376                       self.sp_available_p += soil_out['pmin']
  1524    200.5 MiB -25589.7 MiB       23376                       self.sp_available_n += soil_out['nmin']
  1525    200.5 MiB -25589.7 MiB       23376                       self.sp_available_p -= self.pupt[0, step]
  1526    200.5 MiB -25589.7 MiB       23376                       self.sp_available_n -= self.nupt[0, step]
  1527                                         
  1528                                                             # NUTRIENT DINAMICS
  1529                                         
  1530                                                             # Inorganic N
  1531                                                             # TODO: NaNs are being sourced upstream , need to track the source and fix it
  1532                                         
  1533    200.5 MiB -25589.7 MiB       23376                       if not np.isfinite(self.sp_in_n):
  1534                                                                 # rwarn(f"Non-finite value detected in sp_in_n pool at step {step}. Resetting to zero.")
  1535                                                                 self.sp_in_n = 0.0
  1536    200.5 MiB -25589.7 MiB       23376                       if not np.isfinite(self.sp_available_n):
  1537                                                                 # rwarn(f"Non-finite value detected in sp_available_n pool at step {step}. Resetting to zero.")
  1538                                                                 self.sp_available_n = 0.0
  1539    200.5 MiB -25589.7 MiB       23376                       if not np.isfinite(self.sp_so_n):
  1540                                                                 # rwarn(f"Non-finite value detected in sp_so_n pool at step {step}. Resetting to zero.")
  1541                                                                 self.sp_so_n = 0.0
  1542                                         
  1543    200.5 MiB -25589.7 MiB       23376                       self.sp_in_n += self.sp_available_n + self.sp_so_n
  1544    200.5 MiB -25589.7 MiB       23376                       self.sp_so_n = soil_dec.sorbed_n_equil(self.sp_in_n)
  1545    200.5 MiB -25589.7 MiB       23376                       self.sp_available_n = soil_dec.solution_n_equil(self.sp_in_n)
  1546    200.5 MiB -25589.7 MiB       23376                       self.sp_in_n -= (self.sp_so_n + self.sp_available_n)
  1547                                         
  1548                                                             # Inorganic P
  1549    200.5 MiB -25589.7 MiB       23376                       if not np.isfinite(self.sp_in_p):
  1550                                                                 # rwarn(f"Non-finite value detected in sp_in_p pool at step {step}. Resetting to zero.")
  1551                                                                 self.sp_in_p = 0.0
  1552    200.5 MiB -25589.7 MiB       23376                       if not np.isfinite(self.sp_available_p):
  1553                                                                 # rwarn(f"Non-finite value detected in sp_available_p pool at step {step}. Resetting to zero.")
  1554                                                                 self.sp_available_p = 0.0
  1555    200.5 MiB -25589.7 MiB       23376                       if not np.isfinite(self.sp_so_p):
  1556                                                                 # rwarn(f"Non-finite value detected in sp_so_p pool at step {step}. Resetting to zero.")
  1557                                                                 self.sp_so_p = 0.0
  1558                                         
  1559    200.5 MiB -25589.7 MiB       23376                       self.sp_in_p += self.sp_available_p + self.sp_so_p
  1560                                                             # sp_so_p is the occluded P in the inorganic pool
  1561    200.5 MiB -25589.6 MiB       23376                       self.sp_so_p = soil_dec.sorbed_p_equil(self.sp_in_p)
  1562                                                             # THe fraction that can be dissolved in soil solution (passive uptake uses transpiration
  1563                                                             # to estimate the amount of P that can be taken up from the soil solution pool)
  1564    200.5 MiB -25589.6 MiB       23376                       self.sp_available_p = soil_dec.solution_p_equil(self.sp_in_p)
  1565                                                             # Inorganic pool that is adsorbed
  1566    200.5 MiB -25589.6 MiB       23376                       self.sp_in_p -= (self.sp_so_p + self.sp_available_p)
  1567                                         
  1568    200.5 MiB -25589.6 MiB       23376                       self.sp_so_p -= self.pupt[1, step]
  1569                                         
  1570    200.5 MiB -25589.6 MiB       23376                       try:
  1571    200.5 MiB -25589.6 MiB       23376                           t1 = np.all(self.sp_snc > 0.0)
  1572                                                             except:
  1573                                                                 if self.sp_snc is None:
  1574                                                                     self.sp_snc = np.zeros(shape=8,)
  1575                                                                     t1 = True
  1576                                                                 elif self.sp_snc is not None:
  1577                                                                     t1 = True
  1578                                                                 rwarn(f"Exception while handling sp_snc pool")
  1579    200.5 MiB -25589.6 MiB       23376                       if not t1:
  1580                                                                 self.sp_snc[np.where(self.sp_snc < 0)[0]] = 0.0
  1581                                         
  1582                                                             # ORGANIC nutrients uptake
  1583    200.5 MiB -25589.6 MiB       23376                       total_on = self.sp_snc[:4].sum()
  1584    200.5 MiB -25589.6 MiB       23376                       if total_on > 0.0 and np.isfinite(total_on):
  1585    200.5 MiB -179127.0 MiB      163632                           frsn = [i / total_on for i in self.sp_snc[:4]]
  1586                                                             else:
  1587                                                                 frsn = [0.0, 0.0, 0.0, 0.0]
  1588    200.5 MiB -127948.1 MiB      116880                       for i, fr in enumerate(frsn):
  1589    200.5 MiB -102358.6 MiB       93504                           self.sp_snc[i] -= (self.nupt[1, step] * fr)
  1590                                         
  1591    200.5 MiB -25589.6 MiB       23376                       idx = np.where(self.sp_snc < 0.0)[0]
  1592    200.5 MiB -25589.6 MiB       23376                       if len(idx) > 0:
  1593                                                                 self.sp_snc[idx] = 0.0
  1594                                         
  1595    200.5 MiB -25589.6 MiB       23376                       self.sp_organic_n = self.sp_snc[:2].sum()
  1596    200.5 MiB -25589.6 MiB       23376                       self.sp_sorganic_n = self.sp_snc[2:4].sum()
  1597                                         
  1598                                                             # P
  1599    200.5 MiB -25589.6 MiB       23376                       total_op = self.sp_snc[4:].sum()
  1600    200.5 MiB -25589.6 MiB       23376                       if total_op > 0.0 and np.isfinite(total_op):
  1601    200.5 MiB -179127.3 MiB      163632                           frsp = [i / total_op for i in self.sp_snc[4:]]
  1602                                                             else:
  1603                                                                 frsp = [0.0, 0.0, 0.0, 0.0]
  1604    200.5 MiB -129406.8 MiB      116880                       for i, fr in enumerate(frsp):
  1605    200.5 MiB -103817.2 MiB       93504                           self.sp_snc[i + 4] -= (self.pupt[2, step] * fr)
  1606                                         
  1607    200.5 MiB -25954.3 MiB       23376                       idx = np.where(self.sp_snc < 0.0)[0]
  1608    200.5 MiB -25954.3 MiB       23376                       if len(idx) > 0:
  1609                                                                 self.sp_snc[idx] = 0.0
  1610                                         
  1611    200.5 MiB -25954.3 MiB       23376                       self.sp_organic_p = self.sp_snc[4:6].sum()
  1612    200.5 MiB -25954.3 MiB       23376                       self.sp_sorganic_p = self.sp_snc[6:].sum()
  1613                                                         # END SOIL NUTRIENT DYNAMICS
  1614                                         
  1615    200.5 MiB -25954.3 MiB       23376                   if save:
  1616                                                             # Plant uptake and Carbon costs of nutrient uptake
  1617    200.5 MiB -25954.3 MiB       23376                       self.storage_pool[:, step] = masked_mean_2D(self.metacomm.mask, storage_pool.astype(np.float32))
  1618    200.5 MiB -25954.3 MiB       23376                       self.carbon_costs[step] = masked_mean(self.metacomm.mask, cc)
  1619    200.5 MiB -25954.3 MiB       23376                       self.tsoil.append(self.soil_temp)
  1620    200.5 MiB -25954.3 MiB       23376                       self.photo[step] = masked_mean(self.metacomm.mask, photo)
  1621    200.5 MiB -25954.3 MiB       23376                       self.aresp[step] = masked_mean(self.metacomm.mask, aresp)
  1622    200.0 MiB -25499.3 MiB       23376                       self.npp[step] = masked_mean(self.metacomm.mask, npp)
  1623    200.0 MiB -25499.3 MiB       23376                       self.rnpp[step] = masked_mean(self.metacomm.mask, rnpp_mt)
  1624    200.0 MiB -25499.3 MiB       23376                       self.lai[step] = masked_mean(self.metacomm.mask, lai)
  1625    200.0 MiB -25499.3 MiB       23376                       self.rcm[step] = masked_mean(self.metacomm.mask, rcm)
  1626    200.0 MiB -25499.3 MiB       23376                       self.f5[step] = masked_mean(self.metacomm.mask, f5)
  1627    200.0 MiB -25499.3 MiB       23376                       self.rm[step] = masked_mean(self.metacomm.mask, rm)
  1628    200.0 MiB -25499.3 MiB       23376                       self.rg[step] = masked_mean(self.metacomm.mask, rg)
  1629    200.0 MiB -25499.3 MiB       23376                       self.wue[step] = masked_mean(self.metacomm.mask, wue)
  1630    200.0 MiB -25499.3 MiB       23376                       self.cue[step] = masked_mean(self.metacomm.mask, cue)
  1631    200.0 MiB -25499.3 MiB       23376                       self.carbon_deficit[step] = masked_mean(self.metacomm.mask, carbon_deficit)
  1632    200.0 MiB -25499.3 MiB       23376                       self.vcmax[step] = masked_mean(self.metacomm.mask, vcmax)
  1633    200.0 MiB -25499.3 MiB       23376                       self.specific_la[step] = masked_mean(self.metacomm.mask, specific_la)
  1634    200.0 MiB -25499.3 MiB       23376                       self.hresp[step] = soil_out['hr']
  1635    200.0 MiB -25499.3 MiB       23376                       self.csoil[:, step] = soil_out['cs']
  1636    200.0 MiB -25499.3 MiB       23376                       self.wsoil[step] = self.swp.calc_total_water()
  1637    200.0 MiB -25499.3 MiB       23376                       self.inorg_n[step] = self.sp_in_n
  1638    200.0 MiB -25499.2 MiB       23376                       self.inorg_p[step] = self.sp_in_p
  1639    200.0 MiB -25499.3 MiB       23376                       self.sorbed_n[step] = self.sp_so_n
  1640    200.0 MiB -25499.3 MiB       23376                       self.sorbed_p[step] = self.sp_so_p
  1641    200.0 MiB -25499.3 MiB       23376                       self.snc[:, step] = soil_out['snc']
  1642    200.0 MiB -25499.3 MiB       23376                       self.nmin[step] = self.sp_available_n
  1643    200.0 MiB -25499.3 MiB       23376                       self.pmin[step] = self.sp_available_p
  1644    200.0 MiB -25499.3 MiB       23376                       self.ls[step] = living_pls
  1645                                         
  1646                                                     # <- Out of the daily loop
  1647                                                     # Save the spin data
  1648                                                     sv: Thread
  1649    198.1 MiB     -4.4 MiB           4               if save:
  1650    198.1 MiB     -0.0 MiB           4                   if s > 0:
  1651    198.1 MiB     -0.0 MiB           3                       sv.join()  # Wait for the previous thread to finish
  1652    198.1 MiB     -0.0 MiB           3                       self.flush_data = None
  1653    198.1 MiB     -0.0 MiB           4                   self.executed_iterations.append((start_date, end_date))
  1654    198.1 MiB      0.0 MiB           8                   self.flush_data = self._flush_output(
  1655    198.1 MiB     -0.0 MiB           4                       'spin', (self.start_index, self.end_index))
  1656    198.1 MiB     -0.0 MiB           4                   sv = Thread(target=self._save_output, args=(self.flush_data,))
  1657    198.1 MiB      0.2 MiB           4                   sv.start()
  1658                                                 # <- Out of spin loop
  1659                                                 # Manage the last thread
  1660    198.1 MiB     -0.0 MiB           1           if save:
  1661    195.8 MiB     -2.4 MiB           1               sv.join()  # Wait for the last thread to finish
  1662    195.8 MiB      0.0 MiB           1               self.flush_data = None
  1663                                         
  1664                                         
  1665                                                 # Restablish new communities in the end, if applicable
  1666    195.7 MiB     -0.0 MiB           1           if kill_and_reset:
  1667                                                     assert not save, "Cannot save data when resetting communities"
  1668                                                     for community in self.metacomm:
  1669                                                         # with lock:
  1670                                                         new_life_strategies = self.get_from_main_array(community.npls)
  1671                                                         community.restore_from_main_table(new_life_strategies)
  1672                                                     # Here we update the metacomm mask to ensure that all communities are active again
  1673                                                     self.metacomm.update_mask()
  1674                                         
  1675    195.7 MiB      0.0 MiB           1           return None


  1622    200.5 MiB -25954.3 MiB       23376                       self.npp[step] = masked_mean(self.metacomm.mask, npp)
  1623    200.5 MiB -25954.3 MiB       23376                       self.rnpp[step] = masked_mean(self.metacomm.mask, rnpp_mt)
  1624    200.5 MiB -25954.3 MiB       23376                       self.lai[step] = masked_mean(self.metacomm.mask, lai)
  1625    200.5 MiB -25954.3 MiB       23376                       self.rcm[step] = masked_mean(self.metacomm.mask, rcm)
  1626    200.5 MiB -25954.3 MiB       23376                       self.f5[step] = masked_mean(self.metacomm.mask, f5)
  1627    200.5 MiB -25954.3 MiB       23376                       self.rm[step] = masked_mean(self.metacomm.mask, rm)
  1628    200.5 MiB -25954.3 MiB       23376                       self.rg[step] = masked_mean(self.metacomm.mask, rg)
  1629    200.5 MiB -25954.3 MiB       23376                       self.wue[step] = masked_mean(self.metacomm.mask, wue)
  1630    200.5 MiB -25954.3 MiB       23376                       self.cue[step] = masked_mean(self.metacomm.mask, cue)
  1631    200.5 MiB -25954.3 MiB       23376                       self.carbon_deficit[step] = masked_mean(self.metacomm.mask, carbon_deficit)
  1632    200.5 MiB -25954.3 MiB       23376                       self.vcmax[step] = masked_mean(self.metacomm.mask, vcmax)
  1633    200.5 MiB -25954.3 MiB       23376                       self.specific_la[step] = masked_mean(self.metacomm.mask, specific_la)
  1634    200.5 MiB -25954.3 MiB       23376                       self.hresp[step] = soil_out['hr']
  1635    200.5 MiB -25954.3 MiB       23376                       self.csoil[:, step] = soil_out['cs']
  1636    200.5 MiB -25954.3 MiB       23376                       self.wsoil[step] = self.swp.calc_total_water()
  1637    200.5 MiB -25954.3 MiB       23376                       self.inorg_n[step] = self.sp_in_n
  1638    200.5 MiB -25954.3 MiB       23376                       self.inorg_p[step] = self.sp_in_p
  1639    200.5 MiB -25954.3 MiB       23376                       self.sorbed_n[step] = self.sp_so_n
  1640    200.5 MiB -25954.3 MiB       23376                       self.sorbed_p[step] = self.sp_so_p
  1641    200.5 MiB -25954.3 MiB       23376                       self.snc[:, step] = soil_out['snc']
  1642    200.5 MiB -25954.3 MiB       23376                       self.nmin[step] = self.sp_available_n
  1643    200.5 MiB -25954.3 MiB       23376                       self.pmin[step] = self.sp_available_p
  1644    200.5 MiB -25954.2 MiB       23376                       self.ls[step] = living_pls
  1645                                         
  1646                                                     # <- Out of the daily loop
  1647                                                     # Save the spin data
  1648                                                     sv: Thread
  1649    198.6 MiB     -4.5 MiB           4               if save:
  1650    198.6 MiB     -0.0 MiB           4                   if s > 0:
  1651    198.6 MiB     -0.0 MiB           3                       sv.join()  # Wait for the previous thread to finish
  1652    198.6 MiB     -0.0 MiB           3                       self.flush_data = None
  1653    198.6 MiB     -0.0 MiB           4                   self.executed_iterations.append((start_date, end_date))
  1654    198.6 MiB     -0.0 MiB           8                   self.flush_data = self._flush_output(
  1655    198.6 MiB     -0.0 MiB           4                       'spin', (self.start_index, self.end_index))
  1656    198.6 MiB     -0.0 MiB           4                   sv = Thread(target=self._save_output, args=(self.flush_data,))
  1657    198.7 MiB      0.1 MiB           4                   sv.start()
  1658                                                 # <- Out of spin loop
  1659                                                 # Manage the last thread
  1660    198.6 MiB     -0.0 MiB           1           if save:
  1661    196.2 MiB     -2.4 MiB           1               sv.join()  # Wait for the last thread to finish
  1662    196.2 MiB      0.0 MiB           1               self.flush_data = None
  1663                                         
  1664                                         
  1665                                                 # Restablish new communities in the end, if applicable
  1666    196.2 MiB     -0.0 MiB           1           if kill_and_reset:
  1667                                                     assert not save, "Cannot save data when resetting communities"
  1668                                                     for community in self.metacomm:
  1669                                                         # with lock:
  1670                                                         new_life_strategies = self.get_from_main_array(community.npls)
  1671                                                         community.restore_from_main_table(new_life_strategies)
  1672                                                     # Here we update the metacomm mask to ensure that all communities are active again
  1673                                                     self.metacomm.update_mask()
  1674                                         
  1675    196.2 MiB     -0.0 MiB           1           return None



Progress: |██████████████████████████████| 100.00% Complete
Write completed: C:\Users\darel\OneDrive\Desktop\CAETE\outputs\test_new_region\state_files_680c5ef326794c04bdab56ec73321938\region_file_6f3479b8-6efc-499e-b5ec-494bc886f38c.z
mprof: Sampling memory every 0.1s
running new process
